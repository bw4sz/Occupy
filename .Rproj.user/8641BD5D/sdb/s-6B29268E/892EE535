{
    "contents" : "---\ntitle: \"Hierarchical N-mixture Models for species interactions: Empirical Data\"\nauthor: \"Ben Weinstein - Stony Brook University\"\noutput:\n  html_document:\n    toc: true\n    number_sections: true\n    theme: spacelab\n    keep_md: true\n  word_document: default\n---\n\n```{r,warning=FALSE,message=FALSE,echo=FALSE,cache=FALSE}\nlibrary(reshape2)\nlibrary(chron)\nlibrary(ggplot2)\nlibrary(knitr)\nlibrary(R2jags)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(gridExtra)\nlibrary(boot)\nlibrary(bipartite)\n\nopts_chunk$set(message=FALSE,warning=FALSE,fig.width=10,fig.height=7,echo=TRUE,cache=F,fig.align='center',fig.path=\"figureObserved/\")\nsource(\"Bayesian/BayesFunctions.R\")\n```\n\n```{r,echo=F,cache=FALSE}\npaste(\"Run Completed at\",Sys.time())\n```\n\n```{r}\n#reload if needed\n#load(\"Observed.Rdata\")\n```\n\n#Load in data\n\n```{r}\n#read in flower morphology data, comes from Nectar.R\nfl.morph<-read.csv(\"InputData/FlowerMorphology.csv\")\n\n#use effective corolla where possible.\nfl.morph$Corolla<-fl.morph$EffectiveCorolla\n\nfl.morph[is.na(fl.morph$Corolla),\"Corolla\"]<-fl.morph[is.na(fl.morph$Corolla),\"TotalCorolla\"]\n\n#First row is empty\nfl.morph<-fl.morph[-1,]\n\n#Bring in Hummingbird Morphology Dataset, comes from\nhum.morph<-read.csv(\"InputData/HummingbirdMorphology.csv\")\n\n#taxonomy change, we are calling them Crowned Woodnymph's now.\nhum.morph$English<-as.character(hum.morph$English)\nhum.morph$English[hum.morph$English %in% \"Green-crowned Woodnymph\"]<-\"Crowned Woodnymph\"\n\n#Bring in Interaction Matrix\nint<-read.csv(\"InputData/HummingbirdInteractions.csv\")\n\nint$timestamp<-as.POSIXct(paste(int$Time,int$DateP),format=\"%H:%M:%S %Y-%m-%d\")\n\n#one date error\nint[int$DateP %in% '2013-07-25',\"Month\"]<-7\n\n#one duplicate camera error, perhaps two GPS records.\nint<-int[!(int$ID %in% \"FH1108\" & int$Date_F %in% '2014-12-01'),]\n\n#Correct known taxonomic disagreements, atleast compared to traits\nint[int$Iplant_Double==\"Alloplectus purpureus\",\"Iplant_Double\"]<-\"Glossoloma purpureum\"\nint[int$Iplant_Double==\"Capanea affinis\",\"Iplant_Double\"]<-\"Kohleria affinis\"\nint[int$Iplant_Double==\"Columnea cinerea\",\"Iplant_Double\"]<-\"Columnea mastersonii\"\nint[int$Iplant_Double==\"Alloplectus teuscheri\",\"Iplant_Double\"]<-\"Drymonia teuscheri\"\nint[int$Iplant_Double==\"Drymonia collegarum\",\"Iplant_Double\"]<-\"Alloplectus tetragonoides\"\n\n#Some reasonable level of presences, 10 points\nkeep<-names(which(table(int$Hummingbird) > 10))\n\nint<-int[int$Hummingbird %in% keep & !int$Hummingbird %in% c(\"Sparkling Violetear\"),]\n\nm.dat<-droplevels(int[colnames(int) %in% c(\"ID\",\"Video\",\"Time\",\"timestamp\",\"Hummingbird\",\"Sex\",\"TransectID\",\"Transect_R\",\"Iplant_Double\",\"Pierce\",\"DateP\",\"Month\",\"ele\",\"Type\")])\n\n#Does the data come from camera or transect?\nm.dat$Type<-(is.na(m.dat$TransectID))*1\n\nm.dat$Year<-years(as.Date(m.dat$DateP))\n#one missing date\nm.dat$Year[m.dat$Year %in% 2012]<-2013\nm.dat$Year[m.dat$Year %in% 2106]<-2016\n\n#Number of bird species\nh_species<-nlevels(m.dat$Hummingbird)\n\n#Number of plant species\nplant_species<-nlevels(m.dat$Iplant_Double)\n\n#Get english name\ndath<-merge(m.dat,hum.morph, by.x=\"Hummingbird\",by.y=\"English\",keep=all)\n\n#Merge to flowers\nint.FLlevels<-levels(factor(dath$Iplant_Double))\n\n#Which flowers are we missing info for?\nmissingTraits<-int.FLlevels[!int.FLlevels %in% fl.morph$X]\n\n#print(paste(\"Missing Trait Information:\",missingTraits))\ndath<-merge(dath,fl.morph, by.x=\"Iplant_Double\",by.y=\"X\")\n\n#Drop piercing events, since they don't represent correlation\n#dath<-dath[!dath$Pierce %in% c(\"y\",\"Y\"),]\n```\n\n##Match Species to Morphology\n\n```{r}\n#observed traitmatching\ntraitmatchF<-abs(t(sapply(hum.morph$Bill,function(x){x-fl.morph$Corolla})))/10\nrownames(traitmatchF)<-hum.morph$English\ncolnames(traitmatchF)<-fl.morph$Group.1\n```\n\n```{r}\n#match names #Round to 2 decimals #Convert to cm for winbugs, avoids numerical underflow\ntraitmatchT<-round(traitmatchF[rownames(traitmatchF) %in% dath$Hummingbird,colnames(traitmatchF) %in% dath$Iplant_Double],2)\ntraitmatchT<-traitmatchT[sort(rownames(traitmatchT)),sort(colnames(traitmatchT))]\n```\n\n##Elevation ranges\n\nCreate a binary variable whether each observation was in a low elevation or high elevation transect. We have some species that just occur at the top of the gradient, and are not present in the sampling window of flowers at the low elevation.\n\nAccounting for non-availability.\nWe have to figure out which plants were sampled in which periods, and if it was sampled, the non-detection are 0 if it wasn't the non-detection are NA. then remove all the Na's.\n\n```{r}\nelevH<-read.csv(\"InputData/HummingbirdElevation.csv\",row.names=1)\ncolnames(elevH)[5]<-\"Elevation\"\nelevH$Bird<-1:nrow(elevH)\n\n#high elevation or low elevation\nelevP<-read.csv(\"InputData/PlantElevation.csv\",row.names=1)\ncolnames(elevP)[5]<-\"Elevation\"\nelevP$Plant<-1:nrow(elevP)\nelevP$Iplant_Double<-as.character(elevP$Iplant_Double)\n\n#Merge to observed Data\n#plants\ndathp<-merge(dath,elevP,by=\"Iplant_Double\")\n\n#birds\ndatph<-merge(dathp,elevH,by=\"Hummingbird\")\n```\n\nWhat elevation transect is each observation in?\nThe camera data need to be inferred from the GPS point.\n\n```{r}\n#cut working best on data.frame\ndatph<-as.data.frame(datph)\n\n#which elevation bin is each observation within\nlabs<-paste(seq(1300,2500,200),seq(1500,2700,200),sep=\"_\")\n\n#for the couple points that have 1290 elevation, round up to 300 for convienance\ndatph$ele[datph$ele < 1300]<-1301\n\n#make sure transect is a character\ndatph$Transect_R<-as.character(datph$Transect_R)\ndatph$Transect_R[is.na(datph$Transect_R)]<-as.character(cut(datph[is.na(datph$Transect_R),]$ele,seq(1300,2700,200),labels=labs))\n\n#Elev for the transects is the midpoint\ntran_elev<-datph[datph$Survey_Type=='Transect',\"Transect_R\"]\ndatph[datph$Survey_Type=='Transect',\"ele\"]<-sapply(tran_elev,function(x){\n  mean(as.numeric(str_split(x,\"_\")[[1]]))\n})\n```\n\n### Define Time Events\n\n```{r}\n#ID for NA is holger transects, make the id's 1:n for each day of transect at each elevation, assuming no elevation was split across days.\ndatph$ID<-as.character(datph$ID)\nnoid<-datph[is.na(datph$ID),]\n\nid_topaste<-paste(noid$Month,noid$Year,\"Transect\",sep=\"_\")\ndatph[which(is.na(datph$ID)),\"ID\"]<-id_topaste\n\n#Create year month combination\ndatph$Time<-paste(datph$Month,datph$Year,sep=\"_\")\n\n#Label survey type\ndatph$Survey_Type<-NA\n\nmt<-!is.na(datph$TransectID)*1\ndatph$Survey_Type[mt==1]<-\"Transect\"\ndatph$Survey_Type[!datph$Survey_Type %in% \"Transect\"]<-\"Camera\"\ndatph<-datph[datph$Survey_Type==\"Camera\",]\n\n#time filter\n\n#sort by timestamp\ndatph<-datph[order(datph$timestamp),]\n\ndotime<-function(d){\n  d$Timediff<-NA\n  if(nrow(d)>1){\n  for (x in 2:nrow(d)){\n  d$Timediff[x]<-difftime(d$timestamp[x],d$timestamp[x-1],units=\"mins\")  \n  }\n  }\n  return(d)\n}\n\ndatph<-datph %>% group_by(ID,Hummingbird) %>% do(dotime(.))\n\n#eliminate interaction by the same species within five minutes\npaste(\"Removing \",length(which(datph$Timediff<5)),\" observations, not enough time since last observation of the same species\",sep=\"\")\n\ndatph<-datph[!1:nrow(datph) %in% which(datph$Timediff<5),]\n\n#Day level\n#add day ID\nsdat<-split(datph,list(datph$ID),drop = T)\n\nsdat<-lapply(sdat,function(x){\n  x<-droplevels(x)\n  x$Day<-as.numeric(as.factor(x$DateP))\n  return(x)\n})\n\nindatraw<-rbind_all(sdat)\n\n#Species names\nfor (x in 1:nrow(indatraw)){\n  indatraw$Hummingbird[x]<-as.character(elevH[elevH$Bird %in% indatraw$Bird[x],\"Hummingbird\"])\n  indatraw$Iplant_Double[x]<-as.character(elevP[elevP$Plant %in% indatraw$Plant[x],\"Iplant_Double\"])\n}\n\n#match the traits\ntraitmelt<-melt(traitmatchT)\ncolnames(traitmelt)<-c(\"Hummingbird\",\"Iplant_Double\",\"Traitmatch\")\n\n#dummy presence variable\nindatraw$Yobs<-1\n\n#prune columsn to make more readable\nindatraw<-indatraw[,c(\"Hummingbird\",\"Iplant_Double\",\"ID\",\"Time\",\"Month\",\"Year\",\"Transect_R\",\"ele\",\"DateP\",\"Yobs\",\"Day\",\"Survey_Type\",\"Pierce\")]\n\n```\n\n##Summarize daily interactions\nTo estimate the daily detectability, there can only be a max of one interaction per day.\nWe use mean elevation to average across observations within a transect\n```{r}\nindatraw<-indatraw %>% group_by(Hummingbird,Iplant_Double,ID,Day) %>% summarize(Yobs=sum(Yobs),Time=unique(Time),Transect_R=unique(Transect_R),Month=unique(Month),Year=unique(Year),ele=mean(ele),DateP=unique(DateP),Survey_Type=unique(Survey_Type)) %>% ungroup()\n```\n\n##Absences - accounting for non-detection\n\nWe have more information than just the presences, given species elevation ranges, we have absences as well. Absences are birds that occur at the elevation of the plant sample, but were not recorded feeding on the flower.\n\n```{r}\n#Only non-detections are real 0's, the rest are NA's and are removed.\n#Plants not surveyed in that time period\n#Hummingbirds not present at that elevation\n\n#For each ID\nTime<-unique(indatraw$Time)\n\n#absences data frame\nabsences<-list()\n\nfor(t in Time){\n  IDlist<-unlist(unique(indatraw[indatraw$Time ==t,\"ID\"]))\n\n  for (j in IDlist){\n  #Which plants were sampled\n  a<-indatraw %>% filter(Time==t,ID==j)\n  \n  #For each sampled transect\n  trans<-unique(a$Transect_R)\n  \n  if(!length(trans)==0){\n    for(transect in trans){\n\n    #for each date \n    datec<-a %>% filter(Transect_R %in% transect)\n    datecam<-unique(datec$DateP)\n    }} else{\n      datecam<-a %>% distinct(DateP) %>% .$DateP\n    }\n    for(Date in datecam){\n      \n    #for each plant along that transect at that date\n    pres<-a %>% filter(DateP %in% Date) %>% distinct(Iplant_Double) %>% .$Iplant_Double\n    \n    #Which day in sampling\n    dday<-a %>% filter(Transect_R %in% transect,DateP %in% Date) %>% distinct(Day) %>% .$Day\n\n      for (plant in pres){\n        #Get mean elevation of that plant record\n        camelev<- a %>% filter(Transect_R %in% transect,DateP %in% Date,Iplant_Double %in% plant) %>% .$ele %>% mean()\n        \n        #Which birds are present at that observation\n        predh<-elevH[((elevH$Low < camelev) & (camelev < elevH$High)),\"Hummingbird\"]\n        \n        #remove the ones seen on that plant\n        hum_present<-a %>% filter(Transect_R %in% transect,DateP %in% Date,Iplant_Double %in% plant) %>% .$Hummingbird\n        abbh<-predh[!predh %in% hum_present]\n        if(length(abbh)==0){next}\n        \n        #Make absences from those )(cat not the best)\n        add_absences<-data.frame(Hummingbird=abbh,Iplant_Double=plant,Time=t,ID=j,DateP=Date,Month=min(a$Month),Year=unique(a$Year),Transect_R=transect,ele=camelev,Day=unique(dday),Survey_Type=unique(a$Survey_Type),Yobs=0)\n        absences<-append(absences,list(add_absences))\n      }\n    }\n  }\n}\n    \nindatab<-rbind_all(absences)\n\n#merge with original data\nindat<-rbind_all(list(indatraw,indatab))\n```\n\n```{r}\n#Get trait information\n#match the traits\nindat<-merge(indat,traitmelt,by=c(\"Hummingbird\",\"Iplant_Double\"))\n```\n\n#Resources at each month\n\nIn our model the covariate is indexed at the scale at which the latent count is considered fixed. This means we need the resource availability per month across the entire elevation gradient for each point.\n\n```{r,fig.height=5,fig.width=9}\n#Get flower transect data\nfull.fl<-read.csv(\"InputData/FlowerTransectClean.csv\")[,-1]\n\n #month should be capital \ncolnames(full.fl)[colnames(full.fl) %in% \"month\"]<-\"Month\"\n\n#group by month and replicate, remove date errors by making a max of 10 flowers, couple times where the gps places it in wrong transect by 1 to 2 meters. \nflower.month<-group_by(full.fl,Month,Year,Transect_R,Date_F) %>% dplyr::summarise(Flowers=sum(Total_Flowers,na.rm=TRUE))  %>% filter(Flowers>20)\n  \n#Make month abbreviation column, with the right order\nflower.month$Month.a<-factor(month.abb[flower.month$Month],month.abb[c(1:12)])\n\n#Make year factor column\nflower.month$Year<-as.factor(flower.month$Year)\n\n#get quantile for each transect\n#thresh<-melt(group_by(flower.month) %>% summarize(Threshold=quantile(Flowers,0.5)))\nflower.month$R<-cut(flower.month$Flowers,breaks=c(0,quantile(flower.month$Flowers,0.33),quantile(flower.month$Flowers,0.66),max(flower.month$Flowers)),label=c(\"Low\",\"Medium\",\"High\"))\n\n#fix the levels\nflower.month$PTransect_R<-flower.month$Transect_R\nlevels(flower.month$PTransect_R)<-c(\"1300m - 1500m\", \"1500m - 1700m\",\"1700m - 1900m\",\"1900m - 2100m\",\"2100m - 2300m\",\"2300m - 2500m\")\n#plot\n\nggplot(flower.month,aes(x=Month.a,log(Flowers),col=R,shape=as.factor(Year))) + geom_point(size=3) + theme_bw()  + geom_smooth(aes(group=1)) + ylab(\"Flowers\") + xlab(\"Month\") + facet_wrap(~PTransect_R) + labs(shape=\"Year\", y= \"Log Available Flowers\") + scale_x_discrete(breaks=month.abb[seq(1,12,2)]) + scale_color_manual(labels=c(\"Low\",\"Medium\",\"High\"),values=c(\"black\",\"blue\",\"red\")) + labs(col=\"Resource Availability\")\nggsave(\"Figures/FlowerMonth.jpeg\",dpi=600,height=5,width=9)\n\n#turn min and max elvation into seperate columns for the range\nflower.month$minElev<-as.numeric(str_extract(flower.month$Transect_R,\"(\\\\d+)\"))\nflower.month$maxElev<-as.numeric(str_match(flower.month$Transect_R,\"(\\\\d+)_(\\\\d+)\")[,3])\n```\n\n```{r}\nindat$All_Flowers<-NA\nindat$Used_Flowers<-NA\nindat$FlowerA<-NA\n\n#Resource list for each species.\nslist<-int %>% group_by(Hummingbird,Iplant_Double) %>% distinct() %>% dplyr::select(Hummingbird,Iplant_Double) %>% arrange(Hummingbird)\n\n#Create time ID for flower transects\nfull.fl$Time<-paste(full.fl$Month,full.fl$Year,sep=\"_\")\n\n#all flowers for each ID period\nallF<-full.fl %>% group_by(Month,Year,Transect_R,Date_F) %>% summarize(n=sum(Total_Flowers,na.rm=T)) %>% summarize(mn=mean(n)) %>% summarize(F=sum(mn)) %>% as.data.frame()\n\n#Individual flowers for each ID period\nindF<-full.fl %>% group_by(Iplant_Double,Month,Year,Transect_R,Date_F) %>% summarize(n=sum(Total_Flowers,na.rm=T)) %>% summarize(mn=mean(n)) %>% summarize(F=sum(mn)) %>% as.data.frame()\n\nfor (x in 1:nrow(indat)){\n\n#All flowers\n indat$All_Flowers[x]<-allF[allF$Month %in% indat$Month[x] & allF$Year %in% indat$Year[x],\"F\"]\n \n #filter by species used by hummingbird\n sp_list<-slist[slist$Hummingbird %in% indat$Hummingbird[x],\"Iplant_Double\"]\n\n indat$Used_Flowers[x]<-sum(indF[indF$Iplant_Double %in% sp_list$Iplant_Double & indF$Month %in% indat$Month[x] & indF$Year %in% indat$Year[x],\"F\"])\n  \n  #just the abundance of that species\n  indat$FlowerA[x]<-sum(indF[indF$Iplant_Double %in% indat$Iplant_Double[x] & indF$Month %in% indat$Month[x] & indF$Year %in% indat$Year[x],\"F\"])\n\n}\n```\n\n###Relationship between resource measures\n\n```{r}\nggplot(indat,aes(x=All_Flowers,y=Used_Flowers)) + geom_point() + facet_wrap(~Hummingbird,scales=\"free\")\n```\n\n##Binary Measures of Resources\n\n```{r}\n#All Resources\n#indat$BAll_Flowers<-(indat$Month  %in% c(\"6\",\"7\",\"8\",\"9\",\"10\"))*1\n\nindat$BAll_Flowers<-(indat$All_Flowers > quantile(indat$All_Flowers,0.5))*1\n\nqthresh<-indat %>% group_by(Hummingbird) %>% summarize(UThresh=quantile(Used_Flowers,0.75))\n\nindat<-merge(indat,qthresh)\nindat$BUsed_Flowers<-(indat$Used_Flowers > indat$UThresh)*1\n\nfthresh<-indat %>% group_by(Hummingbird) %>% summarize(FThresh=mean(FlowerA))\nindat<-merge(indat,fthresh)\nindat$BFlowerA<-(indat$FlowerA > indat$FThresh)*1\n\n#merge with flower month, split by elevation, mean per month\nsflowers<-flower.month %>% group_by(Transect_R,Month,Year) %>% summarize(Flowers=mean(Flowers))\nsflowers$R<-cut(sflowers$Flowers,breaks=c(0,quantile(sflowers$Flowers,0.33),quantile(sflowers$Flowers,0.66),max(sflowers$Flowers)),label=c(\"Low\",\"Medium\",\"High\"))\n \nindat<-merge(indat,sflowers,c(\"Transect_R\",\"Month\",\"Year\"))\n```\n\n```{r}\n#Combine resources with observed data\nf<-(indat$Survey_Type==\"Camera\")*1\nf[f==0]<-NA\nindat$Camera<-indat$Yobs * f\n\nf<-(indat$Survey_Type==\"Transect\")*1\nf[f==0]<-NA\nindat$Transect<-indat$Yobs * f\n```\n\nReformat index for jags.\nJags needs a vector of input species 1:n with no breaks.\n\n```{r}\n#Subset if model testing here\n#indat<-indat[indat$Hummingbird %in% c(\"White-whiskered Hermit\",\"Brown Inca\"),]\n\n#Easiest to work with jags as numeric ordinal values\nindat$Hummingbird<-as.factor(indat$Hummingbird)\nindat$Iplant_Double<-as.factor(indat$Iplant_Double)\nindat$jBird<-as.numeric(indat$Hummingbird)\nindat$jPlant<-as.numeric(indat$Iplant_Double)\n\njagsIndexBird<-data.frame(Hummingbird=levels(indat$Hummingbird),jBird=1:length(levels(indat$Hummingbird)))\njagsIndexPlants<-data.frame(Iplant_Double=levels(indat$Iplant_Double),jPlant=1:length(levels(indat$Iplant_Double)))\n\n#Similiarly, the trait matrix needs to reflect this indexing.\njTraitmatch<-traitmatchT[rownames(traitmatchT) %in% unique(indat$Hummingbird),colnames(traitmatchT) %in% unique(indat$Iplant_Double)]\n```\n\n```{r}\nindat<-droplevels(indat)\n\n#Turn Time and ID into numeric indexes\nindat$jTime<-as.numeric(as.factor(indat$Time))\nindat$jID<-as.numeric(as.factor(indat$ID))\n\n#index resources\nindat$scaledR<-as.numeric(indat$FlowerA)/100\nresourcemat<-indat %>% group_by(jBird,jPlant,jID) %>% summarize(v=max(scaledR))  %>% acast(jBird ~ jPlant ~ jID,value.var='v',fill=0)\n\n#index position\nindat$Index<-1:nrow(indat)\n```\n\n# Hierarcichal N-mixture Model\n\n##Traits\nFor hummingbird i visiting plant j recorded by camera k on day d:\n\n$$ Y_{i,j,k,d} \\sim Binom(N_{i,j,k},\\omega_i)$$\n$$N_{i,j,k} \\sim Pois(\\lambda_{i,j,k}) $$\n$$log(\\lambda_{i,j})<-\\alpha_i + \\beta_{1,i} * |Bill_i - Corolla_j|$$ \n\n##Abundance\nReplace:\n$$log(\\lambda_{i,j})<-\\alpha_i + \\beta_{1,i} * |Bill_i - Corolla_j|$$ \n\nwith:\n\n$$log(\\lambda_{i,j})<-\\alpha_i + \\beta_{1,i} * Resources_{i,j,k} $$ \n\n**Priors**\n\nPlease recall that jags parameterizes models using precision, not sd (precision = 1/sd^2)\n\n$$\\omega_i \\sim (\\mu_{\\omega},\\tau_{\\omega})$$  $$\\mu_{\\omega} \\sim Normal(0,0.5)   \n$$\\tau_{\\omega} \\sim Uniform(0,10)\n\n$$\\alpha_i \\sim Normal(\\mu_{\\alpha},\\tau_{\\alpha})$$\n$$\\beta_{1,i} \\sim Normal(\\mu_{\\beta_1},\\tau_{\\beta_1})$$\n$$\\beta_{2,i} \\sim Normal(\\mu_{\\beta_2},\\tau_{\\beta_2})$$\n\n**Hyperpriors**\n$$\\mu_{\\alpha} \\sim Normal(0,0.0001)$$\n$$\\mu_{\\beta_1} \\sim Normal(0,0.0001)$$\n\n$$\\tau_{\\alpha} \\sim Half-T(0.0001,0.0001)$$\n$$\\tau_{\\beta_1} = \\sqrt[2]{\\frac{1}{\\sigma_{\\beta_1}}}$$\n$$\\tau_{\\beta_2} = \\sqrt[2]{\\frac{1}{\\sigma_{\\beta_2}}}$$\n\n$$\\sigma_{\\alpha} = \\sqrt[2]{\\frac{1}{\\tau_\\alpha}}$$\n$$\\sigma_{\\beta_1} \\sim Half-T(0,1)$$\n$$\\sigma_{\\beta_2} \\sim Half-T(0,1)$$\n\n# Poisson GLMM\n\n```{r,eval=T}\nruns<-50000\n\n#Source model\nsource(\"Bayesian/NoDetectNmixturePoissonRagged.R\")\n\n#print model\nprint.noquote(readLines(\"Bayesian//NoDetectNmixturePoissonRagged.R\"))\n\n  #Data objects for parallel run\n  Yobs=indat$Yobs\n  Bird=indat$jBird\n  Birds=max(indat$jBird)\n  Plant=indat$jPlant\n  Plants=max(indat$jPlant)\n  Camera=indat$jID\n  Cameras=max(indat$jID)\n  Traitmatch=jTraitmatch\n  Nobs=length(indat$Yobs)\n  resources=resourcemat\n\n  #A blank Y matrix - all present\n  Ninit<-array(dim=c(Birds,Plants,Cameras),data=max(indat$Yobs)+1)\n  \n  #Inits\n  InitStage <- function() {list(beta1=rep(0,Birds),alpha=rep(0,Birds),alpha_mu=0,beta1_mu=0,exp_lambda=Ninit)}\n  \n  #Parameters to track\n  ParsStage <- c(\"alpha\",\"beta1\",\"alpha_mu\",\"beta1_mu\",\"ynew\",\"fit\",\"fitnew\",\"tauE\")\n  \n  #MCMC options\n  ni <- runs  # number of draws from the posterior\n  nt <- 10   #thinning rate\n  nb <- max(0,runs-3000) # number to discard for burn-in\n  nc <- 2  # number of chains\n\n  Dat<-list(\"Yobs\",\"Bird\",\"Plant\",\"Plants\",\"Camera\",\"Cameras\",\"Traitmatch\",\"Birds\",\"Ninit\",\"Nobs\",\"nb\",\"nt\",\"nc\",\"ni\")\n    \n  system.time(m2_niave<-jags.parallel(Dat,InitStage,ParsStage,model.file=\"Bayesian/NoDetectNmixturePoissonRagged.jags\", n.iter=ni,n.burnin=nb,n.chains=nc,n.thin=nt))\n```\n\n```{r,eval=F}\n#recompile if needed\nload.module(\"dic\")\nruns<-100000\nrecompile(m2_niave)\nm2_niave<-update(m2_niave,n.iter=runs,n.burnin=runs*.9,n.thin = 5)\n```\n\n```{r,eval=T}\npars_dniave<-extract_par(m2_niave,data=indat,Bird=\"jBird\",Plant=\"jPlant\")\npars_dniave$Model<-\"Poisson GLMM\"\nrm(m2_niave)\ngc()\n\n#write to file\n#write.csv(pars_dniave,\"OutData/GLMM.csv\")\n```\n\n```{r,eval=F}\n#read from file is needed\npars_dniave<-read.csv(\"OutData/GLMM.csv\",row.names = 1)\n```\n\n##Assess Convergence\n\n```{r,cache=FALSE,fig.width=13,fig.height=5}\n###Chains\nggplot(pars_dniave[pars_dniave$par %in% c(\"alpha\",\"beta1\"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_grid(par~species,scale=\"free\") + theme_bw() + labs(col=\"Chain\") + ggtitle(\"Detection Probability\")\n```\n\n```{r,fig.height=5,fig.width=11}\nggplot(pars_dniave[pars_dniave$par %in% c(\"beta1_mu\",\"sigma_alpha\",\"beta1_sigma\",\"alpha_mu\",\"tauE\"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + theme_bw() + labs(col=\"Chain\") + ggtitle(\"Trait-matching regression\") + facet_wrap(~par,scales=\"free\")\n```\n\n# N-mixture\n\n## Traits\n\n```{r,eval=T}\nruns<-100000\n\n#Source model\nsource(\"Bayesian/NmixturePoissonRagged.R\")\n\n#print model\nprint.noquote(readLines(\"Bayesian//NmixturePoissonRagged.R\"))\n\n  #for parallel run\n  Yobs=indat$Yobs\n  Bird=indat$jBird\n  Plant=indat$jPlant\n  Time=indat$jID\n  Times=max(indat$jID)\n  Traitmatch=jTraitmatch\n  Birds=max(indat$jBird)\n  Plants=max(indat$jPlant)\n  Nobs=length(indat$Yobs)\n\n  #A blank Y matrix - all present\n  Ninit<-array(dim=c(Birds,Plants,Times),data=max(indat$Yobs)+1)\n\n  #Inits\n  InitStage <- function() {list(beta1=rep(0,Birds),alpha=rep(0,Birds),N=Ninit,beta1_mu=0,exp_lambda=Ninit)}\n  \n  #Parameters to track\n  ParsStage <- c(\"detect\",\"alpha\",\"beta1\",\"alpha_mu\",\"beta1_sigma\",\"beta1_mu\",\"ynew\",\"fit\",\"fitnew\",\"E\",\"tauE\")\n  \n  #MCMC options\n  ni <- runs  # number of draws from the posterior\n  nt <- 10   #thinning rate\n  nb <- max(0,runs-3000) # number to discard for burn-in\n  nc <- 2  # number of chains\n\n  Dat<-list(\"Yobs\",\"Bird\",\"Plant\",\"Plants\",\"Traitmatch\",\"Birds\",\"Nobs\",\"Ninit\",\"Time\",\"Times\",\"nb\",\"nc\",\"ni\",\"nt\")\n\n    system.time(traits<-jags.parallel(Dat,InitStage,ParsStage,model.file=\"Bayesian/NmixturePoissonRagged.jags\",n.thin=nt, n.iter=ni,n.burnin=nb,n.chains=nc))\n  \n```\n\n```{r,eval=F}\n#recompile if needed\nload.module(\"dic\")\nruns<-100000\nrecompile(traits)\ntraits<-update(traits,n.iter=runs,n.burnin=runs*.9,n.thin=5)\n```\n\n```{r,eval=T}\n#extract par to data.frame\npars_detect_traits<-extract_par(traits,data=indat,Bird=\"jBird\",Plant=\"jPlant\")\n\nrm(traits)\ngc()\n\n#name\npars_detect_traits$Model<-\"N-mixture: Traits\"\n#write.csv(pars_detect_traits,\"OutData/Traits.csv\")\n```\n\n```{r,eval=F}\n#read from file if needed\npars_detect_traits<-read.csv(\"OutData/Traits.csv\",row.names=1)\n```\n\n###Assess Convergence\n\n```{r,cache=FALSE,fig.width=13,fig.height=5}\n###Chains\nggplot(pars_detect_traits[pars_detect_traits$par %in% c(\"detect\",\"alpha\",\"beta1\"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_grid(par~species,scale=\"free\") + theme_bw() + labs(col=\"Chain\") + ggtitle(\"Detection Probability\")\n```\n\n```{r,fig.height=5,fig.width=11}\nggplot(pars_detect_traits[pars_detect_traits$par %in% c(\"beta1_mu\",\"alpha_mu\",\"sigma_alpha\",\"beta1_sigma\",\"tauE\"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + theme_bw() + labs(col=\"Chain\") + ggtitle(\"Trait-matching regression\") + facet_wrap(~par,scales=\"free\")\n```\n\n## Abundance\n\n```{r,eval=T}\nruns<-100000\n\n#Source model\nsource(\"Bayesian/NmixturePoissonRagged_Abundance.R\")\n\n#print model\nprint.noquote(readLines(\"Bayesian//NmixturePoissonRagged_Abundance.R\"))\n\n  #for parallel run\n  Yobs=indat$Yobs\n  Bird=indat$jBird\n  Plant=indat$jPlant\n  Time=indat$jID\n  Times=max(indat$jID)\n  Traitmatch=jTraitmatch\n  Birds=max(indat$jBird)\n  Plants=max(indat$jPlant)\n  Nobs=length(indat$Yobs)\n  resources=resourcemat\n\n  #A blank Y matrix - all present\n  Ninit<-array(dim=c(Birds,Plants,Times),data=max(indat$Yobs)+1)\n\n  #Inits\n  InitStage <- function() {list(beta1=rep(0,Birds),alpha=rep(0,Birds),alpha_mu=0,N=Ninit,beta1_mu=0,exp_lambda=Ninit)}\n  \n  #Parameters to track\n  ParsStage <- c(\"detect\",\"alpha\",\"beta1\",\"alpha_mu\",\"beta1_mu\",\"fit\",\"fitnew\",\"ynew\",\"E\",\"tauE\")\n  \n  #MCMC options\n  ni <- runs  # number of draws from the posterior\n  nt <- 10   #thinning rate\n  nb <- max(0,runs-3000) # number to discard for burn-in\n  nc <- 2  # number of chains\n\n  Dat<-list(\"Yobs\",\"Bird\",\"Plant\",\"Plants\",\"Traitmatch\",\"Birds\",\"Nobs\",\"Ninit\",\"Time\",\"Times\",\"resources\",\"nc\",\"nb\",\"ni\",\"nt\")\n\n    system.time(abundance<-jags.parallel(Dat,InitStage,parameters.to.save=ParsStage,model.file=\"Bayesian/NmixturePoissonRagged_Abundance.jags\",n.thin=nt, n.iter=ni,n.burnin=nb,n.chains=nc))\n```\n\n```{r,eval=F}\n#recompile if needed\nload.module(\"dic\")\nruns<-100000\nrecompile(abundance)\nabundance<-update(abundance,n.iter=runs,n.burnin=runs*.8,n.thin=5,parameters.to.save=ParsStage)\n```\n\n```{r,eval=T}\n#extract par to data.frame\npars_abundance<-extract_par(abundance,data=indat,Bird=\"jBird\",Plant=\"jPlant\")\nrm(abundance)\ngc()\n\n#name\npars_abundance$Model<-\"N-mixture: Plant Abundance\"\n#write.csv(pars_abundance,\"OutData/Abundance.csv\")\n```\n\n```{r,eval=F}\npars_abundance<-read.csv(\"OutData/Abundance.csv\",row.names=1)\n```\n\n###Assess Convergence\n\n```{r,cache=FALSE,fig.width=13,fig.height=5}\n###Chains\nggplot(pars_abundance[pars_abundance$par %in% c(\"detect\",\"alpha\",\"beta1\"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_grid(par~species,scale=\"free\") + theme_bw() + labs(col=\"Chain\") + ggtitle(\"Detection Probability\")\n```\n\n```{r,fig.height=5,fig.width=11}\nggplot(pars_abundance[pars_abundance$par %in% c(\"beta1_mu\",\"alpha_mu\",\"sigma_alpha\",\"beta1_sigma\",\"sigma_detect\",\"tauE\"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + theme_bw() + labs(col=\"Chain\") + ggtitle(\"Trait-matching regression\") + facet_wrap(~par,scales=\"free\")\n```\n\n```{r}\nggplot(pars_abundance[pars_abundance$par %in% c(\"beta1_mu\",\"alpha_mu\",\"sigma_alpha\",\"beta1_sigma\",\"sigma_detect\"),],aes(x=estimate)) + geom_histogram() + theme_bw() + labs(col=\"Chain\") + ggtitle(\" Abundance regression\") + facet_wrap(~par,scales=\"free\")\n```\n\n```{r}\n#Bind together the two models\nparsk<-c(\"detect\",\"alpha\",\"beta1\",\"tauE\",\"beta1_mu\",\"alpha_mu\",\"sigma_alpha\",\"beta1_sigma\",\"fit\",\"fitnew\")\n\nparsObs<-rbind(pars_detect_traits[pars_detect_traits$par %in% parsk,],pars_dniave[pars_dniave$par %in% parsk,])\n```\n\n##Posteriors\n\n```{r,cache=FALSE,fig.width=11,fig.height=14}\n###Posterior Distributions\nggplot(parsObs[parsObs$par %in% c(\"detect\",\"alpha\",\"beta1\"),],aes(x=estimate,fill=Model)) + geom_histogram(position='identity') + ggtitle(\"Estimate of parameters\") + facet_grid(species~par,scales=\"free\") + theme_bw() \n```\n\n### Parameter estimates in the trait and abundance N-mixture.\n\n```{r,cache=FALSE,fig.width=10,fig.height=5}\n#Detection figure\n\n#N-mixture models\npar_at<-list(Abundance=pars_abundance %>% filter(par %in% c(\"detect\")),trait=pars_detect_traits %>% filter(par %in% c(\"detect\")))\npar_at<-melt(par_at,id.vars=colnames(pars_detect_traits))\npar_at<-merge(par_at,jagsIndexBird,by.x=\"species\",by.y=\"jBird\",all.x=T)\n\nggplot(par_at,aes(x=estimate,fill=L1)) + geom_histogram() + ggtitle(\"Posterior Distribution\") + theme_bw() + facet_wrap(~Hummingbird,ncol=5) + xlab(\"Probability of Detection\")\nggsave(\"Figures/DetectionProb.jpg\",dpi=300,height=7,width=11)\n```\n\n```{r,cache=FALSE,fig.width=12,fig.height=7}\n#Detection figure\n\n#N-mixture models\npar_at<-list(Abundance=pars_abundance %>% filter(par %in% c(\"tauE\")),trait=pars_detect_traits %>% filter(par %in% c(\"tauE\")))\npar_at<-melt(par_at,id.vars=colnames(pars_detect_traits))\npar_at<-merge(par_at,jagsIndexBird,by.x=\"species\",by.y=\"jBird\",all.x=T)\n\nggplot(par_at,aes(x=estimate,fill=L1)) + geom_histogram() + ggtitle(\"Posterior Distribution\") + theme_bw() + facet_wrap(~Hummingbird,ncol=5) + xlab(\"Probability of Detection\")\nggsave(\"Figures/DetectionProb.jpg\",dpi=300,height=7,width=11)\n```\n\n```{r,cache=FALSE,fig.height=5,fig.width=13}\nggplot(parsObs[parsObs$par %in% c(\"beta1_mu\",\"alpha_mu\",\"sigma_alpha\",\"beta1_sigma\"),],aes(x=estimate,fill=Model)) + geom_histogram() + ggtitle(\"Trait matching regression parameters\") + facet_wrap(~par,scale=\"free\",nrow=2) + theme_bw() \n```\n\n### Predicted relationship \n\n## Poisson GLMM versus N-mixture model\n```{r,fig.height=6,fig.width=10}\ncastdf<-dcast(parsObs[parsObs$par %in% c(\"beta1_mu\",\"alpha_mu\",\"tauE\"),], Model+Chain + Draw~par,value.var=\"estimate\")\n\ncastdf<-split(castdf,castdf$Model)\n```\n\n```{r}\npredy<-rbind_all(lapply(castdf,function(i){\n  #calculate trajectory and append model\n  pr<-trajF(alpha=i$alpha_mu,beta1=i$beta1_mu,tauSigma=1/sqrt(i$tauE),trait=indat$Traitmatch,resources=indat$scaledR)\n  pr$Model<-unique(i$Model)\n  return(pr)\n  }))\n\nfplot<-ggplot(data=predy[,],aes(x=trait)) + geom_ribbon(aes(ymin=lower,ymax=upper,fill=Model),alpha=0.5)  + geom_line(aes(y=mean,col=Model),size=.4) + theme_bw() + ylab(\"Daily Interactions\") + xlab(\"Difference between Bill and Corolla Length (cm)\") + geom_point(data=indat,aes(x=Traitmatch,y=Yobs),size=.5,alpha=1) + labs(fill=\"Model\",col=\"Model\")  + scale_fill_manual(values=c(\"grey70\",\"black\"))+ scale_color_manual(values=c(\"grey70\",\"black\"))\nfplot \n\nggsave(\"Figures/BothObs.jpg\",heigh=5,width=7,dpi=300)\n```\n\n## Traits\n\n```{r,eval=F}\ncastdf<-dcast(pars_detect_traits[pars_detect_traits$par %in% c(\"beta1_mu\",\"alpha_mu\",\"tauE\"),], Chain + Draw~par,value.var=\"estimate\")\n\npredy_traits<-trajF(alpha=castdf$alpha_mu,beta1=castdf$beta1_mu,tauSigma=1/sqrt(castdf$tauE),trait=indat$Traitmatch,resources=indat$scaledR)\n\ntplot<-ggplot(data=predy_traits,aes(x=trait)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.5)  + geom_line(aes(y=mean),size=.4,linetype=\"dashed\") + theme_bw() + ylab(\"Daily Interactions\") + xlab(\"Difference between Bill and Corolla Length (cm)\") + geom_point(data=indat,aes(x=Traitmatch,y=Yobs),size=.5,alpha=1) + ggtitle(\"Traits\")\ntplot\n```\n\n##Abundance\n\n```{r,eval=T}\ncastdf<-dcast(pars_abundance[pars_abundance$par %in% c(\"beta1_mu\",\"alpha_mu\",\"tauE\"),], Chain + Draw~par,value.var=\"estimate\")\n\npredy_abundance<-trajF(alpha=castdf$alpha_mu,beta1=castdf$beta1_mu,tauSigma=1/sqrt(castdf$tauE),trait=indat$scaledR)\n\naplot<-ggplot(data=predy_abundance,aes(x=trait)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.5)  + geom_line(aes(y=mean),size=.4,linetype=\"dashed\") + theme_bw() + ylab(\"Daily Interactions\") + xlab(\"Hundreds of flowers\") + geom_point(data=indat,aes(x=scaledR,y=Yobs),size=.5,alpha=.9) + ggtitle(\"Abundance\")\naplot \nggsave(\"Figures/AbundanceBothPlot.jpeg\",height=4,width=7,dpi=300)\n```\n\n#Species Predictions\n\n## Credible intervals\n\n### Traits\n\n\n```{r,fig.height=12}\ncastdf<-dcast(pars_detect_traits[pars_detect_traits$par %in% c(\"beta1\",\"alpha\"),], species +Chain +Model+ Draw~par,value.var=\"estimate\")\n\nggplot(castdf,aes(x=beta1)) + geom_histogram() + facet_wrap(~species,scales=\"free\",ncol=4) + geom_vline(xintercept=0)\n```\n\n```{r}\npar_at<-list(Abundance=pars_abundance %>% filter(par %in% c(\"ynew\")),trait=pars_detect_traits %>% filter(par %in% c(\"ynew\")))\npar_at<-melt(par_at,id.vars=colnames(pars_detect_traits))\nynewstat<-dcast(par_at,Model+Index+Draw+Chain~par,value.var=\"estimate\")\n\n#By species\nynewstat$Hummingbird<-indat[ynewstat$Index,\"Hummingbird\"]\nynewstat$Traitmatch<-indat[ynewstat$Index,\"Traitmatch\"]\n\nmean_ynewstat<-ynewstat %>% group_by(Hummingbird,Model,Traitmatch) %>% summarize(mean=mean(ynew),lower=quantile(ynew,0.05),upper=quantile(ynew,0.95))\n  \nggplot(mean_ynewstat,aes(x=Traitmatch,col=Model)) + geom_pointrange(aes(y=mean,ymin=lower,ymax=upper)) + labs(x=\"Difference between bill and Corolla Length (cm)\",y=\"Predicted Count\") + ggtitle(\"Predicted Counts\") + theme_bw() + facet_wrap(~Hummingbird,scales=\"free\") + geom_line(aes(y=mean))\n```\n\n## Prediction intervals\n\n```{r,fig.height=10,fig.width=11}\ncastdf<-dcast(parsObs[parsObs$par %in% c(\"beta1\",\"alpha\"),], species +Chain +Model+ Draw~par,value.var=\"estimate\")\n\ntcastdf<-dcast(parsObs[parsObs$par %in% c(\"tauE\"),],  Chain +Model+ Draw~par,value.var=\"estimate\")\n\ncastdf<-merge(castdf,tcastdf,by=c(\"Chain\",\"Model\",\"Draw\"))\n\n#Turn to species level\ncastdf$species<-factor(castdf$species,levels=1:max(as.numeric(castdf$species)))\n\nspecies.split<-split(castdf,list(castdf$species,castdf$Model),drop=T)\n\nspecies.traj<-list()\n\nfor(d in 1:length(species.split)){\n  x<-species.split[[d]]\n  #species name\n  index<-jagsIndexBird[unique(x$species),\"Hummingbird\"]\n  \n  #range of trait distances\n  tsp<-indat %>% filter(Hummingbird==index) %>% .$Traitmatch\n  \n  #Range of abundances\n  fsp<-indat %>% filter(Hummingbird==index) %>% .$scaledR\n    \n  species.traj[[d]]<-trajF(alpha=x$alpha,beta1=x$beta1,tauSigma=1/sqrt(x$tauE),trait=tsp,resources=fsp)\n}\n\nnames(species.traj)<-names(species.split)\n\nspecies.traj<-melt(species.traj,id.var=colnames(species.traj[[1]]))\n\n#split out names and model\nspecies.traj[,c(\"Index\",\"Model\")]<-colsplit(species.traj$L1,\"\\\\.\",c(\"Index\",\"Model\"))\n\nspe<-merge(species.traj,jagsIndexBird,by.x=\"Index\",by.y=\"jBird\")\n\n#match colnames\n\n#plot and compare to original data\nggplot(data=spe[,],aes(x=trait)) + geom_point(data=indat,aes(x=Traitmatch,y=Yobs)) + geom_ribbon(aes(ymin=lower,ymax=upper,fill=Model),alpha=0.6)  + geom_line(aes(y=mean,col=Model),size=1) + theme_bw() + ylab(\"Interactions\") + xlab(\"Difference between Bill and Corolla Length (cm)\") + facet_wrap(~Hummingbird,scales=\"free\",ncol=4)+ labs(fill=\"Model\")  + ylab(\"Interactions per day\") + scale_color_manual(values=c(\"grey70\",\"black\")) + scale_fill_manual(values=c(\"grey70\",\"black\"))\n\nggsave(\"Figures/SpeciesPredictionsBoth.jpg\",dpi=300,height=9,width=11)\n```\n\n### Abundance Species predictions \n\n```{r,fig.height=10,fig.width=11}\ncastdf<-dcast(pars_abundance[pars_abundance$par %in% c(\"beta1\",\"alpha\"),], species +Chain +Model+ Draw~par,value.var=\"estimate\")\n\ntcastdf<-dcast(pars_abundance[pars_abundance$par %in% c(\"tauE\"),],  Chain +Model+ Draw~par,value.var=\"estimate\")\n\ncastdf<-merge(castdf,tcastdf,by=c(\"Chain\",\"Model\",\"Draw\"))\n\n#Turn to species level\ncastdf$species<-factor(castdf$species,levels=1:max(as.numeric(castdf$species)))\n\nspecies.split<-split(castdf,list(castdf$species,castdf$Model))\n\nspecies.traj<-list()\n\nfor(d in 1:length(species.split)){\n  x<-species.split[[d]]\n  #species name\n  index<-jagsIndexBird[unique(x$species),\"Hummingbird\"]\n  \n  #range of trait distances\n  tsp<-indat %>% filter(Hummingbird==index) %>% .$scaledR\n  \n  #Range of abundances\n    fsp<-indat %>% filter(Hummingbird==index) %>% .$scaledR\n    \n  species.traj[[d]]<-trajF(alpha=x$alpha,beta1=x$beta1,tauSigma=1/sqrt(x$tauE),trait=tsp,resources=fsp)\n}\n\nnames(species.traj)<-names(species.split)\n\nspecies.traj<-melt(species.traj,id.var=colnames(species.traj[[1]]))\n\n#split out names and model\nspecies.traj[,c(\"Index\",\"Model\")]<-colsplit(species.traj$L1,\"\\\\.\",c(\"Index\",\"Model\"))\n\nspe<-merge(species.traj,jagsIndexBird,by.x=\"Index\",by.y=\"jBird\")\n\n#match colnames\n\n#plot and compare to original data\nggplot(data=spe[,],aes(x=trait)) + geom_point(data=indat,aes(x=scaledR,y=Yobs)) + geom_ribbon(aes(ymin=lower,ymax=upper,fill=Model),alpha=0.6)  + geom_line(aes(y=mean,col=Model),size=1) + theme_bw() + ylab(\"Interactions\") + xlab(\"Flowers (Hundreds)\") + facet_wrap(~Hummingbird,scales=\"free\",ncol=4)+ labs(fill=\"Model\")  + ylab(\"Interactions per day\") + scale_color_manual(values=c(\"grey70\",\"black\")) + scale_fill_manual(values=c(\"grey70\",\"black\"))\nggsave(\"Figures/SpeciesPredictions_Abundance.jpg\",dpi=300,height=9,width=11)\n\n```\n\n##Abundance posteriors\n\n```{r,fig.height=12}\ncastdf<-dcast(pars_abundance[pars_abundance$par %in% c(\"beta1\",\"alpha\"),], species +Chain +Model+ Draw~par,value.var=\"estimate\")\n\nggplot(castdf,aes(x=beta1)) + geom_histogram() + facet_wrap(~species,scales=\"free\",ncol=4) + geom_vline(xintercept=0)\n```\n\n#Discrepancy: N-mixture v Poisson GLM\n\nThe goodness of fit is a measured as chi-squared. The expected value for each day is the detection rate * the estimate intensity of interactions. The expected value is compared to the observed value of the actual data. In addition, a replicate dataset is generated from the posterior predicted intensity. Better fitting models will have lower discrepancy values and be \nBetter fitting models are smaller values and closer to the 1:1 line. A perfect model would be 0 discrepancy. This is unrealsitic given the stochasticity in the sampling processes. Rather, its better to focus on relative discrepancy. In addition, a model with 0 discrepancy would likely be seriously overfit and have little to no predictive power.\n\n```{r,fig.height=4,fig.width=8,message=F,warning=F}\nfitstat<-parsObs[parsObs$par %in% c(\"fit\",\"fitnew\"),]\nfitstat<-dcast(fitstat,Model+Draw+Chain~par,value.var=\"estimate\")\n\nymin<-min(c(fitstat$fit,fitstat$fitnew)) - min(c(fitstat$fit,fitstat$fitnew)) * .2\nymax<-max(c(fitstat$fit,fitstat$fitnew)) + max(c(fitstat$fit,fitstat$fitnew)) * .2\ndisc_obs<-ggplot(fitstat,aes(x=fit,y=fitnew)) + geom_point(aes(col=Model)) + theme_bw() + labs(x=\"Discrepancy of observed data\",y=\"Discrepancy of replicated data\",col=\"Model\")  + ggtitle(\"Empirical Data\") + geom_abline() + coord_fixed() + ylim(ymin=ymin,ymax=ymax) + xlim(xmin=ymin,xmax=ymax)\ndisc_obs\n\nfitstat %>% group_by(Model) %>% summarize(mean(fit),sum(fit))\n\nggsave(\"Figures/ObservedDiscrepancy.jpeg\",width = 5,height=10)\n```\n\n#Discrepancy: Abundance v Traits\n\n```{r,fig.height=4,fig.width=8,message=F,warning=F}\npar_at<-list(Abundance=pars_abundance %>% filter(par %in% c(\"fit\",\"fitnew\")),trait=pars_detect_traits %>% filter(par %in% c(\"fit\",\"fitnew\")))\npar_at<-melt(par_at,id.vars=colnames(pars_detect_traits))\n\nfitstat<-dcast(par_at,Model+Draw+Chain~par,value.var=\"estimate\")\n\nymin<-min(c(fitstat$fit,fitstat$fitnew)) - min(c(fitstat$fit,fitstat$fitnew)) * .2\nymax<-max(c(fitstat$fit,fitstat$fitnew)) + max(c(fitstat$fit,fitstat$fitnew)) * .2\ndisc_obs<-ggplot(fitstat,aes(x=fit,y=fitnew)) + geom_point(aes(col=Model)) + theme_bw() + labs(x=\"Discrepancy of observed data\",y=\"Discrepancy of replicated data\",col=\"Model\")  + ggtitle(\"Empirical Data\") + geom_abline() + coord_fixed() + ylim(ymin=ymin,ymax=ymax) + xlim(xmin=ymin,xmax=ymax)\ndisc_obs\n\nfitstat %>% group_by(Model) %>% summarize(mean(fit),sum(fit))\n\nggsave(\"Figures/ATDiscrepancy.jpeg\",width = 5,height=10)\n```\n\n### Correlation in prediction\n\n```{r,eval=T}\npar_at<-list(Abundance=pars_abundance %>% filter(par %in% c(\"ynew\")) %>% group_by(species,plant) %>% summarize(estimate=mean(estimate)) ,trait=pars_detect_traits %>% filter(par %in% c(\"ynew\")) %>% group_by(species,plant) %>% summarize(estimate=mean(estimate)))\npar_at<-melt(par_at,id.vars=c(\"species\",\"plant\",\"estimate\"))\nynewstat<-dcast(par_at,...~L1,value.var=\"estimate\")\n\n#plot\nggplot(ynewstat,aes(x=trait,y=Abundance)) + geom_point() + geom_abline() + labs(x=\"Traits\",y=\"Abundance\") + ggtitle(\"Predicted Counts\") + theme_bw()\n\n#By species\nynewstat<-merge(ynewstat,jagsIndexBird,by.x=\"species\",by.y=\"jBird\")\nynewstat<-merge(ynewstat,jagsIndexPlants,by.x=\"plant\",by.y=\"jPlant\")\n\nggplot(ynewstat,aes(x=trait,y=Abundance)) + geom_point() + geom_abline() + labs(x=\"Traits\",y=\"Abundance\") + ggtitle(\"Predicted Counts\") + theme_bw() + facet_wrap(~Hummingbird,scales=\"free\") + coord_fixed()\n\n```\n\n## Which species did we predict well?\n\n### By Bird\n\n```{r}\npar_at<-list(Abundance=pars_abundance %>% filter(par==\"E\"),Trait=pars_detect_traits %>% filter(par==\"E\"))\npar_at<-melt(par_at,id.vars=colnames(pars_detect_traits))\ndmat<-par_at %>% group_by(species,L1) %>% summarize(E=mean(estimate))\ndmat<-merge(dmat,jagsIndexBird,by.x=\"species\",by.y=\"jBird\")\n\nggplot(dmat,aes(x=Hummingbird,y=E,col=L1)) + geom_point(size=4) + coord_flip() + labs(color=\"N-mixture Model\",y=\"Average Discrepancy\")\n\nggsave(\"Figures/AverageBird.jpeg\",dpi=600,height=7,width=6)\n\n\n```\n\n###By plant\n\n```{r}\ndmat<-par_at %>% group_by(plant,L1) %>% summarize(E=mean(estimate))\ndmat<-merge(dmat,jagsIndexPlants,by.x=\"plant\",by.y=\"jPlant\")\nggplot(dmat,aes(x=Iplant_Double,y=E,col=L1)) + geom_point(size=4) + coord_flip()+ labs(color=\"N-mixture Model\",y=\"Average Discrepancy\")\nggsave(\"Figures/AveragePlant.jpeg\",dpi=600,height=9,width=6)\n\n```\n\n### By Interaction\n\n```{r,fig.height=12}\ndmat<-par_at %>% group_by(species,plant,L1) %>% summarize(E=mean(estimate))\ndmat<-merge(dmat,jagsIndexPlants,by.x=\"plant\",by.y=\"jPlant\")\ndmat<-merge(dmat,jagsIndexBird,by.x=\"species\",by.y=\"jBird\")\nggplot(dmat,aes(x=Iplant_Double,y=Hummingbird,fill=E)) + geom_tile(size=4) + scale_fill_continuous(\"Discrepancy\",low='blue',high='red') + facet_wrap(~L1,nrow=2) + theme_bw() + theme(axis.text.x=element_text(angle=-90))\n```\n\n### Worst twenty fits.\n\n```{r}\nprint(\"Worst 20\")\nhead(dmat %>% arrange(desc(E),L1),20)\n```\n\n###By Intensity\n\n```{r}\ndmat<-par_at %>% group_by(Yobs,L1) %>% summarize(E=mean(estimate))\nggplot(data=dmat,aes(x=as.factor(Yobs),y=E)) + geom_line(aes(col=L1,group=L1)) + labs(\"Observed\",col=\"Mo\")\n```\n\n##Detection table\n\n```{r}\ndp<-group_by(pars_detect_traits[pars_detect_traits$par %in% c(\"detect\"),],species) %>% summarise(mean=round(mean(estimate,na.rm=T),3)*100,lower=round(quantile(estimate,0.025,na.rm=T),3)*100,upper=round(quantile(estimate,0.975,na.rm=T),3)*100)\n\ntab<-merge(dp,jagsIndexBird,by.x=\"species\",by.y=\"jBird\")[,-1]\ntab[,c(4,1,2,3)]\nwrite.csv(tab[,c(4,1,2,3)],\"Figures/Table1.csv\")\n```\n\n##Sampling intensity and detection for each hummingbird species\n\nThe probability of missing a species at each daily visit is 1 - detection probability.\n\nThe probability of missing a species on sequential visits is (1- detection probability) * (1 - detection probability).\n\nWe are interested in the number of sampling events that minimize this value to some reasonable threshold. I have chosen 0.05 by convention. \n\nThe following figure represesent the estimated number of daily surveys to capture a hummingbird event given that we know it occurs. These data can be thought of as successful draws from a negative binomial distribution.\n\nIt is easiest to interpret as the number of days until you are likely to see an interaction, so i prefer to calculate:\n\n$$ 1-(1-p)^n $$\n$$ p = probability of detection$$\n$$ n = days sample $$\n\n```{r,fig.width=13,fig.height=6}\ndp<-function(n,p){\n  1-((1-p)^n)\n}\n\nts<-split(tab,tab$Hummingbird,drop=T)\ndetectd<-lapply(ts,function(x){\n  meanD<-dp(n=1:10,p=x$mean/100)\n  lowerD<-dp(n=1:10,p=x$lower/100)\n  upperD<- dp(n=1:10,p=x$upper/100)\n  data.frame(Days=1:10,mean=meanD,lower=lowerD,upper=upperD)\n})\n\nmd<-melt(detectd,id.var=\"Days\")\nmd<-dcast(md,...~variable)\n\n#get the 0.5 line\ndpn<-function(t,p){\n  n<-(1 - (1-t))/(p/100)\n  return(n)\n}\n\n#for each bird get the upper and middle estimate for 50% chance.\ndaydf<-list()\nfor (x in 1:nrow(tab)){\n  mean_day=dpn(t=0.5,tab$mean[x])\n  lower_day=dpn(t=0.5,tab$lower[x])\n  upper_day=dpn(t=0.5,tab$upper[x])\n  daydf[[x]]<-data.frame(L1=tab$Hummingbird[x],mean=mean_day,lower=lower_day,upper=upper_day)\n}\ndaydf<-rbind_all(daydf)\n\nggplot(md) + geom_ribbon(aes(x=Days,y=mean,ymin=lower,ymax=upper)) + geom_line(aes(x=Days,fill=L1,y=mean,ymin=lower,ymax=upper)) + facet_wrap(~L1,nrow=4,scale=\"free_x\")  + ylab(\"Probability of detecting a interaction\") + scale_fill_discrete(guide=\"none\") + theme_bw() + scale_x_continuous(breaks=seq(0,8,2),limits=c(0,8))+ geom_rect(fill='grey',data=daydf,alpha=0.4,aes(xmax=upper,xmin=lower,ymin=0,ymax=Inf)) + ylim(0,1)\nggsave(\"Figures/DetectionDays.jpeg\",height=7,width=11,dpi=300) \n```\n\nThe number of days it would take to have 50% confidence you have sampled enough to capture known interactions is the x axis value where the dotted line hits the curve.\n\n```{r}\nsampling<-indatraw %>% group_by(Hummingbird) %>% summarize(Obs=length(Hummingbird))\n\ntabD<-merge(tab,sampling,by=\"Hummingbird\")\nggplot(tabD,aes(x=Obs,ymin=lower,ymax=upper,y=mean)) + geom_pointrange() + labs(y=\"Detectability\",x=\"Detections\") + geom_text(aes(label=Hummingbird),vjust=2) + theme_bw() + xlim(0,175)\n```\n\n#Predicted versus Observed Data\n\n```{r}\nm<-max(jTraitmatch)-jTraitmatch\n\nmat<-indat %>% group_by(jBird,jPlant) %>% summarize(n=sum(Yobs))\ntrue_state<-acast(mat,jBird~jPlant,fill=0)\n```\n\n##Generate Networks\n\n```{r}\ncastdf<-dcast(parsObs[parsObs$par %in% c(\"beta1\",\"alpha\"),], species +Model+Chain + Draw~par,value.var=\"estimate\")\n\ntcastdf<-dcast(parsObs[parsObs$par %in% c(\"tauE\"),],  Chain +Model+ Draw~par,value.var=\"estimate\")\n\ncastdf<-merge(castdf,tcastdf,by=c(\"Chain\",\"Model\",\"Draw\"))\n\n#Turn to \ncastdf$species<-factor(castdf$species,levels=1:max(as.numeric(castdf$species)))\n\nspecies.split<-split(castdf,list(castdf$species,castdf$Model),drop = T)\n\nspecies.traj<-lapply(species.split,function(dat){\n  index<-unique(dat$species)\n  \n  #get data for those species\n  billd<-indat[indat$jBird %in% index,]\n  \n  d<-data.frame(alpha=dat$alpha,beta1=dat$beta1,tauSigma=1/sqrt(dat$tauE))\n  \n  #fit regression for each input estimate\n  sampletraj<-list()\n  \n  for (y in 1:nrow(d)){\n    v=exp(d$alpha[y] + d$beta1[y] * billd$Traitmatch + rnorm(1,0,d$tauSigma))\n    \n    sampletraj[[y]]<-data.frame(x=as.numeric(billd$Traitmatch),y=as.numeric(v),jBird=billd$jBird,jPlant=billd$jPlant,Model=unique(dat$Model))\n  }\n  \n  sample_all<-rbind_all(sampletraj)\n})\n\nspecies.traj<-rbind_all(species.traj)\n\nspecies.mean<-species.traj %>% group_by(jBird,jPlant,Model) %>% summarize(Traitmatch=unique(x),phi=mean(y))\n\nspecies.mean<-merge(species.mean,indat[,colnames(indat) %in% c(\"jBird\",\"jPlant\",\"jTime\",\"Hummingbird\",\"Iplant_Double\")])\n\n#get corolla sizes\nspecies.mean<-merge(species.mean,fl.morph,by.x=\"Iplant_Double\", by.y=\"Group.1\")\n\n#bill order\nord<-hum.morph %>% arrange(Total_Culmen) %>% .$English\nspecies.mean$Hummingbird<-factor(species.mean$Hummingbird,levels=ord)\n\n#add level to hum.morph to match naming convention\nspecies.mean<-merge(species.mean,hum.morph[,c(\"English\",\"Total_Culmen\")],by.x=\"Hummingbird\",by.y=\"English\")\n\n#Niche Breadth \nspecies.mean<-species.traj %>% group_by(jBird,jPlant,Model) %>% summarize(Traitmatch=unique(x),phi=mean(y),phi_low=quantile(y,0.05),phi_high=quantile(y,0.95))\n\n#merge names\nspecies.mean<-merge(species.mean,jagsIndexBird)\nspecies.mean<-merge(species.mean,jagsIndexPlants)\n\n#get corolla sizes\nspecies.mean<-merge(species.mean,fl.morph,by.x=\"Iplant_Double\", by.y=\"Group.1\")\n\n#bill order\nord<-hum.morph %>% arrange(Total_Culmen) %>% .$English\nspecies.mean$Hummingbird<-factor(species.mean$Hummingbird,levels=ord)\n\n#add level to hum.morph to match naming convention\nspecies.mean<-merge(species.mean,hum.morph[,c(\"English\",\"Total_Culmen\")],by.x=\"Hummingbird\",by.y=\"English\")\n\nggplot(species.mean) + geom_ribbon(alpha=0.4,aes(x=TotalCorolla,ymin=phi_low,ymax=phi_high,fill=as.factor(Model))) + theme_bw() + facet_wrap(~Hummingbird,scales=\"free\",ncol=4)+ ggtitle(\"Niche Breadth\") + geom_vline(aes(xintercept=Total_Culmen),linetype='dashed') + geom_line(aes(x=TotalCorolla,y=phi,fill=as.factor(Model))) + ylab(\"Daily Interaction Rate\") + xlab(\"Corolla Length (cm)\") + scale_fill_discrete(\"Resource Availability\")\nggsave(\"Figures/NicheBreadth.jpeg\",height=6,width=9)\n```\n\n#Network Statistics\n\nGiven the uncertainty in species interactions, what do emergant statistics look like?\n\n```{r}\n#Split by resource\nnsplit<-split(species.mean,species.mean$Model)\n\nmakeN<-function(x){\n  \n  #input matrix\n  aggm<-matrix(nrow=nrow(jagsIndexBird),ncol=nrow(jagsIndexPlants),data=0)\n  for (j in 1:nrow(x)){\n    aggm[x[j,\"jBird\"],x[j,\"jPlant\"]]<-rpois(1,lambda=x[j,\"phi\"])\n  }\n  #calculate network statistic\n  nstat<-networklevel(aggm,index=c(\"weighted connectance\",\"weighted NODF\"))\n}\n\nnstat<-lapply(nsplit,function(x){\n  netstat<-melt(t(sapply(1:100,function(k) makeN(x)))) \n  colnames(netstat)<-c(\"Iteration\",\"Metric\",\"value\")\n  return(netstat)\n})\n\nnstat<-melt(nstat,colnames(nstat[[1]]))\n\nggplot(nstat,aes(x=value,fill=L1)) + geom_density(alpha=0.6) + facet_wrap(~Metric,scales='free',nrow=2)  + scale_fill_manual(\"Model\",values=c(\"black\",\"grey70\")) + theme_bw()\nggsave(\"Figures/NetworkStats.jpeg\",height = 5,width=6) \n```\n\n```{r}\ngc()\nsave.image(\"Observed.RData\")\n```\n",
    "created" : 1471444188298.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4041261652",
    "id" : "892EE535",
    "lastKnownWriteTime" : 1472497374,
    "path" : "~/Occupy/Observed.Rmd",
    "project_path" : "Observed.Rmd",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_markdown"
}