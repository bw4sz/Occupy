{
    "contents" : "---\ntitle: Hierarchical Nmixture models for species interactions - Simulations\nauthor: \"Ben Weinstein - Stony Brook University\"\noutput:\n  html_document:\n    toc: true\n    number_sectionsf: true\n    theme: spacelab\n    keep_md: true\n  word_document: default\n---\n\n```{r,warning=FALSE,message=FALSE,echo=FALSE,cache=FALSE}\nlibrary(reshape2)\nlibrary(foreach)\nlibrary(doSNOW)\nlibrary(chron)\nlibrary(ggplot2)\nlibrary(knitr)\nlibrary(R2jags)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(gridExtra)\nlibrary(boot)\nlibrary(picante)\nlibrary(GGally)\nlibrary(bipartite)\n\nopts_chunk$set(message=FALSE,warning=FALSE,fig.width=5,fig.height=4,echo=TRUE,cache=F,fig.align='center',fig.path=\"figure/\")\n\nsetwd(\"C:/Users/Ben/Documents/Occupy/\")\n\nset.seed(3)\n#source functions\n\n```\n\n```{r,echo=F,cache=FALSE}\npaste(\"Run Completed at\",Sys.time())\n```\n\n#Simulation   \n\n### Parameters\n\n* 10 hummingbird species\n* Range of hummingbird bill sizes (in mm) ~ Pois(10)/10\n* Twenty plants\n* Range of corolla sizes (in mm) ~ Pois(15)/10\n* Mean frequeny ($\\lambda$) for each hummingbird is drawn from U(0,10)  \n* Trait matching (minimizing Bill-Corolla difference) is drawn from a hierarcichal distribution\n$$log(\\lambda)<-\\alpha_i + \\beta_i *traitmatch$$\n$$\\alpha=N(3,0.2)$$\n$$\\beta = N(1,0.2)$$\n\n* Imperfect detection \n* $$ p_i = U(0,0.5) $$ \n* 36 camera replicates\n\n**View simulated strength and form of trait matching **\n\n```{r}\nload(\"Abundance.RData\")\ngc()\nsource(\"Functions.R\")\n```\n\n#Simulation Parameters\n\n```{r,fig.height=5,fig.width=8,eval=F}\n#Number of hummingbird species\nh_species=10\nplant_species=20\ncameras<-20\ndays<-3\n\n#Bill sizes\nBill<-rpois(h_species,10)\n\n#Corolla sizes\nCorolla<-rpois(plant_species,15)\n\n#Subtract both and take absolute value, convert cm\ntraitmatch<-abs(sapply(Corolla,function(x) x - Bill)/10)\n  \n#regression slope\ngamma<- -1\nintercept<- 3\nsigma_slope<- 0.2\nsigma_intercept<- 0.2\n\ndetection= runif(h_species,0.1,0.9)\nbeta<-rnorm(h_species,gamma,sigma_slope)\nalpha<-rnorm(h_species,intercept,sigma_intercept)\n```\n\n#Compute true interaction matrices\n\n```{r,eval=F}\n#for each species loop through and create a replicate dataframe\nobs<-array(dim=c(h_species,plant_species,cameras,days))\nlambda<-array(dim=c(h_species,plant_species))\nN<-array(dim=c(h_species,plant_species,cameras))\n\n#draw intensities\nfor(x in 1:h_species){\n  for (y in 1:plant_species){\n          #true lambda - interaction intensity\n      lambda[x,y]<-exp(alpha[x] + beta[x] * traitmatch[x,y])\n  }\n}\n\n#draw latent states\nfor(x in 1:h_species){\n  for (y in 1:plant_species){\n    for (z in 1:cameras){\n      # true latent count\n      N[x,y,z]<-rpois(1,lambda[x,y])\n    }\n  }\n}\n\n#Observed counts in each day\nfor(x in 1:h_species){\n  for (y in 1:plant_species){\n    for (z in 1:cameras){\n        for (d in 1:days){\n      #true detection rate of that observed count\n      obs[x,y,z,d]<-rbinom(1,N[x,y,z],p=detection[x])\n      }\n    }\n  }\n}\n```\n\n##View correlation in simulated latent state\n\n```{r}\nmdat<-melt(N)\ncolnames(mdat)<-c(\"Bird\",\"Plant\",\"Camera\",\"Interactions\")\n\ntraitmelt<-melt(traitmatch)\ncolnames(traitmelt)<-c(\"Bird\",\"Plant\",\"traitmatch\")\n\nmdat<-merge(mdat,traitmelt,c(\"Bird\",\"Plant\"))\nggplot(mdat,aes(x=traitmatch,y=Interactions,col=as.factor(Bird))) + geom_point() + geom_smooth(aes(group=1),method=\"glm\",method.args = list(family = \"poisson\")) + labs(col=\"Bird\") + xlab(\"Absolute value of Bill Length - Corolla Length \")\n```\n\n##View Detection Rates\n\n```{r}\nobs.state<-melt(obs)\ncolnames(obs.state)<-c(\"Bird\",\"Plant\",\"Camera\",\"Day\",\"Yobs\")\nobs.state<-merge(mdat,obs.state,by=c(\"Bird\",\"Plant\",\"Camera\"))\nggplot(obs.state,aes(x=Interactions,y=Yobs,col=Camera)) + geom_point() + theme_bw() + geom_abline() + coord_equal()\n```\n\n# Hierarcichal Nmixture Model\n\nFor hummingbird i visiting plant j recorded by camera k on day d:\n\n$$ Y_{i,j,k,d} \\sim Binom(N_{i,j,k},\\omega_i)$$\n$$N_{i,j,k} \\sim Pois(\\lambda_{i,j}) $$\n$$log(\\lambda_{i,j})<-\\alpha_i + \\beta_i * abs(Bill_i - Corolla_i) $$\n\n**Priors**\n\nPlease recall that jags parameterizes models using precision, not sd (precision = 1/sd^2)\n\n$$\\omega_i \\sim (\\mu_{\\omega},\\tau_{\\omega})$$  $$\\mu_{\\omega} \\sim Normal(0,0.5)   \n$$\\tau_{\\omega} \\sim Uniform(0,10)\n\n$$\\alpha_i \\sim Normal(\\mu_{\\alpha},\\tau_{\\alpha})$$\n$$\\beta_i \\sim Normal(\\mu_{\\beta},\\tau_{\\beta})$$\n\n**Hyperpriors**\n$$\\mu_{\\alpha} \\sim Normal(0,0.0001)$$\n$$\\mu_{\\beta} \\sim Normal(0,0.0001)$$\n\n$$\\tau_{\\alpha} \\sim T(0.0001,0.0001)$$\n$$\\tau_{\\beta} = \\sqrt[2]{\\frac{1}{\\sigma_\\beta}}$$\n\n$$\\sigma_{\\alpha} = \\sqrt[2]{\\frac{1}{\\tau_\\alpha}}$$\n$$\\sigma_{\\beta} \\sim T(0,1)$$\n\n#Simulated data without detection\n\n```{r,eval=F}\nruns<-50000\n#runs<-1000\n\n#trigger parallel\nparalleljags<-T\n\n#Source model\nsource(\"Bayesian/NoDetectNmixturePoissonRagged.R\")\n\n#print model\nprint.noquote(readLines(\"Bayesian//NoDetectNmixturePoissonRagged.R\"))\n\nif(paralleljags){\n\n  #for parallel run\n  Yobs=obs.state$Yobs\n  Bird=obs.state$Bird\n  Plant=obs.state$Plant\n  Plants=max(obs.state$Plant)\n  Camera=obs.state$Camera\n  Day=obs.state$Day\n  Traitmatch<-traitmatch\n  #number of birds to iterate\n  Birds=max(obs.state$Bird)\n  Nobs=length(obs.state$Yobs)\n\n  #A blank Y matrix - all present\n  Ninit<-rep(max(obs.state$Yobs)+1,Nobs)\n  \n  #Inits\n  InitStage <- function() {list(beta=rep(0.5,Birds),alpha=rep(0.5,Birds),intercept=0,sigma_int=0.1,sigma_beta=0.1,N=Ninit,gamma=0)}\n  \n  #Parameters to track\n  ParsStage <- c(\"alpha\",\"beta\",\"intercept\",\"sigma_int\",\"sigma_slope\",\"ynew\",\"gamma\",\"fit\",\"fitnew\")\n  \n  #MCMC options\n  ni <- runs  # number of draws from the posterior\n  nt <- 5   #thinning rate\n  nb <- runs*.97 # number to discard for burn-in\n  nc <- 2  # number of chains\n\n  Dat<-list(\"Yobs\",\"Bird\",\"Plant\",\"Plants\",\"Traitmatch\",\"Birds\",\"Nobs\",\"Ninit\")\n\n    sim_niave<-do.call(jags.parallel,list(Dat,InitStage,ParsStage,model.file=\"Bayesian/NoDetectNmixturePoissonRagged.jags\",n.thin=nt, n.iter=ni,n.burnin=nb,n.chains=nc))\n    \n  } else {\n #Input Data\n  Dat <- list(\n    Yobs=obs.state$Yobs,\n    Bird=obs.state$Bird,\n    Plant=obs.state$Plant,\n    Plants=max(obs.state$Plant),\n    Time=obs.state$Time,\n    Traitmatch=traitmatch,\n    #number of birds to iterate\n    Birds=max(obs.state$Bird),\n    Nobs=length(obs.state$Yobs))\n  \n    #A blank Y matrix - all present\n    Ninit<-rep(max(Dat$Yobs)+1,Dat$Nobs)\n  \n    #Inits\n  InitStage <- function() {list(beta=rep(0.5,Dat$Birds),alpha=rep(0.5,Dat$Birds),dtrans=rep(0,Dat$Birds),intercept=0,sigma_int=0.1,sigma_beta=0.1,N=Ninit,gamma=0)}\n  \n  #Parameters to track\n  ParsStage <- c(\"detect\",\"alpha\",\"beta\",\"intercept\",\"sigma_int\",\"sigma_slope\",\"ynew\",\"gamma\",\"fit\",\"fitnew\")\n  \n  #MCMC options\n  ni <- runs  # number of draws from the posterior\n  nt <- 5   #thinning rate\n  nb <- runs*.97 # number to discard for burn-in\n  nc <- 2  # number of chains\n  \n  #Jags\n  \n  sim_niave <- jags(inits=InitStage,\n                   n.chains=nc, model.file=\"Bayesian/NoDetectNmixturePoissonRagged.jags\",\n                   working.directory=getwd(),\n                   data=Dat,\n                   parameters.to.save=ParsStage,\n                   n.thin=nt,\n                   n.iter=ni,\n                   n.burnin=nb,\n                   DIC=F)\n}\n```\n\n```{r,eval=F}\n#recompile if needed\nload.module(\"dic\")\nruns<-5000\nrecompile(sim_niave)\nsim_niave<-update(sim_niave,n.iter=runs,n.burnin=runs*.96,DIC=F)\n```\n\n```{r}\ngc()\npars_niave<-extract_par(sim_niave,data=obs.state)\npars_niave$Model<-c(\"Poisson GLMM\")\n```\n\n##Assess Convergence\n\n```{r,cache=FALSE,fig.width=11,fig.height=5}\nggplot(pars_niave[pars_niave$par %in% c(\"detect\",\"alpha\",\"beta\"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_grid(par~species,scale=\"free\") + theme_bw() + labs(col=\"Chain\") + ggtitle(\"Detection Probability\")\n```\n\n```{r,fig.height=5,fig.width=11}\nggplot(pars_niave[pars_niave$par %in% c(\"gamma\",\"sigma_int\",\"sigma_slope\"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + theme_bw() + labs(col=\"Chain\") + ggtitle(\"Trait-matching regression\") + facet_wrap(~par,scales=\"free\")\n```\n\n##Posteriors\n\n```{r,cache=FALSE,fig.width=7,fig.height=5}\n###Posterior Distributions\np<-ggplot(pars_niave[pars_niave$par %in% c(\"alpha\",\"beta\"),],aes(x=estimate)) + geom_histogram() + ggtitle(\"Estimate of parameters\") + facet_grid(species~par,scales=\"free\") + theme_bw() + ggtitle(\"Species Posteriors\")\n\n#Add true values\ntr<-melt(data.frame(species=1:length(detection),alpha=alpha,beta=beta),id.var='species')\ncolnames(tr)<-c(\"species\",\"par\",\"value\")\npsim<-p + geom_vline(data=tr,aes(xintercept=value),col='red',linetype='dashed',size=1)\npsim\nggsave(\"Figures/SimulationPosteriorsNoDetect.jpg\",dpi=300,height=8,width=8)\n```\n\n```{r,cache=FALSE,fig.height=3,fig.width=10}\np<-ggplot(pars_niave[pars_niave$par %in% c(\"gamma\",\"intercept\",\"sigma_int\",\"sigma_slope\"),],aes(x=estimate)) + geom_histogram() + ggtitle(\"Hierarchical Posteriors\") + facet_grid(~par,scale=\"free\") + theme_bw()\n\n#Add true values\ntr<-melt(list(gamma=gamma,intercept=intercept,sigma_int=sigma_intercept,sigma_slope=sigma_slope))\n\ncolnames(tr)<-c(\"value\",\"par\")\n\npsim2<-p + geom_vline(data=tr,aes(xintercept=value),linetype='dashed',size=1,col=\"red\")\n```\n\n**True values are given in the dashed lines.**\n\n##Predicted Relationship \n\n```{r,fig.height=4,fig.width=4}\ncastdf<-group_by(pars_niave,Chain) %>% select(par,estimate) %>% filter(par %in% c(\"gamma\",\"intercept\"))\n\ncastdf<-dcast(pars_niave[pars_niave$par %in% c(\"gamma\",\"intercept\"),], Chain + Draw~par,value.var=\"estimate\")\n\n#calculated predicted y\npredyniave<-trajF(alpha=castdf$intercept,beta=castdf$gamma,x=as.numeric(traitmatch))\n\norig<-trajF(alpha=rnorm(2000,intercept,sigma_intercept),beta=rnorm(2000,gamma,sigma_slope),x=as.numeric(traitmatch))\n```\n\n# Simulated data with detection\n\n```{r,eval=F}\n#runs<-90000\nruns<-100000\n\n#trigger parallel\nparalleljags<-T\n\n#Source model\nsource(\"Bayesian/NmixturePoissonRagged.R\")\n\n#print model\nprint.noquote(readLines(\"Bayesian//NmixturePoissonRagged.R\"))\n\nif(paralleljags){\n\n  #for parallel run\n  Yobs=obs.state$Yobs\n  Bird=obs.state$Bird\n  Plant=obs.state$Plant\n  Camera=obs.state$Camera\n  Cameras=max(obs.state$Camera)\n  Day<-obs.state$Day\n  Days<-max(obs.state$Day)\n  Traitmatch=traitmatch\n  #number of birds to iterate\n  Birds=max(obs.state$Bird)\n  Plants=max(obs.state$Plant)\n  Nobs=length(obs.state$Yobs)\n\n  #A blank Y matrix - all present\n  Ninit<-array(dim=c(h_species,plant_species,cameras),data=max(obs.state$Yobs)+1)\n\n  #Inits\n  InitStage <- function() {list(beta=rep(0.5,Birds),alpha=rep(0.5,Birds),dtrans=rep(0,Birds),intercept=0,sigma_alpha=0.1,sigma_slope=0.1,N=Ninit,gamma=0)}\n  \n  #Parameters to track\n  ParsStage <- c(\"detect\",\"alpha\",\"beta\",\"intercept\",\"sigma_int\",\"sigma_slope\",\"ynew\",\"gamma\",\"fit\",\"fitnew\")\n  \n  #MCMC options\n  ni <- runs  # number of draws from the posterior\n  nt <- 10   #thinning rate\n  nb <- runs*.95 # number to discard for burn-in\n  nc <- 2  # number of chains\n\n  Dat<-list(\"Yobs\",\"Bird\",\"Plant\",\"Plants\",\"Traitmatch\",\"Birds\",\"Nobs\",\"Ninit\",\"Day\",\"Days\",\"Camera\",\"Cameras\")\n\n    system.time(sim_detect<-do.call(jags.parallel,list(Dat,InitStage,ParsStage,model.file=\"Bayesian/NmixturePoissonRagged.jags\",n.thin=nt, n.iter=ni,n.burnin=nb,n.chains=nc)))\n  } else {\n  #Input Data\n  Dat <- list(\n     Yobs=obs.state$Yobs,\n    Bird=obs.state$Bird,\n    Plant=obs.state$Plant,\n    Camera=obs.state$Camera,\n    Cameras=max(obs.state$Camera),\n    Day<-obs.state$Day,\n    Days<-max(obs.state$Day),\n    Traitmatch=traitmatch,\n    #number of birds to iterate\n    Birds=max(obs.state$Bird),\n    Plants=max(obs.state$Plant),\n    Nobs=length(obs.state$Yobs)\n  )\n    #A blank Y matrix - all present\n  Ninit<-array(dim=c(h_species,plant_species,cameras),data=max(obs.state$Yobs)+1)\n  \n    #Inits\n  InitStage <- function() {list(beta=rep(0.5,Dat$Birds),alpha=rep(0.5,Dat$Birds),dtrans=rep(0,Dat$Birds),intercept=0,tau_alpha=0.1,tau_beta=0.1,N=Ninit,gamma=0)}\n  \n  #Parameters to track\n  ParsStage <- c(\"detect\",\"alpha\",\"beta\",\"intercept\",\"sigma_int\",\"sigma_slope\",\"ynew\",\"gamma\",\"fit\",\"fitnew\")\n  \n  #MCMC options\n  ni <- runs  # number of draws from the posterior\n  nt <- 5   #thinning rate\n  nb <- runs*.95 # number to discard for burn-in\n  nc <- 2  # number of chains\n  \n  #Jags\n  \n  system.time(sim_detect <- jags(inits=InitStage,\n                   n.chains=nc, model.file=\"Bayesian/NmixturePoissonRagged.jags\",\n                   working.directory=getwd(),\n                   data=Dat,\n                   parameters.to.save=ParsStage,\n                   n.thin=nt,\n                   n.iter=ni,\n                   n.burnin=nb,\n                   DIC=F))\n}\n```\n\n```{r,eval=F}\n#recompile if needed\nload.module(\"dic\")\nruns<-5000\nrecompile(sim_detect)\nsystem.time(sim_detect<-update(sim_detect,n.iter=runs,n.burnin=runs*.97,n.thin=5,DIC=F))\n```\n\n```{r}\npars<-extract_par(sim_detect,data=obs.state)\npars$Model<-\"Nmixture\"\n```\n\n##Assess Convergence\n\n```{r,cache=FALSE,fig.width=11,fig.height=5}\nggplot(pars[pars$par %in% c(\"detect\",\"alpha\",\"beta\"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_grid(par~species,scale=\"free\") + theme_bw() + labs(col=\"Chain\") + ggtitle(\"Detection Probability\")\n```\n\n```{r,fig.height=5,fig.width=11}\nggplot(pars[pars$par %in% c(\"gamma\",\"sigma_int\",\"sigma_slope\"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + theme_bw() + labs(col=\"Chain\") + ggtitle(\"Trait-matching regression\") + facet_wrap(~par,scales=\"free\")\n```\n\n##Posteriors\n\n```{r,cache=FALSE,fig.width=7,fig.height=5}\n###Posterior Distributions\np<-ggplot(pars[pars$par %in% c(\"detect\",\"alpha\",\"beta\"),],aes(x=estimate)) + geom_histogram() + ggtitle(\"Estimate of parameters\") + facet_grid(species~par,scales=\"free\") + theme_bw() + ggtitle(\"Species Posteriors\")\n\n#Add true values\ntr<-melt(data.frame(species=1:length(detection),detect=detection,alpha=alpha,beta=beta),id.var='species')\ncolnames(tr)<-c(\"species\",\"par\",\"value\")\npsim<-p + geom_vline(data=tr,aes(xintercept=value),col='red',linetype='dashed',size=1)\n#ggsave(\"Figures/SimulationPosteriors.jpg\",dpi=300,height=8,width=8)\n```\n\n```{r,cache=FALSE,fig.height=3,fig.width=10}\np<-ggplot(pars[pars$par %in% c(\"gamma\",\"intercept\",\"sigma_int\",\"sigma_slope\"),],aes(x=estimate)) + geom_histogram() + ggtitle(\"Hierarchical Posteriors\") + facet_wrap(~par,scale=\"free\",nrow=2) + theme_bw() \n\n#Add true values\ntr<-melt(list(gamma=gamma,intercept=intercept,sigma_int=sigma_intercept,sigma_slope=sigma_slope))\n\ncolnames(tr)<-c(\"value\",\"par\")\n\npsim2<-p + geom_vline(data=tr,aes(xintercept=value),linetype='dashed',size=1,col=\"black\")\n#ggsave(\"Figures/SimulationH.jpg\",dpi=300,height=4,width=10)\n```\n\n**True values are given in the dashed lines.**\n\n##Compare simulation posteriors with and without detection\n\n```{r,cache=FALSE,fig.width=8,fig.height=9}\n#Bind to other dataset\nparsall<-rbind.data.frame(pars[!pars$par %in% \"ynew\",],pars_niave[!pars_niave$par %in% \"ynew\",])\nparsall$Model<-as.factor(parsall$Model)\n\n###Posterior Distributions\np<-ggplot(parsall[parsall$par %in% c(\"detect\",\"alpha\",\"beta\"),],aes(x=estimate,fill=Model)) + geom_histogram(position=\"identity\") + ggtitle(\"Estimate of parameters\") + facet_grid(species~par,scales=\"free\") + theme_bw() \n\n#Add true values\ntr<-melt(data.frame(species=1:length(detection),detect=detection,alpha=alpha,beta=beta),id.var='species')\ncolnames(tr)<-c(\"species\",\"par\",\"value\")\npsim<-p + geom_vline(data=tr,aes(xintercept=value),col='black',linetype='dashed',size=1)\npsim\n#ggsave(\"Figures/SimulationPosteriorsBoth.jpg\",dpi=300,height=8,width=8)\n```\n\n```{r,cache=FALSE,fig.height=3,fig.width=10}\np<-ggplot(parsall[parsall$par %in% c(\"gamma\",\"intercept\",\"sigma_int\",\"sigma_slope\"),],aes(x=estimate,fill=Model)) + geom_histogram(position=\"identity\") + ggtitle(\"Hierarchical Posteriors\") + facet_wrap(~par,scale=\"free\",nrow=2) + theme_bw() \n\n#Add true values\ntr<-melt(list(gamma=gamma,intercept=intercept,sigma_int=sigma_intercept,sigma_slope=sigma_slope))\n\ncolnames(tr)<-c(\"value\",\"par\")\n\npsim2<-p + geom_vline(data=tr,aes(xintercept=value),linetype='dashed',size=1,col=\"black\")\npsim2\n#ggsave(\"Figures/SimulationHBoth.jpg\",dpi=300,height=4,width=10)\n```\n\n##Strip plots\nPlot the posterior mean density\n```{r}\nspars<-parsall %>% filter(par %in% c(\"alpha\",\"beta\",\"detect\")) %>% group_by(Model,species,par) %>% summarize(mean=mean(estimate),lower=quantile(estimate,0.05),upper=quantile(estimate,0.95))\n\ntr<-melt(data.frame(species=1:length(detection),detect=detection,alpha=alpha,beta=beta),id.var='species')\ncolnames(tr)<-c(\"species\",\"par\",\"value\")\n\nggplot(spars,aes(x=Model,ymin=lower,ymax=upper,y=mean,col=Model)) + geom_linerange(size=1.3) + facet_grid(par~species,scales=\"free\") + geom_hline(data=tr,aes(yintercept=value),linetype='dashed',size=1,col=\"black\") + geom_point(aes(y=mean),col='grey50',size=2) + theme_bw() + ylab(\"Estimate\")\n\n#Hierarchical posteriors\nhpars<-parsall %>% filter(par %in% c(\"gamma\",\"intercept\",\"sigma_int\",\"sigma_slope\")) %>% group_by(Model,species,par) %>% summarize(mean=mean(estimate),lower=quantile(estimate,0.05),upper=quantile(estimate,0.95))\n\nggplot(hpars,aes(x=Model,ymin=lower,ymax=upper,y=mean,col=Model)) + geom_linerange(size=1.3) + facet_wrap(~par,scales=\"free\",nrow=1) + geom_hline(data=tr,aes(yintercept=value),linetype='dashed',size=1,col=\"black\") + geom_point(aes(y=mean),col='grey50',size=2) + theme_bw() + ylab(\"Estimate\")\nggsave(\"Figures/StripPlots.svg\",height=4,width=9)\n```\n\n##Correlation in posteriors for Nmixture Model\n\n```{r}\ncastdf<- pars %>% filter(Model ==\"Nmixture\") %>% group_by(Chain) %>% select(par,estimate,Draw) %>% filter(par %in% c(\"gamma\",\"intercept\")) %>% dcast(Chain+Draw~par,value.var=\"estimate\")\nhead(castdf)\nggpairs(castdf[,3:4],title=\"Correlation in Group-Level Posteriors\")\n\ncastdf<- pars %>% filter(Model ==\"Nmixture\") %>% group_by(Chain) %>% select(par,estimate,Draw,species) %>% filter(par %in% c(\"alpha\",\"beta\",\"detect\")) %>% dcast(species+Chain+Draw~par,value.var=\"estimate\")\nhead(castdf)\nggpairs(castdf[,4:6],title=\"Correlation in Species-Level Posteriors\")\n```\n\n##Predicted Relationship \n\nDoes accounting for non-independence and detection change our estimate of trait matching?\n\n```{r,fig.height=4,fig.width=4}\ncastdf<-group_by(pars,Chain) %>% select(par,estimate) %>% filter(par %in% c(\"gamma\",\"intercept\"))\n\ncastdf<-dcast(pars[pars$par %in% c(\"gamma\",\"intercept\"),], Chain + Draw~par,value.var=\"estimate\")\n\ntrajF<-function(alpha,beta,x){\n  indat<-cbind(alpha,beta)\n  \n  #fit regression for each input estimate\n  sampletraj<-apply(indat,1,function(s){\n    data.frame(x=x,y=exp(s['alpha'] + s['beta'] *x))})\n  sample_all<-rbind_all(sampletraj)\n  \n  #Compute CI intervals\n  predy<-group_by(sample_all,x) %>% summarise(lower=quantile(y,0.025,na.rm=T),upper=quantile(y,0.975,na.rm=T),mean=mean(y,na.rm=T))\n  }\n\n#calculated predicted y\npredy<-trajF(alpha=castdf$intercept,beta=castdf$gamma,x=as.numeric(traitmatch))\n\norig<-trajF(alpha=rnorm(2000,intercept,sigma_intercept),beta=rnorm(2000,gamma,sigma_slope),x=as.numeric(traitmatch))\n\n\n#plot and compare to original data\npsim3<-ggplot(data=predy,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.1,fill=\"red\")  + geom_line(aes(y=mean),size=.8,col=\"red\",linetype=\"dashed\") + theme_bw() + ylab(\"Interactions\") + geom_line(data=orig,aes(x=x,y=mean),col='black',size=1) + geom_ribbon(data=predyniave,aes(ymin=lower,ymax=upper),alpha=0.1,fill=\"blue\") +  geom_line(data=predyniave,aes(y=mean),size=.8,col=\"blue\",linetype=\"dashed\") + xlab(\"Difference between Bill and Corolla Length\") \n\npsim3\nggsave(\"Figures/SimulationResults.jpg\",height=5,width=6,dpi=300)\n```\n\nBlack line is the true relationship. The red line is the posterior mean with confidible intervals in shaded grey for the proposed bayesian model. The blue line is the same model, but assuming perfect detection rates.\n\n**Conclusion:** Accounting for detection and non-independence greatly increases the accuracy of the predicted state. The perfect detection model underestimates the strength of trait matching among hummingbirds and their foodplants.\n\n##Posterior Predictive Check\n\nSince I have simualted the data, it should fit as well as any random dataset drawn from the estimated parameters. An ideal fit would be posterior values sitting along the 1:1 line.\n\n```{r,fig.height=4,fig.width=8}\nfitstat<-droplevels(parsall[parsall$par %in% c(\"fit\",\"fitnew\"),])\nfitstat<-dcast(fitstat,Draw+Chain+Model~par,value.var=\"estimate\")\n\n#add 1:1 line\nymin<-round(min(c(fitstat$fit,fitstat$fitnew)))\nymax<-round(max(c(fitstat$fit,fitstat$fitnew)))\nab<-data.frame(x=ymin:ymax,y=ymin:ymax)\np<-ggplot(fitstat,aes(x=fit,y=fitnew)) + geom_point(aes(col=Model)) + theme_bw() + coord_equal()\npsim4<-p  + labs(x=\"Discrepancy of observed data\",y=\"Discrepancy of replicated data\",col=\"Model\") + geom_line(data=ab,aes(x=x,y=y)) + ggtitle(\"Simulated Data\")\npsim4\nggsave(\"Figures/SimulationDisc.jpeg\",height=5,width=5)\n```\n\n```{r,echo=FALSE}\n#Write Figures as panels\njpeg(\"Figures/SimulationPosteriorsBoth.jpg\",height=12,width=12,units=\"in\",res=300)\ngrid.arrange(psim,psim2,ncol=1,heights=c(3/4,1/4))\ndev.off()\n\njpeg(\"Figures/SimPredictBoth.jpg\",height=6,width=7,units=\"in\",res=300)\ngrid.arrange(psim3)\ndev.off()\n```\n\n#Compare Nmixture Models to a Multinomial fit\n\nSeveral studies follow Vasquez 2009 in fitting a multinomial relationship to frequency and interaction probabilities. See ??mgen in package bipartite. Since traitmatching is a distance, take 1-probabilities to correct weight the multinomial\n\n```{r}\n#true number of observed interactions\ntrue_state<-obs.state %>% group_by(Bird,Plant) %>% summarize(n=sum(Yobs)) %>% acast(.$Bird~.$Plant)\n\nm<-max(traitmatch)-traitmatch\nm<-m/sum(m)\n\n#True latent interactions, since the simulated data is known.\nprint(paste(\"Correlation coefficient is:\", round(cor(c(true_state),c(m),method=\"spearman\"),2)))\n```\n\nWhat is the discrepancy of a multinomial approach?\n\nChisquared statistic is (observed-expected)^2/(expected + 0.5), we add the 0.5 to avoid dividing by 0. For each combination of birds and plants, predicted versus mean observed.\n\n```{r}\n#define discrep function\nchisq<-function(o,e){(o-e)^2/(e+0.5)}\n\nnullm<-function(){\nr<-mgen(m,sum(true_state),keep.species = F)\n}\n\n#same number of draws as bayesian\n#cl<-makeCluster(20,\"SOCK\")\n#registerDoSNOW(cl)\nmult_matrix<-foreach(x=1:length(pars[pars$par %in% \"fit\",\"estimate\"]),.packages=c(\"bipartite\",\"reshape2\")) %do% nullm()\n#stopCluster(cl)\n\nmats<-lapply(mult_matrix,function(r){\nrmerge<-matrix(nrow = nrow(true_state),ncol=ncol(true_state))\n\n#for each position what is the chisq\nfor (x in 1:nrow(r)){\n  for (y in 1:ncol(r)){\n   rmerge[x,y]<-chisq(e=r[x,y],o=true_state[x,y])\n  }\n}\n\n#sum of chisq driscrepancy\nreturn(rmerge)\n})\n\nmulti_disc<-sapply(mats,function(x) sum(x))\n\nqplot(multi_disc)+ xlab(\"Chi-squared Discrepancy for Multimonial Liklihood\") + geom_vline(xintercept=mean(multi_disc),col='red',linetype='dashed')\n```\n\n#Compare Bayesian Nmixture and Multinomial using true known interactions\n\n## No Detection Nmixture Model\n\n```{r}\nN_niave<-pars_niave[ pars_niave$par %in% \"ynew\",]\n\nbydraw<-split(N_niave,list(N_niave$Chain,N_niave$Draw))\n\n#Don't need giant matrix sitting around\nrm(N_niave)\ngc()\n\nocc_nodetect_matrix<-lapply(bydraw,function(x){\n  r<-acast(x,species ~ plant,value.var = \"estimate\",fun.aggregate = sum)\n})\n\n#calculate discrep on those deviates\nocc_nodetect<-lapply(occ_nodetect_matrix,function(r){\n    #for each position what is the chisq\n  rmerge<-matrix(nrow = nrow(true_state),ncol=ncol(true_state))\n  for (x in 1:nrow(r)){\n    for (y in 1:ncol(r)){\n     rmerge[x,y]<-chisq(e=r[x,y],o=true_state[x,y])\n      }\n    }\n  return(rmerge)\n})\n\nnames(occ_nodetect)<-1:length(occ_nodetect)\nnames(occ_nodetect_matrix)<-1:length(occ_nodetect_matrix)\n```\n\n##With Detection\n\n```{r}\nNdetect<-pars %>% filter(par== \"ynew\")\nbydraw<-split(Ndetect,list(Ndetect$Chain,Ndetect$Draw))\n\n#Don't need giant matrix around\nrm(Ndetect)\ngc()\n\nocc_matrix<-lapply(bydraw,function(x){\n  r<-acast(x,species ~ plant,value.var = \"estimate\",fun.aggregate = sum)\n  })\n\n#calculate discrep for those aggregated matrices\nocc<-lapply(occ_matrix,function(r){\n    #for each position what is the chisq\n  rmerge<-matrix(nrow = nrow(true_state),ncol=ncol(true_state))\n  for (x in 1:nrow(r)){\n    for (y in 1:ncol(r)){\n     rmerge[x,y]<-chisq(e=r[x,y],o=true_state[x,y])\n      }\n    }\n  return(rmerge)\n})\n\nnames(occ)<-1:length(occ)\nnames(occ_matrix)<-1:length(occ_matrix)\n```\n\n##Compare to observed data\n\n```{r,fig.width=11}\nmmat<-melt(true_state)\ncolnames(mmat)<-c(\"Bird\",\"Plant\",\"True_State\")\n\n#append to predicted matrices\n\n#Nmixture with detection\nmocc<-melt(occ_matrix)\ncolnames(mocc)<-c(\"Bird\",\"Plant\",\"Nmixture\",\"Iteration\")\nsimdat<-merge(mocc,mmat,by=c(\"Bird\",\"Plant\"),all.x=T)\n\n#Nmixture with nodetection\nmoccd<-melt(occ_nodetect_matrix)\ncolnames(moccd)<-c(\"Bird\",\"Plant\",\"Poisson GLMM\",\"Iteration\")\n\nsimdat<-merge(simdat,moccd,by=c(\"Bird\",\"Plant\",\"Iteration\"))\n\n#multinomial\nmultmats<-melt(mult_matrix)\ncolnames(multmats)<-c(\"Bird\",\"Plant\",\"Multinomial\",\"Iteration\")\nsimdat<-merge(simdat,multmats,by=c(\"Bird\",\"Plant\",\"Iteration\"))\n\nsimdat<-melt(simdat,measure.vars = c(\"Nmixture\",\"Poisson GLMM\",\"Multinomial\"))\n\nggplot(simdat,aes(x=True_State,y=value,col=variable),alpha=.4) + geom_point() + geom_abline() + labs(col=\"Model\") + ylab(\"Predicted State\") + xlab(\"True State\") + theme_bw() + facet_wrap(~variable)\n\nggsave(\"Figures/PredictedState.jpeg\",height=3,width=8)\n\nggplot(simdat[simdat$variable %in% c(\"Nmixture\",\"Poisson GLMM\"),],aes(x=True_State,y=value,col=variable),alpha=.4) + geom_point() + geom_abline() + labs(col=\"Model\") + ylab(\"Predicted State\") + xlab(\"True State\") + theme_bw()\nggsave(\"Figures/PredictedState_noM.jpeg\",height=3,width=8)\n\n\n#difference in the middle\nsimd<-dcast(simdat,...~variable)\nsimd$Diff<-simd$Nmixture-simd$`Poisson GLMM`\nggplot(simd,aes(x=True_State,y=Diff)) + geom_point() + ylab(\"Difference in Nmixture and Poisson GLMM\")\n```\n\n## View predicted trait-matching relationship with the number of visits.\n```{r}\nsimdat<-merge(simdat,traitmelt,c(\"Bird\",\"Plant\"))\nmmat<-merge(mmat,traitmelt,by=c(\"Bird\",\"Plant\"))\n```\n\n#Predicted total number of visits based on morphology\n\n```{r,fig.height=5,fig.width=5}\nsimT<-simdat %>% group_by(variable,traitmatch) %>% summarize(Lower=quantile(value,0.05),Upper=quantile(value,0.95),y=mean(value))\n\nggplot(simT,aes(x=traitmatch)) + geom_ribbon(aes(ymin=Lower,ymax=Upper,fill=variable),alpha=0.4) + geom_line(aes(y=y,col=variable),linetype='dashed') + theme_bw()  + geom_point(data=mmat,aes(y=True_State)) + labs(x=\"Difference in Bill and Corolla Length\",y=\"Total Predicted Visits\",fill=\"Model\",col='Model')\n\n```\n\nView a couple example data points from across the type of interactions.\n\n```{r}\nh<-simdat[which.max(simdat$True_State),c(\"Bird\",\"Plant\")]\nd<-simdat[simdat$Bird %in% h$Bird & simdat$Plant %in% h$Plant,]\n\nggplot(data=d,aes(x=value,fill=variable))+ geom_histogram(position=\"identity\") + labs(fill=\"Model\") + geom_vline(aes(xintercept=True_State)) + ggtitle(\"High Visitation Example\")\n\nh<-simdat[which.min(simdat$True_State),c(\"Bird\",\"Plant\")]\nd<-simdat[simdat$Bird %in% h$Bird & simdat$Plant %in% h$Plant,]\n\nggplot(data=d,aes(x=value,fill=variable))+ geom_histogram(position=\"identity\") + labs(fill=\"Model\") + geom_vline(aes(xintercept=True_State)) + ggtitle(\"Low Visitation Example\")\n```\n\n##Summary of discrepancy of predicted matrices\n\n```{r}\n#Multinomial\nmulti_disc<-sapply(mats,function(x) median(x))\n\n#Nmixture without detection\noccno_disc<-sapply(occ_nodetect,function(x) median(x))\n\n#Nmixture with detection\nocc_disc<-sapply(occ,function(x) median(x))\n\n#compared to bayesian\nggplot(data.frame(multi_disc)) + geom_histogram(aes(x=multi_disc),fill=\"blue\",alpha=.6)+ xlab(\"Chi-squared Discrepancy\") + geom_histogram(data=data.frame(occ_disc),aes(x=occ_disc),fill=\"red\",alpha=.6) + theme_bw() +geom_vline(aes(xintercept=mean(occ_disc)),linetype=\"dashed\",col=\"red\")+ geom_vline(xintercept=mean(multi_disc),linetype=\"dashed\",col=\"blue\") + geom_histogram(data=data.frame(occno_disc),aes(x=occno_disc),fill=\"orange\",alpha=.6) + geom_vline(aes(xintercept=mean(occno_disc)),linetype=\"dashed\",col=\"orange\")\n```\n\n##Comparison of summary statistics for all three approaches\n\n```{r}\nd<-list(Nmixture=occ,Multinomial=mats,Poisson_GLM=occ_nodetect)\nd<-melt(d)\ncolnames(d)<-c(\"Bird\",\"Plant\",\"value\",\"Iteration\",\"Model\")\n\nd %>% group_by(Model,Iteration) %>% summarize(mean=mean(value),sd=sd(value),sum=sum(value)) %>% group_by(Model) %>% summarize(mean_mean=round(mean(mean),2),mean_sd=round(sd(mean),2),mean_sum=round(mean(sum),2))\n```\n\n#DIC\n\n```{r}\nsim_niave$BUGSoutput$DIC\nsim_detect$BUGSoutput$DIC\n```\n\n\n```{r}\nsave.image(\"Abundance.Rdata\")\n```\n\n",
    "created" : 1460126238254.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2119382288",
    "id" : "BD562A8C",
    "lastKnownWriteTime" : 1460142523,
    "path" : "~/Occupy/Abundance.Rmd",
    "project_path" : "Abundance.Rmd",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_markdown"
}