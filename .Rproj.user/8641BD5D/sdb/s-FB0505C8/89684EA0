{
    "contents" : "---\ntitle: \"Hierarchical Nmixture Models for species interactions: Empirical Data\"\nauthor: \"Ben Weinstein - Stony Brook University\"\noutput:\n  html_document:\n    toc: true\n    number_sections: true\n    theme: spacelab\n    keep_md: true\n  word_document: default\n---\n\n```{r,warning=FALSE,message=FALSE,echo=FALSE,cache=FALSE}\nlibrary(reshape2)\nlibrary(foreach)\nlibrary(doSNOW)\nlibrary(chron)\nlibrary(ggplot2)\nlibrary(knitr)\nlibrary(R2jags)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(gridExtra)\nlibrary(boot)\nlibrary(picante)\nlibrary(bipartite)\n\nopts_chunk$set(message=FALSE,warning=FALSE,fig.width=6,fig.height=4,echo=TRUE,cache=F,fig.align='center',fig.path=\"figureObserved/\")\n\nset.seed(3)\n#source functions\n\nsource(\"Functions.R\")\n```\n\n```{r,echo=F,cache=FALSE}\npaste(\"Run Completed at\",Sys.time())\n```\n\n```{r}\n#reload if needed\nload(\"Observed.Rdata\")\n```\n\n#Observed dataset\n\n```{r}\n#read in flower morphology data, comes from Nectar.R\ndroppath<-\"C:/Users/Ben/Dropbox/\"\nfl.morph<-read.csv(\"InputData/FlowerMorphology.csv\")\n\n#First row is empty\nfl.morph<-fl.morph[-1,]\n\n#Bring in Hummingbird Morphology Dataset, comes from\nhum.morph<-read.csv(\"InputData/HummingbirdMorphology.csv\")\n  \n#taxonomy change, we are calling them Crowned Woodnymph's now.\nhum.morph$English<-as.character(hum.morph$English)\n\nhum.morph$English[hum.morph$English %in% \"Green-crowned Woodnymph\"]<-\"Crowned Woodnymph\"\n\n#Bring in Interaction Matrix\nint<-read.csv(\"InputData/HummingbirdInteractions.csv\")\n\n#just use camera data\nint<-int[is.na(int$TransectID),]\n\n#Correct known taxonomic disagreements, atleast compared to traits\nint[int$Iplant_Double==\"Alloplectus purpureus\",\"Iplant_Double\"]<-\"Glossoloma purpureum\"\nint[int$Iplant_Double==\"Capanea affinis\",\"Iplant_Double\"]<-\"Kohleria affinis\"\nint[int$Iplant_Double==\"Columnea cinerea\",\"Iplant_Double\"]<-\"Columnea mastersonii\"\nint[int$Iplant_Double==\"Alloplectus teuscheri\",\"Iplant_Double\"]<-\"Drymonia teuscheri\"\nint[int$Iplant_Double==\"Drymonia collegarum\",\"Iplant_Double\"]<-\"Alloplectus tetragonoides\"\n\n#Some reasonable level of presences, 3 points\nkeep<-names(which(table(int$Hummingbird)>4))\n\nint<-int[int$Hummingbird %in% keep,]\n\nm.dat<-droplevels(int[colnames(int) %in% c(\"ID\",\"Video\",\"Time\",\"Hummingbird\",\"Sex\",\"TransectID\",\"Transect_R\",\"Iplant_Double\",\"Pierce\",\"DateP\",\"Month\",\"ele\",\"Type\")])\n\n#Does the data come from camera or transect?\nm.dat$Type<-(is.na(m.dat$TransectID))*1\n\nm.dat$Year<-years(as.Date(m.dat$DateP))\n#one missing date\nm.dat$Year[m.dat$Year %in% 2012]<-2013\n\n#Number of bird species\nh_species<-nlevels(m.dat$Hummingbird)\n\n#Number of plant species\nplant_species<-nlevels(m.dat$Iplant_Double)\n\n#Get english name\ndath<-merge(m.dat,hum.morph, by.x=\"Hummingbird\",by.y=\"English\",keep=all)\n\n#Merge to flowers\nint.FLlevels<-levels(factor(dath$Iplant_Double))\n\n#Which flowers are we missing info for?\nmissingTraits<-int.FLlevels[!int.FLlevels %in% fl.morph$X]\n\n#print(paste(\"Missing Trait Information:\",missingTraits))\ndath<-merge(dath,fl.morph, by.x=\"Iplant_Double\",by.y=\"X\")\n```\n\n##Match Species to Morphology\n\n```{r}\ndath<-droplevels(dath[dath$Hummingbird %in% keep,])\n\n#observed traitmatching\ntraitmatchF<-abs(t(sapply(hum.morph$Bill,function(x){x-fl.morph$TotalCorolla})))\n\nrownames(traitmatchF)<-hum.morph$English\ncolnames(traitmatchF)<-fl.morph$Group.1\n```\n\n```{r}\n#match names #Round to 2 decimals #Convert to cm for winbugs, avoids numerical underflow\ntraitmatchT<-round(traitmatchF[rownames(traitmatchF) %in% dath$Hummingbird,colnames(traitmatchF) %in% dath$Iplant_Double],2)/10\n\ntraitmatchT<-traitmatchT[sort(rownames(traitmatchT)),sort(colnames(traitmatchT))]\n```\n\n##Morphology distributions\n\nBlack is flower corolla length\nRed is total hummingbird bill length\n```{r}\nggplot() + geom_density(data=fl.morph,aes(x=TotalCorolla),fill='black') + labs(x='Length (cm)') + geom_density(data=hum.morph,aes(x=Total_Culmen),fill='red',alpha=0.5) + theme_bw() \n```\n\n##Elevation ranges\n\nCreate a binary variable whether each observation was in a low elevation or high elevation transect. We have some species that just occur at the top of the gradient, and are not present in the sampling window of flowers at the low elevation.\n\nAccounting for non-availability.\nWe have to figure out which plants were sampled in which periods, and if it was sampled, the non-detection are 0 if it wasn't the non-detection are NA. then remove all the Na's.\n\n```{r}\nelevH<-read.csv(\"InputData/HummingbirdElevation.csv\",row.names=1)\nhead(elevH)\n\n#Gorgetted Sunangels wanders \n#rename columns\ncolnames(elevH)<-c(\"Hummingbird\",\"Low\",\"Mean\",\"High\",\"Elevation\")\nelevH$Bird<-1:nrow(elevH)\n\n#high elevation or low elevation\nelevP<-read.csv(\"InputData/PlantElevation.csv\",row.names=1)\ncolnames(elevP)<-c(\"Iplant_Double\",\"Low\",\"m\",\"High\",\"Elevation\")\n\nelevP$Plant<-1:nrow(elevP)\nelevP$Iplant_Double<-as.character(elevP$Iplant_Double)\n\n#Correct known taxonomic errors\nelevP[elevP$Iplant_Double %in% \"Alloplectus purpureus\",\"Iplant_Double\"]<-\"Glossoloma purpureum\"\nelevP[elevP$Iplant_Double %in% \"Capanea affinis\",\"Iplant_Double\"]<-\"Kohleria affinis\"\nelevP[elevP$Iplant_Double %in% \"Alloplectus teuscheri\",\"Iplant_Double\"]<-\"Drymonia teuscheri\"\nelevP[elevP$Iplant_Double %in% \"Columnea cinerea\",\"Iplant_Double\"]<-\"Columnea mastersonii\"\nelevP[elevP$Iplant_Double %in% \"Alloplectus tenuis\",\"Iplant_Double\"]<-\"Drymonia tenuis\"\n\n#Merge to observed Data\n#plants\ndathp<-merge(dath,elevP,by=\"Iplant_Double\")\n\n#birds\ndatph<-merge(dathp,elevH,by=\"Hummingbird\")\n\n```\n\n### Summarize Observations\n\n```{r}\n#ID for NA is holger transects, make the id's 1:n for each day of transect at each elevation, assuming no elevation was split across days.\ndatph$ID<-as.character(datph$ID)\n\nnoid<-datph[is.na(datph$ID),]\n\nid_topaste<-paste(noid$Transect_R,noid$DateP,\"Transect\",sep=\"_\")\ndatph[which(is.na(datph$ID)),\"ID\"]<-id_topaste\n  \nindatraw<- datph %>% group_by(Bird,Plant,ID,DateP) %>% summarize(Yobs=n(),Elev=mean(ele,na.rm=T),Transect_R=unique(Transect_R)) \n\nindatraw[order(indatraw$Yobs,decreasing=T),]\n\n#add unique Camera ID\nindatraw$Camera<-as.numeric(factor(indatraw$ID))\n\n#add day ID\nsdat<-split(indatraw,list(indatraw$Camera,indatraw$Plant),drop = T)\n\nsdat<-lapply(sdat,function(x){\n  x<-droplevels(x)\n  x$Day<-as.numeric(as.factor(x$DateP))\n  return(x)\n})\n\nindatraw<-rbind_all(sdat)\n\n#add months and years\nindatraw$Month<-as.numeric(factor(months(strptime(indatraw$DateP,format=\"%Y-%m-%d\")),levels=month.name))\nindatraw$Year<-years(indatraw$DateP)\n\n#Species names\nfor (x in 1:nrow(indatraw)){\n  indatraw$Hummingbird[x]<-as.character(elevH[elevH$Bird %in% indatraw$Bird[x],\"Hummingbird\"])\n  indatraw$Iplant_Double[x]<-as.character(elevP[elevP$Plant %in% indatraw$Plant[x],\"Iplant_Double\"])\n}\n```\n\nWhat elevation transect is each observation in?\nThe camera data need to be inferred from the GPS point.\n\n```{r}\n#cut working best on data.frame\nindatraw<-as.data.frame(indatraw)\n\n#which elevation bin is each observation within\nlabs<-paste(seq(1300,2500,200),seq(1500,2700,200),sep=\"_\")\nindatraw$Transect_R[is.na(indatraw$Transect_R)]<-as.character(cut(indatraw[is.na(indatraw$Transect_R),]$Elev,seq(1300,2700,200),labels=labs))\n```\n\n```{r}\n#match the traits\ntraitmelt<-melt(traitmatchT)\ncolnames(traitmelt)<-c(\"Hummingbird\",\"Iplant_Double\",\"Traitmatch\")\n```\n\n##Absences - accounting for non-detection\n\nWe have more information than just the presences, given species elevation ranges, we have absences as well. Absences are birds that occur at the elevation of the plant sample, but were not recorded feeding on the flower.\n\n```{r}\nindatlong<-acast(indatraw,Bird~Plant~Camera~Day,value.var=\"Yobs\")\nindatlong[is.na(indatlong)]<-0\n```\n\n```{r}\n#Only non-detections are real 0's, the rest are NA's and are removed.\n#Plants not surveyed in that time period\n#Hummingbirds not present at that elevation\n\n  for(x in 1:dim(indatlong)[3]){\n  \n  #Remove non sampled plants \n  a<-indatlong[,,x,]\n\n  #No observations at that plant\n  toNA<-as.numeric(names(which(apply(a,2,sum)==0)))\n  pres<-as.numeric(names(which(!apply(a,2,sum)==0)))\n  indatlong[,colnames(a) %in% toNA,x,]<-NA\n\n  if(length(pres)==0){next} else {\n\n  #Get elevation point of that sampling event\n  cam<-dimnames(indatlong)[[3]][x]\n  camelev<-    indatraw %>% filter(Camera==cam)  %>% .$Elev %>% mean()\n  \n  #for each hummingbird, was that camera within elevation?\n  for(i in 1:dim(a)[1]){\n      low<-elevH[elevH$Bird == rownames(a)[i],\"Low\"]\n      high<-elevH[elevH$Bird == rownames(a)[i],\"High\"]\n        \n        #if not in elev range, set to NA\n        \n        if(!((low < camelev) & (camelev < high))){\n            if(sum(indatlong[i,,x,],na.rm=T)>0){next}\n          #if you had a wandering individual outside range, allow interaction to occur.\n                indatlong[i,,x,]<-NA\n        }\n      }\n    }\n  }\n\n### There can't be absences in days that weren't sampled.\nfor (x in 1:dim(indatlong)[3]){\n  cam<-indatlong[,,x,]\n  for (y in 1:dim(cam)[3]){\n    sc<-sum(cam[,,y],na.rm=T)\n    if (sc ==0){\n      indatlong[,,x,y]<-NA\n    }\n  }\n}\n\n\n#melt and remove Na's\nindat<-melt(indatlong)\n\n#get only absence data\nindat<-indat[indat$value %in% 0,]\n\ncolnames(indat)<-c(\"Bird\",\"Plant\",\"Camera\",\"Day\",\"Yobs\")\n```\n\n```{r}\n#remerge the time period data for absences\nTimelookup<-indatraw %>% dplyr::select(Camera,Transect_R,Month,Year,Day,DateP,ID) %>% unique()\n\n#Get time information\nindat<-merge(indat,Timelookup,by=c(\"Camera\",\"Day\"))\n\n#bind to presence data\nindat<-as.data.frame(rbind_all(list(indat,indatraw)))\n\n#Species names\nfor (x in 1:nrow(indat)){\n  indat$Hummingbird[x]<-as.character(elevH[elevH$Bird %in% indat$Bird[x],\"Hummingbird\"])\n  indat$Iplant_Double[x]<-as.character(elevP[elevP$Plant %in% indat$Plant[x],\"Iplant_Double\"])\n}\n\n#Get trait information\n#match the traits\nindat<-merge(indat,traitmelt,by=c(\"Hummingbird\",\"Iplant_Double\"))\n```\n\n```{r}\n#keep<-unique(indat %>% group_by(Hummingbird,Camera,Day) %>% filter(Yobs>0) %>% summarise(n=n()) %>% summarize(d=n()) %>% filter(d>1) %>% summarize(s=n()) %>% .$Hummingbird)\n#indat<-indat[indat$Hummingbird %in% keep,]\n\n#take our sparkling violetear, does not occur year round\nindat<-indat[!indat$Hummingbird %in% \"Sparkling Violetear\",]\n```\n\n```{r}\n#Get flower transect data\nfull.fl<-read.csv(\"InputData/FlowerTransectClean.csv\")[,-1]\n\n #month should be capital \ncolnames(full.fl)[colnames(full.fl) %in% \"month\"]<-\"Month\"\n\n#group by month and replicate, remove date errors by making a max of 10 flowers, couple times where the gps places it in wrong transect by 1 to 2 meters. \nflower.month<-group_by(full.fl,Iplant_Double,Month,Year,Transect_R,Date_F) %>% dplyr::summarise(Flowers=sum(Total_Flowers,na.rm=TRUE))  %>% group_by(Iplant_Double,Transect_R,Month,Year) %>% dplyr::summarise(Flowers=mean(Flowers,na.rm=TRUE)) \n\n#Make month abbreviation column, with the right order\nflower.month$Month.a<-factor(month.abb[flower.month$Month],month.abb[c(1:12)])\n\n#Make year factor column\nflower.month$Year<-as.factor(flower.month$Year)\n\nindat<-merge(indat,flower.month,all.x=T,by=c(\"Iplant_Double\",\"Month\",\"Year\",\"Transect_R\"))\n\n#how many Na's, turn to na for the moment\nindat[is.na(indat$Flowers),\"Flowers\"]<-0\n\n#scale to 0-1\nindat$Flowers<-indat$Flowers/max(indat$Flowers)\n```\n\nReformat index for jags.\nJags needs a vector of input species 1:n with no breaks.\n\n```{r}\nindat$Hummingbird<-as.factor(indat$Hummingbird)\nindat$Iplant_Double<-as.factor(indat$Iplant_Double)\nindat$Camera<-as.factor(indat$Camera)\n\nindat$jBird<-as.numeric(indat$Hummingbird)\nindat$jPlant<-as.numeric(indat$Iplant_Double)\nindat$jCamera<-as.numeric(indat$Camera)\n\njagsIndexBird<-data.frame(Hummingbird=levels(indat$Hummingbird),jBird=1:length(levels(indat$Hummingbird)))\n \njagsIndexPlants<-data.frame(Iplant_Double=levels(indat$Iplant_Double),jPlant=1:length(levels(indat$Iplant_Double)))\n\n#Similiarly, the trait matrix needs to reflect this indexing.\njTraitmatch<-traitmatchT[rownames(traitmatchT) %in% unique(indat$Hummingbird),colnames(traitmatchT) %in% unique(indat$Iplant_Double)]\n\n#And resources\nresourcemat<-group_by(indat,jBird,jPlant,jCamera) %>% summarize(m=mean(unique(Flowers))) %>% acast(jBird~jPlant~Camera,fill=0) \n\n#and data for predictions\nwrite.csv(indat,\"InputData/ObservedData.csv\")\n```\n\n# Hierarcichal Nmixture Model\n\nFor hummingbird i visiting plant j recorded by camera k on day d:\n\n$$ Y_{i,j,k,d} \\sim Binom(N_{i,j,k},\\omega_i)$$\n$$N_{i,j,k} \\sim Pois(\\lambda_{i,j}) $$\n$$log(\\lambda_{i,j})<-\\alpha_i + \\beta_{1,i} * |Bill_i - Corolla_j| + \\beta_{2,i} *Resource_{j,k} $$\n\n**Priors**\n\nPlease recall that jags parameterizes models using precision, not sd (precision = 1/sd^2)\n\n$$\\omega_i \\sim (\\mu_{\\omega},\\tau_{\\omega})$$  $$\\mu_{\\omega} \\sim Normal(0,0.5)   \n$$\\tau_{\\omega} \\sim Uniform(0,10)\n\n$$\\alpha_i \\sim Normal(\\mu_{\\alpha},\\tau_{\\alpha})$$\n$$\\beta_{1,i} \\sim Normal(\\mu_{\\beta_1},\\tau_{\\beta_1})$$\n$$\\beta_{2,i} \\sim Normal(\\mu_{\\beta_2},\\tau_{\\beta_2})$$\n\n**Hyperpriors**\n$$\\mu_{\\alpha} \\sim Normal(0,0.0001)$$\n$$\\mu_{\\beta_1} \\sim Normal(0,0.0001)$$\n\n$$\\tau_{\\alpha} = \\sqrt[2]{\\frac{1}{\\sigma_{\\alpha}}}$$\n$$\\tau_{\\beta_1} = \\sqrt[2]{\\frac{1}{\\sigma_{\\beta_1}}}$$\n$$\\tau_{\\beta_2} = \\sqrt[2]{\\frac{1}{\\sigma_{\\beta_2}}}$$\n\n$$\\sigma_{\\beta_1} \\sim Half-Cauchy(0,1)$$\n$$\\sigma_{\\beta_1} \\sim Half-Cauchy(0,1)$$\n$$\\sigma_{\\beta_2} \\sim Half-Cauchy(0,1)$$\n\n# Poisson GLMM\n\n```{r,eval=F}\nruns<-50000\n\n#Source model\nsource(\"Bayesian/NoDetectNmixturePoissonRagged.R\")\n\n#print model\nprint.noquote(readLines(\"Bayesian//NoDetectNmixturePoissonRagged.R\"))\n\n  #Data objects for parallel run\n  Yobs=indat$Yobs\n  Bird=indat$jBird\n  Birds=max(indat$jBird)\n  Plant=indat$jPlant\n  Plants=max(indat$jPlant)\n  Camera=indat$jCamera\n  Cameras=max(indat$jCamera)\n  Traitmatch=jTraitmatch\n  Nobs=length(indat$Yobs)\n  resources=resourcemat\n\n  #A blank Y matrix - all present\n  Ninit<-rep(max(indat$Yobs)+1,Nobs)\n  \n  #Inits\n  InitStage <- function() {list(beta1=rep(0.5,Birds),alpha=rep(0.5,Birds),intercept=0,sigma_alpha=0.1,sigma_beta=0.1,N=Ninit,gamma1=0,gamma2=0)}\n  \n  #Parameters to track\n  ParsStage <- c(\"alpha\",\"beta1\",\"beta2\",\"intercept\",\"sigma_alpha\",\"sigma_beta1\",\"sigma_beta2\",\"ynew\",\"gamma1\",\"gamma2\",\"fit\",\"fitnew\")\n  \n  #MCMC options\n  ni <- runs  # number of draws from the posterior\n  nt <- 5   #thinning rate\n  nb <- runs*.95 # number to discard for burn-in\n  nc <- 2  # number of chains\n\n  Dat<-list(\"Yobs\",\"Bird\",\"Plant\",\"Plants\",\"Camera\",\"Cameras\",\"Traitmatch\",\"Birds\",\"Nobs\",\"Ninit\",\"resources\",\"nb\",\"nt\",\"nc\",\"ni\")\n    \n  system.time(m2_niave<-jags.parallel(Dat,InitStage,ParsStage,model.file=\"Bayesian/NoDetectNmixturePoissonRagged.jags\", n.iter=ni,n.burnin=nb,n.chains=nc,n.thin=nt))\n```\n\n```{r,eval=F}\n#recompile if needed\nload.module(\"dic\")\nruns<-100000\nrecompile(m2_niave)\nm2_niave<-update(m2_niave,n.iter=runs,n.burnin=runs*.9,n.thin = 5)\n```\n\n```{r}\npars_dniave<-extract_par(m2_niave,data=indat,Bird=\"jBird\",Plant=\"jPlant\")\npars_dniave$Model<-\"Poisson GLMM\"\n```\n\n##Assess Convergence\n\n```{r,cache=FALSE,fig.width=13,fig.height=5}\n###Chains\nggplot(pars_dniave[pars_dniave$par %in% c(\"alpha\",\"beta1\",\"beta2\"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_grid(par~species,scale=\"free\") + theme_bw() + labs(col=\"Chain\") + ggtitle(\"Detection Probability\")\n```\n\n```{r,fig.height=5,fig.width=11}\nggplot(pars_dniave[pars_dniave$par %in% c(\"gamma1\",\"gamma2\",\"sigma_alpha\",\"sigma_beta1\",\"sigma_beta2\",\"intercept\"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + theme_bw() + labs(col=\"Chain\") + ggtitle(\"Trait-matching regression\") + facet_wrap(~par,scales=\"free\")\n```\n\n# Observed Data With Detection\n\n## Traits\n\n```{r,eval=F}\nruns<-200000\n\n#Source model\nsource(\"Bayesian/NmixturePoissonRagged_traits.R\")\n\n#print model\nprint.noquote(readLines(\"Bayesian//NmixturePoissonRagged_traits.R\"))\n\n  #for parallel run\n  Yobs=indat$Yobs\n  Bird=indat$jBird\n  Plant=indat$jPlant\n  Camera=indat$jCamera\n  Cameras=max(indat$jCamera)\n  Traitmatch=jTraitmatch\n  Birds=max(indat$jBird)\n  Plants=max(indat$jPlant)\n  Nobs=length(indat$Yobs)\n\n  #A blank Y matrix - all present\n  Ninit<-array(dim=c(Birds,Plants,Cameras),data=max(indat$Yobs)+1)\n\n  #Inits\n  InitStage <- function() {list(beta1=rep(0.5,Birds),alpha=rep(0.5,Birds),intercept=0,sigma_alpha=0.1,sigma_beta1=0.1,N=Ninit,gamma1=0)}\n  \n  #Parameters to track\n  ParsStage <- c(\"detect\",\"alpha\",\"beta1\",\"intercept\",\"sigma_alpha\",\"sigma_beta1\",\"gamma1\",\"dprior\")\n  \n  #MCMC options\n  ni <- runs  # number of draws from the posterior\n  nt <- 10   #thinning rate\n  nb <- runs*.95 # number to discard for burn-in\n  nc <- 2  # number of chains\n\n  Dat<-list(\"Yobs\",\"Bird\",\"Plant\",\"Plants\",\"Traitmatch\",\"Birds\",\"Nobs\",\"Ninit\",\"Camera\",\"Cameras\",\"nb\",\"nc\",\"ni\",\"nt\")\n\n    system.time(traits<-jags.parallel(Dat,InitStage,ParsStage,model.file=\"Bayesian/NmixturePoissonRagged_traits.jags\",n.thin=nt, n.iter=ni,n.burnin=nb,n.chains=nc))\n  \n```\n\n```{r,eval=F}\n#recompile if needed\nload.module(\"dic\")\nruns<-100000\nrecompile(traits)\ntraits<-update(traits,n.iter=runs,n.burnin=runs*.9,n.thin=5)\n```\n\n```{r}\n#extract par to data.frame\npars_detect_traits<-extract_par(traits,data=indat,Bird=\"jBird\",Plant=\"jPlant\",ynew=F)\n\n#name\npars_detect_traits$Model<-\"Nmixture\"\n```\n\n###Assess Convergence\n\n```{r,cache=FALSE,fig.width=13,fig.height=5}\n###Chains\nggplot(pars_detect_traits[pars_detect_traits$par %in% c(\"detect\",\"alpha\",\"beta1\"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_grid(par~species,scale=\"free\") + theme_bw() + labs(col=\"Chain\") + ggtitle(\"Detection Probability\")\n```\n\n###Hierarcichal Posteriors\n\n```{r,fig.height=5,fig.width=11}\nggplot(pars_detect_traits[pars_detect_traits$par %in% c(\"gamma1\",\"intercept\",\"sigma_alpha\",\"sigma_beta1\",\"dprior\"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + theme_bw() + labs(col=\"Chain\") + ggtitle(\"Trait-matching regression\") + facet_wrap(~par,scales=\"free\")\n```\n\n## Traits + Abundance\n\n```{r,eval=F}\nruns<-200000\n\n#Source model\nsource(\"Bayesian/NmixturePoissonRagged.R\")\n\n#print model\nprint.noquote(readLines(\"Bayesian//NmixturePoissonRagged.R\"))\n\n  #for parallel run\n  Yobs=indat$Yobs\n  Bird=indat$jBird\n  Plant=indat$jPlant\n  Camera=indat$jCamera\n  Cameras=max(indat$jCamera)\n  Traitmatch=jTraitmatch\n  Birds=max(indat$jBird)\n  Plants=max(indat$jPlant)\n  Nobs=length(indat$Yobs)\n  resources=resourcemat\n\n  #A blank Y matrix - all present\n  Ninit<-array(dim=c(Birds,Plants,Cameras),data=max(indat$Yobs)+1)\n\n  #Inits\n  InitStage <- function() {list(beta1=rep(0.5,Birds),alpha=rep(0.5,Birds),intercept=0,sigma_alpha=0.1,sigma_beta2=0.1,sigma_beta1=0.1,N=Ninit,gamma1=0)}\n  \n  #Parameters to track\n  ParsStage <- c(\"detect\",\"alpha\",\"beta1\",\"beta2\",\"intercept\",\"sigma_alpha\",\"sigma_beta1\",\"sigma_beta2\",\"gamma1\",\"gamma2\",\"fit\",\"fitnew\",\"dprior\",\"sigma_detect\",\"ynew\")\n  \n  #MCMC options\n  ni <- runs  # number of draws from the posterior\n  nt <- 10   #thinning rate\n  nb <- runs*.95 # number to discard for burn-in\n  nc <- 2  # number of chains\n\n  Dat<-list(\"Yobs\",\"Bird\",\"Plant\",\"Plants\",\"Traitmatch\",\"Birds\",\"Nobs\",\"Ninit\",\"Camera\",\"Cameras\",\"resources\",\"nc\",\"nb\",\"ni\",\"nt\")\n\n    system.time(m2<-jags.parallel(Dat,InitStage,parameters.to.save=ParsStage,model.file=\"Bayesian/NmixturePoissonRagged.jags\",n.thin=nt, n.iter=ni,n.burnin=nb,n.chains=nc))\n```\n\n```{r,eval=F}\n#recompile if needed\nload.module(\"dic\")\nruns<-100000\nrecompile(m2)\nm2<-update(m2,n.iter=runs,n.burnin=runs*.8,n.thin=5,parameters.to.save=ParsStage)\n```\n\n```{r}\n#extract par to data.frame\npars_detect<-extract_par(m2,data=indat,Bird=\"jBird\",Plant=\"jPlant\")\n\n#name\npars_detect$Model<-\"Nmixture\"\n```\n\n###Assess Convergence\n\n```{r,cache=FALSE,fig.width=13,fig.height=5}\n###Chains\nggplot(pars_detect[pars_detect$par %in% c(\"detect\",\"alpha\",\"beta1\",\"beta2\"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_grid(par~species,scale=\"free\") + theme_bw() + labs(col=\"Chain\") + ggtitle(\"Detection Probability\")\n```\n\n###Hierarcichal Posteriors\n\n```{r,fig.height=5,fig.width=11}\nggplot(pars_detect[pars_detect$par %in% c(\"gamma1\",\"gamma2\",\"intercept\",\"sigma_alpha\",\"sigma_beta1\",\"sigma_beta2\",\"dprior\",\"sigma_detect\"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + theme_bw() + labs(col=\"Chain\") + ggtitle(\"Trait-matching regression\") + facet_wrap(~par,scales=\"free\")\n```\n\n```{r}\n#Bind together the two models\nparsObs<-rbind(pars_detect,pars_dniave)\n```\n\n##Posteriors\n\n```{r,cache=FALSE,fig.width=11,fig.height=14}\n###Posterior Distributions\nggplot(parsObs[parsObs$par %in% c(\"detect\",\"alpha\",\"beta1\",\"beta2\"),],aes(x=estimate,fill=Model)) + geom_histogram(position='identity') + ggtitle(\"Estimate of parameters\") + facet_grid(species~par,scales=\"free\") + theme_bw() \n```\n\n```{r,cache=FALSE,fig.width=10,fig.height=5}\n#Detection figure\nggplot(parsObs[parsObs$par %in% c(\"detect\"),],aes(x=as.factor(species),y=estimate,fill=Model)) + geom_violin() + ggtitle(\"Estimate of parameters\") + theme_bw() + ggtitle(\"Detection Probability\") +facet_wrap(~Model,scales=\"free\") \n\npars_detect<-merge(pars_detect,jagsIndexBird,by.x=\"species\",by.y=\"jBird\",all.x=T)\n\nggplot(pars_detect[pars_detect$par %in% c(\"detect\"),],aes(x=estimate)) + geom_histogram() + ggtitle(\"Posterior Distribution\") + theme_bw() + facet_wrap(~Hummingbird,ncol=5) + xlab(\"Probability of Detection\")\nggsave(\"Figures/DetectionProb.jpg\",dpi=300,height=7,width=11)\n```\n\n```{r,cache=FALSE,fig.height=5,fig.width=13}\nggplot(parsObs[parsObs$par %in% c(\"gamma1\",\"gamma2\",\"intercept\",\"sigma_alpha\",\"sigma_beta1\",\"sigma_beta2\",\"dprior\",\"sigma_detect\"),],aes(x=estimate,fill=Model)) + geom_histogram() + ggtitle(\"Trait matching regression parameters\") + facet_wrap(~par,scale=\"free\",nrow=2) + theme_bw() \n```\n\n###Overall predicted relationship \n\nCalculated predicted visitation rates\n\nDoes accounting for non-independence and detection change our estimate of trait matching?\n\n```{r,fig.height=6,fig.width=10}\ncastdf<-dcast(parsObs[parsObs$par %in% c(\"gamma1\",\"gamma2\",\"intercept\"),], Model+Chain + Draw~par,value.var=\"estimate\")\n\ncastdf<-split(castdf,castdf$Model)\n```\n\n## Trait+Abundance\n\n```{r}\npredy<-rbind_all(lapply(castdf,function(i){\n  #calculate trajectory and append model\n  pr<-trajF(alpha=i$intercept,beta1=i$gamma1,beta2=i$gamma2,x=indat$Traitmatch,resources=indat$Flowers)\n  pr$Model<-unique(i$Model)\n  return(pr)\n  }))\n\nfplot<-ggplot(data=predy,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper,fill=Model),alpha=0.3)  + geom_line(aes(y=mean,col=Model),size=.4,linetype=\"dashed\") + theme_bw() + ylab(\"Daily Interactions\") + xlab(\"Difference between Bill and Corolla Length\") + geom_point(data=indat,aes(x=Traitmatch,y=Yobs),size=.5,alpha=.5) + labs(fill=\"Model\",col=\"Model\") + ggtitle(\"Traits+Abundance\")\nfplot\nggsave(\"Figures/BothObs.svg\",height=5,width=7)\nggsave(\"Figures/BothObs.jpg\",heigh=5,width=7,dpi=300)\n```\n\n# Does including abundance change the biological inference?\n\nWe are only interested in the inference for the observed detection model data.\n\n## Trait only\n\n```{r}\ncastdf<-dcast(pars_detect_traits[pars_detect_traits$par %in% c(\"gamma1\",\"intercept\"),], Chain + Draw~par,value.var=\"estimate\")\n\npredy_traits<-trajF(alpha=castdf$intercept,beta1=castdf$gamma1,beta2=0,x=indat$Traitmatch,resources=indat$Flowers)\n\ntplot<-ggplot(data=predy_traits,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.3)  + geom_line(aes(y=mean),size=.4,linetype=\"dashed\") + theme_bw() + ylab(\"Daily Interactions\") + xlab(\"Difference between Bill and Corolla Length\") + geom_point(data=indat,aes(x=Traitmatch,y=Yobs),size=.5,alpha=.5) + labs(fill=\"Model\",col=\"Model\") + ggtitle(\"Traits\")\ntplot\n```\n\n## Abundance estimate\n\nAs part of the full model.\n\n```{r}\ncastdf<-dcast(pars_detect[pars_detect$par %in% c(\"gamma1\",\"gamma2\",\"intercept\"),], Chain + Draw~par,value.var=\"estimate\")\n\npredy_abundance<-trajA(alpha=castdf$intercept,beta1=castdf$gamma1,beta2=castdf$gamma2,x=indat$Traitmatch,resources=indat$Flowers)\n\naplot<-ggplot(data=predy_abundance,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.3)  + geom_line(aes(y=mean),size=.4,linetype=\"dashed\") + theme_bw() + ylab(\"Daily Interactions\") + xlab(\"Available Resources\") + geom_point(data=indat,aes(x=Flowers,y=Yobs),size=.5,alpha=.5) + labs(fill=\"Model\",col=\"Model\") + ggtitle(\"Abundance\")\naplot\n```\n\n```{r}\nallpred<-list('Traits+Abundance'=predy[predy$Model==\"Nmixture\",!colnames(predy) %in% \"Model\"],Traits=predy_traits)\n\nallpred<-melt(allpred,id.vars=colnames(predy_traits))\n\nallplot<-ggplot(data=allpred,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper,fill=L1),alpha=0.4)  + geom_line(aes(y=mean,col=L1),size=.4,linetype=\"dashed\") + theme_bw() + ylab(\"Daily Interactions\") + xlab(\"Difference between Bill and Corolla Length (cm)\") + geom_point(data=indat,aes(x=Traitmatch,y=Yobs),size=.5,alpha=.7) + labs(fill=\"Model\",col=\"Model\") + ggtitle(\"Nmixture Model Comparison\") + scale_fill_manual(values=c(\"black\",\"red\")) + scale_color_manual(values=c(\"black\",\"red\"))\nallplot\nggsave(\"Figures/AddingAbundance.jpeg\",height=3,width=5.5)\n```\n\n##Species Predictions\n\n```{r,fig.height=10,fig.width=11}\ncastdf<-dcast(parsObs[parsObs$par %in% c(\"beta1\",\"beta2\",\"alpha\"),], species +Chain +Model+ Draw~par,value.var=\"estimate\")\n\n#Turn to species level\ncastdf$species<-factor(castdf$species,levels=1:max(as.numeric(castdf$species)))\n\nspecies.split<-split(castdf,list(castdf$species,castdf$Model))\n\nspecies.traj<-list()\n\nfor(d in 1:length(species.split)){\n  x<-species.split[[d]]\n  #species name\n  index<-jagsIndexBird[unique(x$species),\"Hummingbird\"]\n  \n  #range of trait distances\n  tsp<-indat %>% filter(Hummingbird==index) %>% .$Traitmatch\n  \n  #Range of abundances\n    fsp<-indat %>% filter(Hummingbird==index) %>% .$Flowers\n    \n  species.traj[[d]]<-trajF(alpha=x$alpha,beta1=x$beta1,beta2=x$beta2,x=tsp,resources=fsp)\n}\n\nnames(species.traj)<-names(species.split)\n\nspecies.traj<-melt(species.traj,id.var=colnames(species.traj[[1]]))\n\n#split out names and model\nspecies.traj[,c(\"Index\",\"Model\")]<-colsplit(species.traj$L1,\"\\\\.\",c(\"Index\",\"Model\"))\n\nspe<-merge(species.traj,jagsIndexBird,by.x=\"Index\",by.y=\"jBird\")\n\n#match colnames\n\n#plot and compare to original data\nggplot(data=spe[,],aes(x=x)) + geom_point(data=indat,aes(x=Traitmatch,y=Yobs)) + geom_ribbon(aes(ymin=lower,ymax=upper,fill=Model),alpha=0.2)  + geom_line(aes(y=mean,col=Model),size=1) + theme_bw() + ylab(\"Interactions\") + xlab(\"Difference between Bill and Corolla Length\") + facet_wrap(~Hummingbird,scales=\"free\",ncol=3)+ labs(fill=\"Model\")  + ylab(\"Interactions per day\")\n\nggsave(\"Figures/SpeciesPredictionsBoth.jpg\",dpi=300,height=8,width=10)\n```\n\n##Species Predictions - Abundance\n\n### How many overlap 0?\n\n```{r,fig.height=10,fig.width=11}\ncastdf<-dcast(parsObs[parsObs$par %in% c(\"beta1\",\"beta2\",\"alpha\"),], species +Chain +Model+ Draw~par,value.var=\"estimate\")\n\nspbeta2<-filter(castdf,Model %in% \"Nmixture\") %>% select(species,beta2) %>% group_by(species) %>% summarize(lower=quantile(beta2,0.05),mean=mean(beta2),upper=quantile(beta2,0.95))\n\nspbeta2<-merge(spbeta2,jagsIndexBird,by.x=\"species\",by.y=\"jBird\")\nggplot(spbeta2,aes(x=Hummingbird,y=mean,ymin=lower,ymax=upper)) + geom_pointrange() + geom_hline(yintercept=0,linetype='dashed',col='red') + theme_bw() + coord_flip() + labs(y=\"Effect of Resources\")\n```\n\n### Abundance Predictions\n\n```{r,fig.height=10,fig.width=13}\n#\n#Turn to species level\ncastdf$species<-factor(castdf$species,levels=1:max(as.numeric(castdf$species)))\n\nspecies.split<-split(castdf,list(castdf$species,castdf$Model))\n\nspecies.traj<-list()\n\nfor(d in 1:length(species.split)){\n  x<-species.split[[d]]\n  #species name\n  index<-jagsIndexBird[unique(x$species),\"Hummingbird\"]\n  \n  #range of trait distances\n  tsp<-indat %>% filter(Hummingbird==index) %>% .$Traitmatch\n  \n  #Range of abundances\n    fsp<-indat %>% filter(Hummingbird==index) %>% .$Flowers\n    \n  species.traj[[d]]<-trajA(alpha=x$alpha,beta1=x$beta1,beta2=x$beta2,x=tsp,resources=fsp)\n}\n\nnames(species.traj)<-names(species.split)\n\nspecies.traj<-melt(species.traj,id.var=colnames(species.traj[[1]]))\n\n#split out names and model\nspecies.traj[,c(\"Index\",\"Model\")]<-colsplit(species.traj$L1,\"\\\\.\",c(\"Index\",\"Model\"))\n\nspe<-merge(species.traj,jagsIndexBird,by.x=\"Index\",by.y=\"jBird\")\n\n#match colnames\n\n#plot and compare to original data\nggplot(data=spe[,],aes(x=x)) + geom_point(data=indat,aes(x=Flowers,y=Yobs)) + geom_ribbon(aes(ymin=lower,ymax=upper,fill=Model),alpha=0.2)  + geom_line(aes(y=mean,col=Model),size=1) + theme_bw() + ylab(\"Interactions\") + xlab(\"Difference between Bill and Corolla Length\") + facet_wrap(~Hummingbird,scales=\"free\",ncol=3)+ labs(fill=\"Model\")  + ylab(\"Interactions per day\")\n```\n\n##Discrepancy \n\nThe goodness of fit is a measured as chi-squared. The expected value for each day is the detection rate * the estimate intensity of interactions. The expected value is compared to the observed value of the actual data. In addition, a replicate dataset is generated from the posterior predicted intensity. Better fitting models will have lower discrepancy values and be \nBetter fitting models are smaller values and closer to the 1:1 line. A perfect model would be 0 discrepancy. This is unrealsitic given the stochasticity in the sampling processes. Rather, its better to focus on relative discrepancy. In addition, a model with 0 discrepancy would likely be seriously overfit and have little to no predictive power.\n\n```{r,fig.height=4,fig.width=8,message=F,warning=F}\nfitstat<-parsObs[parsObs$par %in% c(\"fit\",\"fitnew\"),]\nfitstat<-dcast(fitstat,Model+Draw+Chain~par,value.var=\"estimate\")\n\nymin<-round(min(fitstat$fit))\nymax<-round(max(fitstat$fit))\nab<-data.frame(x=0:ymax,y=0:ymax)\ndisc_obs<-ggplot(fitstat,aes(x=fit,y=fitnew)) + geom_point(aes(col=Model)) + theme_bw() + labs(x=\"Discrepancy of observed data\",y=\"Discrepancy of replicated data\",col=\"Model\")  + ggtitle(\"Empirical Data\") + geom_line(data=ab,aes(x=x,y=y)) + coord_fixed() + ylim(ymin=0,ymax=max(max(c(fitstat$fit,fitstat$fitnew)))) + xlim(xmin=0,xmax=max(max(c(fitstat$fit,fitstat$fitnew))))\ndisc_obs\nggsave(\"Figures/ObservedDiscrepancy.jpeg\",width = 5,height=10)\n```\n\n##Detection table\n\n```{r}\ndp<-group_by(pars_detect[pars_detect$par %in% c(\"detect\"),],species) %>% summarise(mean=round(mean(estimate,na.rm=T),3)*100,lower=round(quantile(estimate,0.025,na.rm=T),3)*100,upper=round(quantile(estimate,0.975,na.rm=T),3)*100)\n\ntab<-merge(dp,jagsIndexBird,by.x=\"species\",by.y=\"jBird\")[,-1]\ntab[,c(4,1,2,3)]\nwrite.csv(tab[,c(4,1,2,3)],\"Figures/Table1.csv\")\n```\n\n##Sampling intensity and detection for each hummingbird species\n\nThe probability of missing a species at each daily visit is 1 - detection probability.\n\nThe probability of missing a species on sequential visits is (1- detection probability) * (1 - detection probability).\n\nWe are interested in the number of sampling events that minimize this value to some reasonable threshold. I have chosen 0.05 by convention. \n\nThe following figure represesent the estimated number of daily surveys to capture a hummingbird event given that we know it occurs. These data can be thought of as successful draws from a negative binomial distribution.\n\nIt is easiest to interpret as the number of days until you are likely to see an interaction, so i prefer to calculate:\n\n$$ 1-(1-p)^n $$\n$$ p = probability of detection$$\n$$ n = days sample $$\n\n```{r,fig.width=13,fig.height=6}\ndp<-function(n,p){\n  1-((1-p)^n)\n}\n\nts<-split(tab,tab$Hummingbird,drop=T)\ndetectd<-lapply(ts,function(x){\n  meanD<-dp(n=1:10,p=x$mean/100)\n  lowerD<-dp(n=1:10,p=x$lower/100)\n  upperD<- dp(n=1:10,p=x$upper/100)\n  data.frame(Days=1:10,mean=meanD,lower=lowerD,upper=upperD)\n})\n\nmd<-melt(detectd,id.var=\"Days\")\nmd<-dcast(md,...~variable)\n\n#get the 0.5 line\ndpn<-function(t,p){\n  n<-(1 - (1-t))/(p/100)\n  return(n)\n}\n\n#for each bird get the upper and middle estimate for 50% chance.\ndaydf<-list()\nfor (x in 1:nrow(tab)){\n  mean_day=dpn(t=0.5,tab$mean[x])\n  lower_day=dpn(t=0.5,tab$lower[x])\n  upper_day=dpn(t=0.5,tab$upper[x])\n  daydf[[x]]<-data.frame(L1=tab$Hummingbird[x],mean=mean_day,lower=lower_day,upper=upper_day)\n}\ndaydf<-rbind_all(daydf)\n\nggplot(md) + geom_ribbon(alpha=.5,aes(x=Days,fill=L1,y=mean,ymin=lower,ymax=upper)) + geom_line(aes(x=Days,fill=L1,y=mean,ymin=lower,ymax=upper)) + facet_wrap(~L1,nrow=4,scale=\"free_x\")  + ylab(\"Probability of detecting a interaction\") + scale_fill_discrete(guide=\"none\") + theme_bw() + scale_x_continuous(breaks=seq(0,10,2),limits=c(0,10))+ geom_rect(fill='grey',data=daydf,alpha=0.4,aes(xmax=upper,xmin=lower,ymin=0,ymax=Inf)) + ylim(0,1)\nggsave(\"Figures/DetectionDays.jpeg\",height=7,width=9,dpi=300) \n```\n\nThe number of days it would take to have 50% confidence you have sampled enough to capture known interactions is the x axis value where the dotted line hits the curve.\n\n```{r}\nsampling<-indatraw %>% group_by(Hummingbird) %>% summarize(Obs=length(Hummingbird))\n\ntabD<-merge(tab,sampling,by=\"Hummingbird\")\nggplot(tabD,aes(x=Obs,ymin=lower,ymax=upper,y=mean)) + geom_pointrange() + labs(y=\"Detectability\",x=\"Detections\") + geom_text(aes(label=Hummingbird),vjust=2) + theme_bw() + xlim(0,175)\n```\n\n##DIC Table\n\n```{r}\nm2_niave$BUGSoutput$DIC\nm2$BUGSoutput$DIC\n```\n\n#Predicted versus Observed Data\n\n```{r}\nm<-max(jTraitmatch)-jTraitmatch\n\nmat<-indat %>% group_by(jBird,jPlant) %>% summarize(n=sum(Yobs))\ntrue_state<-acast(mat,jBird~jPlant,fill=0)\n```\n\n###Test Statistic\n\nChisquared statistic is (observed-expected)^2/(expected + 0.5), we add the 0.5 to avoid dividing by 0. For each combination of birds and plants, predicted versus  observed for each data point.\n\n#Compare using true known interactions\n\n## Poisson GLMM\n\n```{r}\n#Discrepancy function\nchisq<-function(o,e){(o-e)^2/(e+0.5)}\n\nN_niave<-pars_dniave[ pars_dniave$par %in% \"ynew\",]\n\nbydraw<-split(N_niave,list(N_niave$Chain,N_niave$Draw))\n\n#remove large N matrix\nrm(pars_dniave,N_niave)\ngc()\n\nocc_nodetect_matrix<-lapply(bydraw,function(x){\n  r<-acast(x,species ~ plant,value.var = \"estimate\",fun.aggregate = sum)\n})\n\n#calculate discrep on those deviates\nocc_nodetect<-lapply(occ_nodetect_matrix,function(r){\n    #for each position what is the chisq\n  rmerge<-matrix(nrow = nrow(true_state),ncol=ncol(true_state))\n  colnames(rmerge)<-colnames(true_state)\n  rownames(rmerge)<-rownames(true_state)\n  for (x in 1:nrow(r)){\n    for (y in 1:ncol(r)){\n     rmerge[x,y]<-chisq(o=r[x,y],e=true_state[x,y])\n      }\n    }\n  return(rmerge)\n})\n\nnames(occ_nodetect)<-1:length(occ_nodetect)\nnames(occ_nodetect_matrix)<-1:length(occ_nodetect_matrix)\n```\n\n##With Detection\n\n```{r}\nN<-pars_detect[pars_detect$par %in% \"ynew\",]\nbydraw<-split(N,list(N$Chain,N$Draw))\n\n#remove large N matrix\nrm(N)\ngc()\n\nocc_matrix<-lapply(bydraw,function(x){\n  r<-acast(x,species ~ plant,value.var = \"estimate\",fun.aggregate = sum)\n  })\n\n#calculate discrep for those aggregated matrices\nocc<-lapply(occ_matrix,function(r){\n    #for each position what is the chisq\n  rmerge<-matrix(nrow = nrow(true_state),ncol=ncol(true_state))\n  colnames(rmerge)<-colnames(true_state)\n  rownames(rmerge)<-rownames(true_state)\n  for (x in 1:nrow(r)){\n    for (y in 1:ncol(r)){\n     rmerge[x,y]<-chisq(o=r[x,y],e=true_state[x,y])\n      }\n  }\n  return(rmerge)\n})\n\nnames(occ)<-1:length(occ)\nnames(occ_matrix)<-1:length(occ_matrix)\n\n```\n\n##Compare to observed data\n\n```{r,fig.width=12}\nmmat<-melt(true_state)\ncolnames(mmat)<-c(\"Bird\",\"Plant\",\"True_State\")\n\n#append to predicted matrices\n\n#Nmixture with detection\nmocc<-melt(occ_matrix)\ncolnames(mocc)<-c(\"Bird\",\"Plant\",\"Nmixture\",\"Iteration\")\nsimdat<-merge(mocc,mmat,by=c(\"Bird\",\"Plant\"))\n\n#Nmixture with nodetection\nmoccd<-melt(occ_nodetect_matrix)\ncolnames(moccd)<-c(\"Bird\",\"Plant\",\"Poisson GLMM\",\"Iteration\")\n\nsimdat<-merge(simdat,moccd,by=c(\"Bird\",\"Plant\",\"Iteration\"))\n\nsimdat<-melt(simdat,measure.vars = c(\"Nmixture\",\"Poisson GLMM\"))\n\nggplot(simdat,aes(x=True_State,y=value,col=variable)) + geom_point() + geom_abline() + labs(col=\"Model\") + ylab(\"Predicted State\") + xlab(\"True State\") + theme_bw() + facet_wrap(~variable)\n\n```\n\n##Summary of discrepancy of predicted matrices\n\n```{r}\n#Nmixture without detection\noccno_disc<-sapply(occ_nodetect,function(x) mean(x))\n\n#Nmixture with detection\nocc_disc<-sapply(occ,function(x) mean(x))\n\n#compared to bayesian\nggplot() + xlab(\"Chi-squared Discrepancy\") + geom_histogram(data=data.frame(occ_disc),aes(x=occ_disc),fill=\"red\",alpha=.6) + theme_bw() +geom_vline(aes(xintercept=mean(occ_disc)),linetype=\"dashed\",col=\"red\") + geom_histogram(data=data.frame(occno_disc),aes(x=occno_disc),fill=\"orange\",alpha=.6) + geom_vline(aes(xintercept=mean(occno_disc)),linetype=\"dashed\",col=\"orange\")\n```\n\n##Comparison of summary statistics for all three approaches\n\n```{r}\nd<-list(Nmixture=occ,Poisson_GLM=occ_nodetect)\nd<-melt(d)\ncolnames(d)<-c(\"Bird\",\"Plant\",\"value\",\"Iteration\",\"Model\")\n\nd %>% group_by(Model,Iteration) %>% summarize(mean=mean(value),sd=sd(value),sum=sum(value)) %>% group_by(Model) %>% summarize(mean_mean=round(mean(mean),2),mean_sd=round(sd(mean),2),mean_sum=round(mean(sum),2))\n```\n\nMerge with morphological data.\n\n```{r}\njT<-indat %>% group_by(Bird=jBird,Plant=jPlant) %>% summarize(Traitmatch=unique(Traitmatch))\nsimdat<-merge(simdat,jT,by=c(\"Bird\",\"Plant\"))\n\nmmat<-merge(mmat,jT,by=c(\"Bird\",\"Plant\"))\n```\n\n#Predicted total number of visits based on morphology\n\n```{r}\nsimT<-simdat %>% group_by(variable,Traitmatch) %>% summarize(Lower=quantile(value,0.05),Upper=quantile(value,0.95),y=mean(value))\n\nggplot(simT,aes(x=Traitmatch)) + geom_ribbon(aes(ymin=Lower,ymax=Upper,fill=variable),alpha=0.6) + geom_line(aes(y=y,col=variable),linetype='dashed') + theme_bw() + facet_wrap(~variable,nrow=3) + geom_point(data=mmat,aes(y=True_State))\n```\n\n\n```{r}\ngc()\nsave.image(\"Observed.Rdata\")\n```\n\n",
    "created" : 1461336362538.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1841242518",
    "id" : "89684EA0",
    "lastKnownWriteTime" : 1462296337,
    "path" : "~/Occupy/Observed.Rmd",
    "project_path" : "Observed.Rmd",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_markdown"
}