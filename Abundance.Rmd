---
title: Accounting for detection bias increases trait-matching in a tropical plant-hummingbird
  network
author: "Ben Weinstein - Stony Brook University"
date: "Monday, March 16, 2015"
output: html_document
---

```{r,warning=FALSE,message=FALSE,echo=FALSE,cache=FALSE}
library(reshape2)
library(chron)
library(ggplot2)
library(knitr)
library(R2jags)
library(dplyr)
library(stringr)
library(gridExtra)
library(boot)
library(picante)
library(bipartite)

opts_chunk$set(message=FALSE,warning=FALSE,fig.width=5,fig.height=4,echo=TRUE,cache=TRUE,cache.path = 'jp_cache/',fig.align='center',fig.path="figure/")

setwd("C:/Users/Ben/Documents/Occupy/")

set.seed(11)
#load("Abundance.RData")
```

#Simulation   

I first create data with constant detection for each hummingbird speices, and the interaction frequency is a function of a species hierarcichal model and corolla similarity. There is uneven sampling among species.

### Parameters

* 8 hummingbird species
* Range of hummingbird bill sizes (mm) ~ Pois(2)
* Twenty plants
* Range of corolla sizes (mm) ~ Pois(2)
* Mean frequeny ($\lambda$) for each hummingbird is drawn from U(0,10)  
* For each plant the occupancy is N($\lambda$,0.2) (truncated 0-1) 
* Trait matching (minimizing Bill-Corolla difference) is drawn from a hierarcichal distribution
$$log(\lambda)<-\alpha_i + \beta_i *traitmatch$$
$$\alpha=N(3,.01)$$
$$\beta = N(-.01,.001)$$

* Imperfect detection 
* $p_i = U(0,1)$ 
* 24 month replicates
* Phenology = .5 (plants are in flower/present .5 of surveys)

**View simulated strength and form of trait matching **

```{r,fig.height=5,fig.width=8}
#Number of hummingbird species
h_species=8
plant_species=20
months=24
detection=runif(h_species,0,1)
phenology=.5

#Bill sizes
Bill<-rpois(h_species,10)

#Corolla sizes
Corolla<-rpois(plant_species,15)

#Subtract both and take absolute value
traitmatch<-abs(sapply(Corolla,function(x) x - Bill)/10)

#regression slope
gamma=-0.5
intercept<-3
sigma_slope<- 0.2
sigma_intercept<- 0.2

beta<-rnorm(h_species,gamma,sigma_slope)
alpha<-rnorm(h_species,intercept,sigma_intercept)

#fit regression
lambda<-exp(alpha + beta * traitmatch)

true_interactions<-sapply(lambda,function(x){rpois(1,x)})

#convert to matrix
true_interactions<-matrix(nrow=h_species,ncol=plant_species,data=true_interactions)

#combine and melt into a single dataframe
mdat<-dcast(melt(list(y=true_interactions,x=traitmatch)),Var1+Var2~L1)

ggplot(mdat,aes(x=x,y=y,col=as.factor(Var1))) + geom_point() + geom_smooth(aes(group=1),method="glm",family="poisson",formula=y~x) + theme_bw() + labs(x="Bill-Corolla Difference",y="Occurrences","Hummingbird") + ggtitle("Correlation in Simulated Data") + labs(col="Species")

```

### True Interaction Matrix

```{r,fig.width=12}
#Reshape into a nicer format
colnames(mdat)<-c("Hummingbird","Plant","Bill_Diff","True_State")

trueplot<-ggplot(mdat,aes(y=as.factor(Plant),x=as.factor(Hummingbird),fill=True_State)) + geom_tile() + labs(x="Hummingbird",y="Plant",fill="Presence") + ggtitle("True State ") + scale_fill_continuous(low="white",high="red","Occurrences")
```

```{r,fig.width=11,fig.height=4}
##Simulate detection 

#for each species loop through and create a replicate dataframe
obs<-array(dim=c(h_species,plant_species,months))

#Which months are plants in bloom?
#This is the phenology matrix
sampled<-replicate(plant_species,rbinom(months,1,phenology))
sampled[sampled==0]<-NA

for(x in 1:h_species){
  for (y in 1:plant_species){
    
    #True State
    ts<-true_interactions[x,y]
    
    #detections are function of phenology detection probability and occupancy
    det<-rbinom(months,ts,detection[x])
    
    #detections and phenology
    obs[x,y,]<-det *sampled[,y]
    }
  }

#plot observed state
obs.state<-melt(obs)
colnames(obs.state)<-c("Hummingbird","Plant","Month","Detections")

#turn NA's to 0
obs.state$Detections[is.na(obs.state$Detections)]<-0

obs.state$Hummingbird<-as.factor(obs.state$Hummingbird)
obs.state$Plant<-factor(obs.state$Plant,levels=1:plant_species)

ob1<-ggplot(obs.state[obs.state$Month==12,],aes(x=Hummingbird,y=Plant,fill=Detections)) + geom_tile() + scale_fill_continuous(low="white",high="Red",limits=c(0,max(mdat$True_State))) + ylab("Plant") + ggtitle("Example 1") + xlab("Hummingbird")

ob2<-ggplot(obs.state[obs.state$Month==18,],aes(x=Hummingbird,y=Plant,fill=Detections)) + geom_tile() + scale_fill_continuous(low="white",high="Red",limits=c(0,max(mdat$True_State))) + ylab("Plant") + ggtitle("Example 2") + xlab("Hummingbird")

grid.arrange(trueplot,ob1,ob2,nrow=1)
```

The left hand panel is the true state for each hummingbird plant combination. The middle and right hand panel are two realizations that might result from a month of sampling given incomplete detection and phenology.

```{r}
d<-merge(mdat,obs.state)
ggplot(d,aes(x=True_State,y=Detections,col=Month)) + geom_point() + theme_bw() + geom_abline() + coord_equal()
```

### Model Fitting
## Hierarcichal Occupancy Model Formulation

$$ Y_{i,j,k} \sim Binom(N_{i,j},detect_i)$$
$$N_{i,j} \sim Pois(\lambda_{i,j}) $$
$$log(\lambda_{i,j})<-\alpha_i + \beta_i * abs(Bill_i - Corolla_i) $$
$$detect_i \sim U(0,1)$$     

**Priors**

$$\alpha_i \sim N(intercept,\tau_{\alpha})$$
$$\beta_i \sim N(\gamma,\tau_{\beta})$$

**Hyperpriors**
$$gamma \sim N(0.001,0.001)$$
$$intercept \sim N(0.001,0.001)$$

$$\tau_{\alpha} \sim Gamma(0.001,0.001)$$
$$\tau_\beta \sim Gamma(0.001,0.001)$$

**Derived quantities**

$$\sigma_{int} = \frac{1}{\tau_{\alpha}}^2$$
$$\sigma_{slope} = \frac{1}{\tau_{\beta}}^2$$

## Poisson Estimate of trait-matching without detection bias or non-independence. 

Fit a model of observations without repect to their hierarcichal structure or with detection bias.

Observations between each bird and flower is modeled as a poisson with a lognormal link. 

$$Y{i,j} \sim Pois(\lambda)$$
$$log(\lambda) = \alpha + \beta * abs(Bill_i-Corolla_i)$$

```{r}
#Fit model
niave<-glm(data=d,Detections~Bill_Diff,family=poisson())
niavecoef<-niave$coefficients

pm<-predict(niave,type="response")
niave.pred<-data.frame(x=d$Bill_Diff,y=pm)
true.pred<-data.frame(x=d$Bill_Diff,y=d$True_State)
detect.pred<-data.frame(x=d$Bill_Diff,y=d$Detections)
pred.frame<-melt(list(Niave=niave.pred,Detections=detect.pred),id.var=c("x","y"))
ggplot(pred.frame,aes(x=x,y=y,col=L1)) + geom_point(data=pred.frame[pred.frame$L1=='Detections',],size=2.5) + theme_bw() + geom_line(data=pred.frame[pred.frame$L1=='Niave',]) + labs(col="",x="Bill Length- Corolla Length",y="Interactions") + scale_color_discrete(labels=c("Observations","Poisson GLM"))
```

##Hierarcichal Bayesian Model

```{r,eval=T}
setwd("C:/Users/Ben/Documents/Occupy/")
runs<-150000

#Source model
source("Bayesian/NMixture.R")

#print model
print.noquote(readLines("Bayesian/NMixture.R"))

#Input Data
Dat <- list(
  Y=obs,
  Birds=dim(obs)[1],
  Plants=dim(obs)[2],
  Months=dim(obs)[3],
  traitmatch=traitmatch)

#A blank Y matrix - all present
initY<-array(dim=c(Dat$Birds,Dat$Plants),data=max(obs,na.rm=T))

#Inits
InitStage <- function() {list(beta=rep(.5,Dat$Birds),alpha=rep(.5,Dat$Birds),detect=rep(.5,Dat$Birds),intercept=0,tau_alpha=0.1,tau_beta=0.1,N=initY,gamma=0)}

#Parameters to track
ParsStage <- c("detect","alpha","beta","intercept","sigma_int","sigma_slope","N","gamma","fit","fitnew")

#MCMC options
ni <- runs  # number of draws from the posterior
nt <- runs*.001   #thinning rate
nb <- 0 # number to discard for burn-in
nc <- 2  # number of chains

#Jags

m = jags(inits=InitStage,
         n.chains=nc,
         model.file="Bayesian/NMixture.jags",
         working.directory=getwd(),
         data=Dat,
         parameters.to.save=ParsStage,
         n.thin=nt,
         n.iter=ni,
         n.burnin=nb,
         DIC=T)
```

```{r,echo=FALSE,eval=F}
#Update if needed
recompile(m5)
add<-1000000
m5 <- update(m5,n.iter=add)
```

```{r}
#extract desired info from the models
parsO<-melt(m$BUGSoutput$sims.array)
colnames(parsO)<-c("Draw","Chain","parameter","estimate")
parsO<-parsO[!parsO$Draw %in% 1:(max(parsO$Draw)-3000/m$BUGSoutput$n.chains),]

#label species and plants
l<-levels(parsO$parameter)

#parameters to save
totrack<-m$parameters.to.save

sp_pl<-data.frame(parameter=l,str_match(l,pattern="(\\d+),(\\d+)")[,-1],par=str_extract(l,paste(totrack,collapse="|")))

colnames(sp_pl)<-c("parameter","species","plant","par")

sp_pl[is.na(sp_pl$species),c("species")]<-str_extract(sp_pl[is.na(sp_pl$species),"parameter"],"\\d+")

#merge levels
pars<-merge(parsO,sp_pl)

#take out deviance
pars<-pars[!pars$par %in% "deviance",]

```

###Assess Convergence

```{r,cache=FALSE,eval=TRUE,fig.width=11,fig.height=5}

###Chains
ggplot(pars[pars$par %in% c("detect","alpha","beta"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_grid(par~species,scale="free") + theme_bw() + labs(col="Chain") + ggtitle("Detection Probability")

```

```{r,fig.height=5,fig.width=11,eval=T}
ggplot(pars[pars$par %in% c("gamma","sigma_int","sigma_slope"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + theme_bw() + labs(col="Chain") + ggtitle("Trait-matching regression") + facet_wrap(~par,scales="free")
```

###Posteriors

```{r,cache=FALSE,fig.width=7,fig.height=5}
###Posterior Distributions
p<-ggplot(pars[pars$par %in% c("detect","alpha","beta"),],aes(x=estimate)) + geom_histogram() + ggtitle("Estimate of parameters") + facet_grid(species~par,scales="free") + theme_bw() + ggtitle("Species Posteriors")

#Add true values
tr<-melt(data.frame(species=1:length(detection),detect=detection,alpha=alpha,beta=beta),id.var='species')
colnames(tr)<-c("species","par","value")
psim<-p + geom_vline(data=tr,aes(xintercept=value),col='red',linetype='dashed',size=1)
ggsave("Figures/SimulationPosteriors.jpg",dpi=300,height=8,width=8)
```

```{r,cache=FALSE,eval=TRUE,fig.height=3,fig.width=10}

p<-ggplot(pars[pars$par %in% c("gamma","polygamma","intercept","sigma_int","sigma_slope","sigma_polyslope"),],aes(x=estimate)) + geom_histogram() + ggtitle("Hierarchical Posteriors") + facet_grid(~par,scale="free") + theme_bw() 

#Add true values
tr<-melt(list(gamma=gamma,intercept=intercept,sigma_int=sigma_intercept,sigma_slope=sigma_slope))

colnames(tr)<-c("value","par")

psim2<-p + geom_vline(data=tr,aes(xintercept=value),linetype='dashed',size=1,col="red")
ggsave("Figures/SimulationH.jpg",dpi=300,height=4,width=10)
```

**True values are given in the dashed lines.**

###Predicted Relationship 

Does accounting for non-independence and detection change our estimate of trait matching?

```{r,fig.height=4,fig.width=4}

castdf<-group_by(pars,Chain) %>% sample_n(2000)%>% select(par,estimate) %>% filter(par %in% c("gamma","intercept"))

castdf<-dcast(pars[pars$par %in% c("gamma","intercept"),], Chain + Draw~par,value.var="estimate")
castdf<-castdf[sample(1:nrow(castdf),1500),]

trajF<-function(alpha,beta,x){
  indat<-cbind(alpha,beta)
  
  #fit regression for each input estimate
  sampletraj<-apply(indat,1,function(s){
    data.frame(x=x,y=exp(s['alpha'] + s['beta'] *x))})
  sample_all<-rbind_all(sampletraj)
  
  #Compute CI intervals
  predy<-group_by(sample_all,x) %>% summarise(lower=quantile(y,0.025,na.rm=T),upper=quantile(y,0.975,na.rm=T),mean=mean(y,na.rm=T))
  }

#calculated predicted y
predy<-trajF(alpha=castdf$intercept,beta=castdf$gamma,x=as.numeric(traitmatch))

orig<-trajF(alpha=rnorm(2000,intercept,sigma_intercept),beta=rnorm(2000,gamma,sigma_slope),x=as.numeric(traitmatch))

niaveP<-trajF(alpha=rep(niave$coefficients[1],100),beta=rep(niave$coefficients[2],100),x=as.numeric(traitmatch))

#plot and compare to original data
psim3<-ggplot(data=predy,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.1)  + geom_line(aes(y=mean),size=1.,col="red") + theme_bw() + ylab("Interactions") + geom_line(data=orig,aes(x=x,y=mean),col='blue',linetype="dashed",size=1) + geom_line(data=niaveP,aes(x=x,y=mean),col="green") + xlab("Difference between Bill and Corolla Length") 

ggsave("Figures/SimulationResults.jpg",height=5,width=6,dpi=300)
```

Blue line is the true relationship. The red line is the posterior mean with confidible intervals in shaded grey for the proposed bayesian model. The poisson glm that does not account for detectability or non-independence is in green.


**Conclusion:** Accounting for detection and non-independence greatly increases the accuracy of the predicted state. The poisson glm underestimates the strength of trait matching among hummingbirds and their foodplants.

###Predicted Frequency

Validating the model

```{r,eval=T}

#any given state
predState<-group_by(pars,par) %>% filter(par=="N") %>% group_by(par,species,plant) %>% summarize(State=as.numeric(names(which.max(table(estimate)))))

predState$species<-as.factor(predState$species)
predState$plant<-factor(predState$plant,levels=1:plant_species)

predplot<-ggplot(predState,aes(x=species,y=plant,fill=State)) + geom_tile() + scale_fill_continuous(na.value="white",low="white",high="red",limits=c(0,max(obs.state$Detection))) + labs(x="Hummingbird",y="Plant",fill="Predicted State") + ggtitle("Predicted")

#compare true and pred states
tr<-melt(true_interactions)
colnames(tr)<-c("Hummingbird","Plant","True_State")

mdat<-merge(predState,tr,by.x=c("species","plant"),by.y=c("Hummingbird","Plant"))

ggplot(mdat,aes(y=State,x=True_State)) + geom_point(size=3) + geom_abline(linetype="dashed") + theme_bw() + xlab("True State") + ylab("Predicted State") + coord_equal()
```

###Posterior Check

Since I have simualted the data, it should fit as well as any random dataset drawn from the estimated parameters. An ideal fit would be posterior values sitting along the 1:1 line.

```{r}
#Define a function that computes new state for the model
trajState<-function(alpha,beta,x,observed){
  
  #Bind together
  fdat<-data.frame(alpha=alpha,beta=beta)
  
  #fit regression for each input estimate
  sampletraj<-list()
  for (s in 1:nrow(fdat)){
    a<-fdat$alpha[s]
    b<-fdat$beta[s]
    yp=exp(a + (b*x$value))
    
    #compute pred value
    state<-data.frame(x,State=rpois(length(yp),yp))
    
    #merge with observed state
    mstate<-merge(state,observed,by=c("Bird","Plant"))
    
    #Compute chisquared
    csq<-sum((mstate$Y-mstate$State)^2/(mstate$State+0.5))
    
    sampletraj[[s]]<-csq
    }
  
  #return as a vector
  return(unlist(sampletraj))
  }


#format the trait matrix
it<-melt(traitmatch)
colnames(it)<-c("Bird","Plant","value")

#list of observed data
orig<-obs.state
colnames(orig)<-c("Bird","Plant","Month","Y")

#create a replicated dataset from the parameters, assume a norma
niave_fit<-trajState(alpha=rep(niavecoef[1],100),beta=rep(niavecoef[2],100),x=it,observed=orig)

#create a replicated dataset from the parameters
yp=exp(niavecoef[1] + (niavecoef[2]*it$value))

pstate<-data.frame(it,Y=rpois(length(yp),yp))

niave_fitnew<-trajState(alpha=rep(niavecoef[1],1000),beta=rep(niavecoef[2],1000),x=it,observed=pstate)

discr_niave<-data.frame(fit=niave_fit,fitnew=niave_fitnew,model="Poisson GLM")
```

```{r,fig.height=4,fig.width=8}

fitstat<-pars[pars$par %in% c("fit","fitnew"),]
fitstat<-dcast(fitstat,Draw+Chain~par,value.var="estimate")
fitstat$model<-"Occupancy Model"

ddat<-rbind_all(list(fitstat,discr_niave))
#add 1:1 line

ymin<-log(round(min(c(ddat$fit,ddat$fitnew))))
ymax<-log(round(max(c(ddat$fit,ddat$fitnew))))
ab<-data.frame(x=ymin:ymax,y=ymin:ymax)
p<-ggplot(ddat,aes(x=log(fit),y=log(fitnew))) + geom_point(aes(col=model)) + theme_bw() + coord_equal()
psim4<-p  + labs(x="Log discrepancy of observed data",y="Log discrepancy of replicated data",col="Model") + geom_line(data=ab,aes(x=x,y=y)) + ggtitle("Simulations")

psim4
#Write Figures as panels
jpeg("Figures/SimulationPosteriors.jpg",height=12,width=12,units="in",res=300)
grid.arrange(psim,psim2,ncol=1,heights=c(3/4,1/4))
dev.off()

jpeg("Figures/SimPredict.jpg",height=6,width=7,units="in",res=300)
grid.arrange(psim3)
dev.off()
```

#Observed dataset

```{r}
###Read in data
#read in flower morphology data, comes from Nectar.R
droppath<-"C:/Users/Ben/Dropbox/"
fl.morph<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/FlowerMorphology.csv",sep=""))

#First row is empty
fl.morph<-fl.morph[-1,]

#Bring in Hummingbird Morphology Dataset, comes from
hum.morph<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/HummingbirdMorphology.csv",sep=""))

#Bring in Interaction Matrix
int<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/Network/HummingbirdInteractions.csv",sep=""),row.names=1)

#int$Month<-cut(int$Month,seq(0,12,2),labels=seq(1,11,2))

#Melt the interaction frame and match it with the traits
m.dat<-int[colnames(int) %in% c("ID","Video","Time","Hummingbird","Sex","TransectID","Transect_R","Iplant_Double","Pierce","DateP","Month","ele")]

m.dat$Year<-years(as.Date(m.dat$DateP))
#Fix spacing to match clades

#Which are matching
levels(m.dat$Hummingbird)[!levels(m.dat$Hummingbird) %in% hum.morph$English]

#This needs to be checked
#print(paste(levels(m.dat$Hummingbird)[!levels(m.dat$Hummingbird) %in% hum.morph$English],"not matched"))

#Number of bird species
h_species<-nlevels(m.dat$Hummingbird)

#Number of plant species
plant_species<-nlevels(m.dat$Iplant_Double)

#levels(m.dat$Hummingbird)[!levels(m.dat$Hummingbird) %in% hum.morph$English]<-c("Green-crowned Woodnymph")
m.datH<-merge(m.dat,hum.morph, by.x="Hummingbird",by.y="English")

#Merge to flowers
int.FLlevels<-levels(factor(m.datH$Iplant_Double))

#Which flowers are we missing info for?
missingTraits<-int.FLlevels[!int.FLlevels %in% fl.morph$X]

#print(paste("Missing Trait Information:",missingTraits))
m.datH<-merge(m.datH,fl.morph, by.x="Iplant_Double",by.y="X")

#Drop piercing events, since they don't represent correlation
m.datH<-m.datH[!m.datH$Pierce %in% c("y","Y"),]

p<-ggplot(m.datH[!is.na(m.datH$Month),],aes(x=factor(Total_Culmen),TotalCorolla,col=Hummingbird)) + geom_point() 
p<-p + geom_smooth(aes(group=1),method="lm") + facet_wrap(~Month) + theme_bw()

p<-ggplot(m.datH[!is.na(m.datH$Month),],aes(x=Total_Culmen,TotalCorolla,col=Month)) + geom_point() 
p<-p + geom_smooth(aes(group=Month),method="lm") + theme_bw() + scale_color_continuous(low="blue",high="red")

#Difference Between Corolla and Bill Length of interactions measured
m.datH$BD<-abs(m.datH$Total_Culmen-m.datH$TotalCorolla)
p<-ggplot(m.datH,aes(y=BD,x=Hummingbird)) + geom_boxplot(position="dodge")
p<-p + coord_flip()

```

```{r}
###Format data

#remove species with less than  10 observations
keep<-names(which(table(m.datH$Hummingbird) > 20))

m.datH<-droplevels(m.datH[m.datH$Hummingbird %in% keep,])

#observed traitmatching
traitmatchF<-abs(t(sapply(hum.morph$Bill,function(x){x-fl.morph$TotalCorolla})))

rownames(traitmatchF)<-hum.morph$English
colnames(traitmatchF)<-fl.morph$Group.1
```

```{r}
#match names
#Round to 2 decimals
#Convert to cm for winbugs, avoids numerical underflow
traitmatchT<-round(traitmatchF[rownames(traitmatchF) %in% m.datH$Hummingbird,colnames(traitmatchF) %in% m.datH$Iplant_Double],2)/10
```

```{r}
#Formatting indexes
m.datH$Bird<-as.numeric(factor(m.datH$Hummingbird,sort(unique(m.datH$Hummingbird))))
m.datH$Plant<-as.numeric(factor(m.datH$Iplant_Double,sort(unique(m.datH$Iplant_Double))))
m.datH$obs<-1

traitmatchT<-traitmatchT[sort(rownames(traitmatchT)),sort(colnames(traitmatchT))]

#Create an index to connect to species names
#remerge species levels
bindex<-data.frame(Index=1:length(rownames(traitmatchT)),Species=rownames(traitmatchT))

pindex<-data.frame(Index=1:length(colnames(traitmatchT)),Species=colnames(traitmatchT))

indat<-filter(m.datH,!is.na(DateP)) %>% mutate(Time=DateP) %>% group_by(Bird,Plant,Time) %>% summarize(Yobs=sum(obs)) 

indat$Time<-as.numeric(factor(indat$Time))

#add in non-detection 0's
#this involves some ugly data management, where we have to figure out which plants were sampled in which periods, and if it was sampled, the non-detections are 0 if it wasn't the non-detections are NA. then remove all the Na's.

indatlong<-acast(indat,Bird~Plant~Time,value.var="Yobs",fill=0)
```


###Elevation ranges

Create a binary variable whether each observation was in a low elevation or high elevation transect. We have some species that just occur at the top of the gradient, and are not present in the sampling window of flowers at the low elevation.

Start by a hand drawn table - then move to quantitative
```{r}

#1 is low elevation, #2 is high elevation, # 3 is both
elevH<-data.frame(Species=keep,Range=c(1,3,3,2,2,2,1,2,1,2,1,3,3,1))
#merge to names
elevH<-merge(bindex,elevH)

elevP<-data.frame(Species=colnames(traitmatchT),Range=c(2,2,2,3,3,1,1,2,2,3,3,3,3,2,1,3,1,1,1,2,2,2,3,3,3,1,2,2,3,2,3,3,1,3,1,2))
elevP<-merge(pindex,elevP)

```

```{r}
#Only non-detections are real 0's, the rest are NA's and are removed.
#Plants not surveyed in that time period
#Hummingbirds not present at that site

for(x in 1:dim(indatlong)[3]){
  #Remove non sampled plants 
  a<-indatlong[,,x]
  toNA<-as.numeric(names(which(apply(a,2,sum)==0)))
  pres<-as.numeric(names(which(!apply(a,2,sum)==0)))
  
  indatlong[,toNA,x]<-NA
  
  #match elevation if there were presences, slightly terse code.
  if(length(pres)>0){
    for (y in 1:length(pres)){
      #Plant range
      pr<-elevP[elevP$Index %in% pres[y],"Range"]
      if(!pr==3){
        helim<-elevH[!elevH$Range %in% c(pr,3),"Index"]
        #print(paste(x,"=",sum(indatlong[helim,pres[y],x])))
        indatlong[helim,pres[y],x]<-NA
        }
      }  
    }
  }

#melt and remove Na's
indat<-melt(indatlong)
indat<-indat[!is.na(indat$value),]

colnames(indat)<-c("Bird","Plant","Time","Yobs")
```

```{r,eval=T,results='hide'}

runs<-150000

#Source model
source("Bayesian/NMixtureRagged.R")

#print model
#print.noquote(readLines("Bayesian/NMixtureRagged.R"))


#ragged index data

#Input Data
Dat <- list(
  Y=indat$Yobs,
  Bird=indat$Bird,
  Plant=indat$Plant,
  Birds=length(unique(indat$Bird)),
  Plants=length(unique(indat$Plant)),
  Nobs=length(indat$Yobs),
  traitmatch=traitmatchT
  )


# # #Input Data 
#  Dat <- list(
#    Y=indatlong,
#    Birds=dim(indatlong)[1],
#    Plants=dim(indatlong)[2],
#    Months=dim(indatlong)[3],
#    traitmatch=traitmatchT
#    )

#A blank Y matrix - all present
initY<-matrix(nrow=Dat$Birds,ncol=Dat$Plants,data=max(Dat$Y,na.rm=T))

#Inits
InitStage <- function() {list(beta=rep(.5,Dat$Birds),alpha=rep(.5,Dat$Birds),detect=rep(.5,Dat$Birds),gamma=0,intercept=0,tau_alpha=0.1,tau_beta=0.1,N=initY)}

#Parameters to track
ParsStage <- c("detect","alpha","beta","intercept","gamma","sigma_int","sigma_slope","N","fit","fitnew")

#MCMC options
ni <- runs  # number of draws from the posterior
nt <- runs*.001   #thinning rate
nb <- 0 # number to discard for burn-in
nc <- 2  # number of chains

#Jags

m2 = jags(inits=InitStage,
          n.chains=nc,
          model.file="Bayesian/NMixtureRagged.jags",
          working.directory=getwd(),
          data=Dat,
          parameters.to.save=ParsStage,
          n.thin=nt,
          n.iter=ni,
          n.burnin=nb,
          DIC=T)
```


```{r}
#extract desired info from the models
parsO<-melt(m2$BUGSoutput$sims.array)
colnames(parsO)<-c("Draw","Chain","parameter","estimate")
parsO<-parsO[!parsO$Draw %in% 1:(max(parsO$Draw)-3000/m2$BUGSoutput$n.chains),]

#label species and plants
l<-levels(parsO$parameter)

#parameters to save
totrack<-m2$parameters.to.save

sp_pl<-data.frame(parameter=l,str_match(l,pattern="(\\d+),(\\d+)")[,-1],par=str_extract(l,paste(totrack,collapse="|")))

colnames(sp_pl)<-c("parameter","species","plant","par")

sp_pl[is.na(sp_pl$species),c("species")]<-str_extract(sp_pl[is.na(sp_pl$species),"parameter"],"\\d+")

#merge levels
pars<-merge(parsO,sp_pl)

#take out deviance
pars<-pars[!pars$par %in% "deviance",]

```

###Assess Convergence

```{r,cache=FALSE,eval=TRUE,fig.width=13,fig.height=5}

###Chains
ggplot(pars[pars$par %in% c("detect","alpha","beta"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_grid(par~species,scale="free") + theme_bw() + labs(col="Chain") + ggtitle("Detection Probability")

```

```{r,fig.height=5,fig.width=11,eval=T}
ggplot(pars[pars$par %in% c("gamma","sigma_int","sigma_slope"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + theme_bw() + labs(col="Chain") + ggtitle("Trait-matching regression") + facet_wrap(~par,scales="free")
```

###Posteriors

```{r,cache=FALSE,fig.width=11,fig.height=12}
###Posterior Distributions
ggplot(pars[pars$par %in% c("detect","alpha","beta"),],aes(x=estimate)) + geom_histogram() + ggtitle("Estimate of parameters") + facet_grid(species~par,scales="free") + theme_bw() + ggtitle("Detection Probability")

```

```{r,cache=FALSE,fig.width=11,fig.height=12}
#Detection figure
ggplot(pars[pars$par %in% c("detect"),],aes(x=as.factor(species),y=estimate)) + geom_violin(fill="grey10") + ggtitle("Estimate of parameters") + theme_bw() + ggtitle("Detection Probability") + coord_flip() + ylim(0,.3)

parsp<-merge(pars,bindex,by.x="species",by.y="Index")
ggplot(parsp[parsp$par %in% c("detect"),],aes(x=estimate)) + geom_histogram() + ggtitle("Posterior Distribution") + theme_bw() + facet_wrap(~Species,ncol=4) + xlab("Probability of Detection")
ggsave("Figures/DetectionProb.jpg",dpi=300,height=7,width=11)
```


```{r,cache=FALSE,eval=TRUE,fig.height=5,fig.width=13}

ggplot(pars[pars$par %in% c("gamma","intercept","sigma_int","sigma_slope"),],aes(x=estimate)) + geom_histogram() + ggtitle("Trait matching regression parameters") + facet_wrap(~par,scale="free",nrow=2) + theme_bw() 
```

###Species Predictions

```{r}
#orignal data to plot as ppints
odat<-merge(indat,bindex,by.x="Bird",by.y="Index")
odat<-merge(odat,pindex,by.x="Plant",by.y="Index")

#Append the traits
odatT<-melt(traitmatchT)
colnames(odatT)<-c("Bird","Plant","x")
colnames(odat)<-c("Plant","Bird","Time","Yobs","Bird_Species","Plant_Species")
odat<-merge(odat,odatT,by.x=c("Bird_Species","Plant_Species"),by.y=c("Bird","Plant"))
#rename the column to match
colnames(odat)[1]<-"L1"
```

```{r,fig.height=10,fig.width=11}

castdf<-dcast(pars[pars$par %in% c("beta","alpha","polybeta"),], species +Chain + Draw~par,value.var="estimate")

#Turn to 
castdf$species<-factor(castdf$species,levels=1:max(as.numeric(castdf$species)))

species.split<-split(castdf,castdf$species)

species.traj<-list()

trajF<-function(alpha,beta,x){
  fdat<-data.frame(alpha=alpha,beta=beta)
  
  #fit regression for each input estimate
  sampletraj<-list()
  for (s in 1:nrow(fdat)){
    a<-fdat$alpha[s]
    b<-fdat$beta[s]
    b2<-fdat$beta2[s]
    yp=exp(a + (b*x))
    
    #compute pred value
    sampletraj[[s]]<-data.frame(x=x,y=yp)
    }
  
  sample_all<-rbind_all(sampletraj)
  
  #Compute CI intervals
  predy<-group_by(sample_all,x) %>% summarise(lower=quantile(y,0.025,na.rm=T),upper=quantile(y,0.975,na.rm=T),median=mean(y,na.rm=T))
  return(predy)
  }

for(d in 1:length(species.split)){
  x<-species.split[[d]]
  species.traj[[d]]<-trajF(alpha=x$alpha,beta=x$beta,x=as.numeric(traitmatchT[d,]))
  }

names(species.traj)<-rownames(traitmatchT)

species.traj<-melt(species.traj,id.var=colnames(species.traj[[1]]))


#plot and compare to original data
ggplot(data=species.traj,aes(x=x,fill=L1)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.1)  + geom_line(aes(y=median),size=1.,col="red") + theme_bw() + ylab("Interactions") + xlab("Difference between Bill and Corolla Length") + facet_wrap(~L1,scales="free",ncol=3) + labs(fill="Species") + geom_point(data=odat,aes(x=x,y=Yobs))

ggsave("Figures/SpeciesPredictions.jpg",dpi=300,height=8,width=10)
```

###Overall predicted relationship 

Does accounting for non-independence and detection change our estimate of trait matching?

```{r,fig.height=4,fig.width=4}

castdf<-group_by(pars,Chain) %>% sample_n(2000)%>% select(par,estimate) %>% filter(par %in% c("gamma","intercept"))

castdf<-dcast(pars[pars$par %in% c("gamma","intercept"),], Chain + Draw~par,value.var="estimate")

#calculated predicted y
predy<-trajF(alpha=castdf$intercept,beta=castdf$gamma,x=round(as.numeric(traitmatchT),2))

#plot and compare to original data
ggplot(data=predy,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.1)  + geom_line(aes(y=median),size=1,col="red") + theme_bw() + ylab("Interactions") + xlab("Difference between Bill and Corolla Length") 

```

The red line is the posterior median with confidible intervals in shaded grey for the proposed bayesian model. The poisson glm that does not account for detectability or non-independence is in green.

**Conclusion:** Accounting for detection and non-independence greatly increases the accuracy of the predicted state. The poisson glm underestimates the strength of trait matching among hummingbirds and their foodplants.

###Poisson regression without detection bias

```{r,fig.height=6,fig.width=9}

niavedat<-as.data.frame(filter(m.datH,!is.na(Month)) %>% mutate(Time=paste(Month,Year)) %>% group_by(Bird,Plant,Time) %>% summarize(Yobs=sum(obs)))
niavedat$x<-NULL

for (g in 1:nrow(niavedat)){ 
  b<-niavedat[g,"Bird"]
  I<-niavedat[g,"Plant"]
  niavedat[g,"x"]<-traitmatchT[b,I]  
  }

niaveobs<-glm(data=niavedat,Yobs~poly(x,2,raw=T),family=poisson())
summary(niaveobs)
niavecoef<-niaveobs$coefficients
predyniave<-trajF(alpha=rep(niavecoef[1],100),beta=rep(niavecoef[2],100),x=as.numeric(traitmatchT))

#plot and compare to original data
p<-ggplot(data=predyniave,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.1)  + geom_line(aes(y=median),size=1.,col="blue") + theme_bw() + ylab("Interactions") + xlab("Difference between Bill and Corolla Length") + ggtitle("Without accounting for detection bias")

pboth<-ggplot(data=predyniave,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.1)  + geom_line(aes(y=median),size=1.,col="blue") + theme_bw() + ylab("Interactions") + xlab("Difference between Bill and Corolla Length") + geom_ribbon(data=predy,aes(ymin=lower,ymax=upper),alpha=0.1)  + geom_line(data=predy,aes(y=median),size=1.,col="red") + ggtitle("Accounting for detection bias")
grid.arrange(p,pboth)

ggsave(plot=pboth,"Figures/DetectionObs.jpg",dpi=300,height=4,width=5)
```

###Predicted Frequency

```{r,eval=T,fig.height=7,fig.width=12,eval=T}

#any given state
predState<-group_by(pars,par) %>% filter(par=="N") %>% group_by(par,species,plant) %>% summarize(State=as.numeric(names(which.max(table(estimate)))))

predState<-merge(predState,bindex,by.x="species",by.y="Index")

predState<-merge(predState,pindex,by.x="plant",by.y="Index")
colnames(predState)<-c("plant","species","par","State","Bird","Plant")

#order it to show nestedness.
b_ord<-group_by(predState,Bird) %>% summarize(I=sum(State)) %>% arrange(desc(I)) %>% select(Bird)

p_ord<-group_by(predState,Plant) %>% summarize(I=sum(State)) %>% arrange(I) %>% select(Plant)

predState$Bird<-factor(predState$Bird,levels=b_ord$Bird)
predState$Plant<-factor(predState$Plant,levels=p_ord$Plant)

predplot<-ggplot(predState,aes(x=Bird,y=Plant,fill=State)) + geom_tile() + scale_fill_continuous(na.value="white",low="white",high="red",limits=c(0,max(obs.state$Detection))) + labs(x="Hummingbird",y="Plant",fill="Predicted State") + ggtitle("Predicted")


orig<-group_by(indat,Bird,Plant) %>% summarize(Y=sum(Yobs))

finaldat<-merge(predState,orig,by.x=c("species","plant"),by.y=c("Bird","Plant"))
```

```{r}
#Define a function that computes new state for the model
trajState<-function(alpha,beta,x,observed){
  
  #Bind together
  fdat<-data.frame(alpha=alpha,beta=beta)
  
  #fit regression for each input estimate
  sampletraj<-list()
  for (s in 1:nrow(fdat)){
    a<-fdat$alpha[s]
    b<-fdat$beta[s]
    yp=exp(a + (b*x$value))
    
    #compute pred value
    state<-data.frame(x,State=rpois(length(yp),yp))
    
    #merge with observed state
    mstate<-merge(state,observed,by=c("Bird","Plant"))
    
    #Compute chisquared
    csq<-sum((mstate$Y-mstate$State)^2/(mstate$State+0.5))
    
    sampletraj[[s]]<-csq
    }
  
  #return as a vector
  return(unlist(sampletraj))
  }


#format the trait matrix
it<-melt(traitmatchT)
colnames(it)<-c("Bird","Plant","value")

#list of observed data
orig<-as.data.frame(group_by(m.datH,Hummingbird,Iplant_Double) %>% summarize(Y=sum(obs)))
colnames(orig)<-c("Bird","Plant","Y")

#create a replicated dataset from the parameters, assume a norma
confint(niave)
niave_fit<-trajState(alpha=rep(niavecoef[1],100),beta=rep(niavecoef[2],100),x=it,observed=orig)

#create a replicated dataset from the parameters
yp=exp(niavecoef[1] + (niavecoef[2]*it$value))

pstate<-data.frame(it,Y=rpois(length(yp),yp))

niave_fitnew<-trajState(alpha=rep(niavecoef[1],1000),beta=rep(niavecoef[2],1000),x=it,observed=pstate)

discr_niave<-data.frame(fit=niave_fit,fitnew=niave_fitnew,model="Poisson GLM")

```

###Discrepancy 

The goodness if of fit is a measured as chi-squared. The expected value for each month is the detection rate * the estimate intensity of interactions. The expected value is compared to the observed value of the actual data. In addition, a replicate dataset is generated from the posterior predicted intensity. Better fitting models will have lower discrepancy values and be 
Better fitting models are smaller values and closer to the 1:1 line. A perfect model would be 0 discrepancy. This is unrealsitic given the stochasticity in the sampling processes. Rather, its better to focus on relative discrepancy. 

```{r,fig.height=4,fig.width=8}
fitstat<-pars[pars$par %in% c("fit","fitnew"),]
fitstat<-dcast(fitstat,Draw+Chain~par,value.var="estimate")
fitstat$model<-"Occupancy Model"

ddat<-rbind_all(list(fitstat,discr_niave))
#add 1:1 line

ymin<-log(round(min(c(ddat$fit,ddat$fitnew))))
ymax<-log(round(max(c(ddat$fit,ddat$fitnew))))
ab<-data.frame(x=ymin:ymax,y=ymin:ymax)
p<-ggplot(ddat,aes(x=log(fit),y=log(fitnew))) + geom_point(aes(col=model)) + theme_bw() + coord_equal()
disc_obs<-p  + labs(x="Log discrepancy of observed data",y="Log discrepancy of replicated data",col="Model") + geom_line(data=ab,aes(x=x,y=y)) + ggtitle("Field Observations")
jpeg("Figures/DiscrepancyBoth.jpeg",res=300,height=7,width=6,units="in")
grid.arrange(psim4,disc_obs,nrow=2)
dev.off()
```

###Posterior p-value (worst term in the world.)

We are interested in the mean number of interactions per species.

```{r}
hist(ddat$fitnew)
hist(ddat$fit)
```

```{r}
#Detection table

dp<-group_by(pars[pars$par %in% c("detect"),],species) %>% summarise(mean=round(mean(estimate,na.rm=T),3)*100,lower=round(quantile(estimate,0.025,na.rm=T),3)*100,upper=round(quantile(estimate,0.975,na.rm=T),3)*100)

tab<-merge(dp,bindex,by.x="species",by.y="Index")[,-1]
write.csv(tab[,c(4,1,2,3)],"Figures/Table1.csv")
```


```{r}
save.image("Abundance.Rdata")
```

#Discussion

  Species are difficult to observe in the natural world. By allowing for observation error, we can better estimate the underlying mechanisms shaping ecological communities. In this paper, i compared poisson generalized linear models with a hierarcichal bayesian approach that accounted for detection bias and non-independence among species. Both the estimate of trait-matching, as well as the model fit increased using the hierarcichal approach. 
  By using the raw number of interactions among plants and pollinators, we assume that each species sampled evenly, and that each interaction was equally detectable. The automated cameras used to moniter the majority of these interactions turn on and off at dawn and dusk and provide a much longer duration of observation than is possible with a human observer(). Nevertheless, hummingbird-plant interactions were detected less than 20% of the sampling periods. This suggest that the problem of detection bias would be even more severe when the sampling window is even shorter. 
  The occupancy models presented here can be extended to include time-varying components (Royle), and covariates. For example, detection may decrease as plant height increases, since observations may be harder to confirm at greater distances.
  The underlyin
#Similiar work

* http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0069200
* http://onlinelibrary.wiley.com/doi/10.1111/j.2041-210x.2012.00249.x/abstract