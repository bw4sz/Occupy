---
title: "Accounting for detection bias increases trait-matching in a tropical plant-hummingbird network"
author: "Ben Weinstein - Stony Brook University"
date: "Monday, March 16, 2015"
output: html_document
---

```{r,warning=FALSE,message=FALSE,echo=FALSE,cache=FALSE}
library(reshape2)
library(chron)
library(ggplot2)
library(knitr)
library(R2jags)
library(dplyr)
library(stringr)
library(gridExtra)
library(boot)
library(picante)
library(bipartite)

opts_chunk$set(message=FALSE,warning=FALSE,fig.width=5,fig.height=4,echo=FALSE,cache=TRUE,cache.path = 'jp_cache/',fig.align='center',fig.path="figure/")

setwd("C:/Users/Ben/Documents/Occupy/")

set.seed(11)

```

#Introduction

Network ecology is a rapidly developing field that has reinvorgorated research on assemblage stability and complexity. By harnessing graph theory to represent ecological interactions, networks have informed evolution of specialization (), the importance of complex interactions () and predicting population decline due to shared partners(). While considerable work has focused on sampling and measuring network properties (Bluthgen, Bascompte, Jordano), much less work has focused on a central problem of network ecology: our ability to detect interactions is imperfect in time and space. This limitation can greatly bias results by assuming that non-detection is synomonous with non-interaction. 

  The importance of detection bias is widely appreciated in wildlife sciences(Mackenzie), but only rarely incoporated into evolutionary and theoretical ecology (xy, but see). However, the same issues that limit inference in determining population dyanimcs (), site selection(), and breeding ecology (), also undermine our ability to make inference about the evolution of ecological systems. We can harness the tools developed in widlife sciences to strengthen the realism of network observations. The chief improvement is to incorporate detection bias directly into our estimates of species interactions using occupancy models. In occupancy modeling, repeated surveys are used to estimate the probability of detection given a species probability of occurrence. The probability of occurrence is a latent variable which cannot be directly infered from the data. If we did not see a species at a site, was it absent or undetected? By analogy, if we failed to find a pollinator interacting with a plant, is it due to detection or is it a 'forbidden link' due mismatch in species  or functional morphology? The goal of this paper is to use a large dataset on plant-hummingbird interactions from a tropical montane forest to evaluate the effect of imperfect detection on estimating species interactions. 
  
  In the tropical Andes, up to thirty hummingbirds can co-occur in local assemblages. Hummingbirds are largley nectarivorous and have diversity of bill morphologies. Species with longer and more curved bills tend to visit flowers with longer and more curved flower corollas (Temeles,Magliansi). This traitmatching may help promote community stability through niche partitioning(Weinstein). To test the strength of the observed trait-matching, studies use the number of visits to a flower as interaction strength among network levels. While randomization approaches have been purposed to test for the strength of specialization (Bluthgen), extremely few studies have evaluated the detection rates of different interactions, and included these coefficients into estimates of trait-matching. 
  
  To estimate detection, observers need to return multiple times within a sampling window. Human observation is expensive, and it is often prohibitively expensive to design studies to accomodate occupancy modeling using human observations. However, the hummingbird dataset in this paper was collected by using time-lapse cameras which turn on at dawn and dusk automatically. In addition, more traditional hummingbird transects were used to survey flower visitation. Combining these sampling types, we have a very large network with over 3,000 interactions (Weinstein XXXX). By embracing automated monitering of plant-animal interactions, we can determine and account for detection bias. 

  To illustrate the utility of this approach, I begin with simulations to demonstrate the importance for accounting for detection bias, and to demonstrate the flexibility and accuracy of such heirarcichal models. In addition, occupancy models are complex and require fitting a number of latent variables. Before I fit models to an observed dataset, it is crucial to simulate data with known results to show that the models perform as expected. In this analysis, i will use a Bayesian Hierarcichal framework, where we are ultimately interested in estimating three quantities, the number of interactions between a hummingbird species and plant species, the probability of detection, and the frequency (or 'intensity') of the interaction. To do this, i will first consider the observation model.

###Observation Model

The observation model describes the sampling process that yields our data. These are the actual number of observations observed by reviewing the cameras and transects. We know there is some true, but unknown intensity of interactions among hummingbird i and plant j, and that we are likely to see some, but not all, interactions. We assume that we are equally likely to see any one interaction, so the number of detections of hummingbird i on plant j in month k is modeled as as a binomial trail where the probability of detecting a species is a species-specific parameter *detect* with *N* trials. 

$$ Y_{i,j,k} \sim Binom(N_{i,j},detect_i)$$

###Process Model

To estimate the parameter *N*, which is the unknown true rate of interactions, we need a process model. The process model is the mechansism that generates interactions among plants and pollinators in a given time period.In our analysis, our sampling period is one day. We can model the daily intensity as a poisson distribution with $\lambda_{i,j}$. The hypothesis is that $\lambda$ should increase with greater matching between plant corolla and hummingbird bill lengths. Since lambda is a intensity of interactions, it must be a positive number. We there model lambda as a function of linear predictors with a log link function. In our simulation, we give equal penalty for having a bill too long, or too short for a given corolla. The entire process model can be written as:

$$N_{i,j} \sim Pois(\lambda_{i,j}) $$
$$log(\lambda_{i,j})<-\alpha_i + \beta_i * (Bill_i - Corolla_i) + \beta_{i2} *(Bill_i - Corolla_i)^2 $$

###Hierarcichal structure

Each $Y_{i,j,k}$ interaction is not independent. Due to foraging behavior (Sandlin), physiological requirements (Powers), or difference in available resources (Weinstein), different species may respond differently to differences in bill or corolla lengths. However, our goal is to study any one species, but to capture the overall effect of trait-matching on hummingbirds and plants. We therefore use a hierarcichal model to account both for within species variability, but to estimate a group-level mean (Bolker). Similiarly, due to differences in abundance, behavior, and foraging strategy (Colwell), some hummingbird species will be more detectable than others. We allow a fixed species level effect of hummingbird species on detection probability. Each of these levels could be fit to covariates as well depending on vegetation height, observer distance and quality (Royle).

#Similiar work

  * http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0069200
  * http://onlinelibrary.wiley.com/doi/10.1111/j.2041-210x.2012.00249.x/abstract


**In this study we want to estimate three quantitites:**

$$ \psi_{i,j} = \text{The probability a flower is visited by a hummigbird}  $$

$$ p_{i,j} = \text{The probability of detecting a bird-flower interaction given that it occurs} $$

#Methods
##Simulation

I first create data with constant detection for each hummingbird speices, and the interaction frequency is a function of a species hierarcichal model and corolla similarity. There is uneven sampling among species.

### Parameters

  * 7 hummingbird species
    * Range of hummingbird bill sizes (mm) ~ Pois(10)
  * Ten plants
    * Range of corolla sizes (mm) ~ Pois(20)
  * Mean frequeny ($\lambda$) for each hummingbird is drawn from U(0,10)  
    * For each plant the occupancy is N($\lambda$,0.2) (truncated 0-1) 
    * Trait matching (minimizing Bill-Corolla difference) is drawn from a hierarcichal distribution
    $$log(\lambda)<-\alpha_i + \beta_i *traitmatch + \beta_{2i} * traitmatch^2$$
      $$\alpha=N(3,.01)$$
      $$\beta = N(-.01,.001)$$
      $$\beta_2=N(.-.05,.001)$$
      
  * Imperfect detection 
    * $p_i = U(0,1)$ 
  * 24 month replicates
  * Phenology = .5 (plants are in flower/present .5 of surveys)

************

**View simulated strength and form of trait matching **

```{r,fig.height=5,fig.width=8}
#Number of hummingbird species
h_species=8
plant_species=20
months=24
detection=runif(h_species,0,1)
phenology=.5

#Bill sizes
Bill<-rpois(h_species,10)

#Corolla sizes
Corolla<-rpois(plant_species,15)

#Subtract both
traitmatch<-sapply(Corolla,function(x) x - Bill)

#regression slope
intercept<-3
gamma<- -0.01
polygamma<- -0.05
sigma_slope<- 0.01
sigma_slope2<- 0.01
sigma_intercept<- 0.01

beta<-rnorm(h_species,gamma,sigma_slope)
beta2<-rnorm(h_species,polygamma,sigma_slope2)
alpha<-rnorm(h_species,intercept,sigma_intercept)

#fit regression
lambda<-exp(alpha + beta * traitmatch + beta2*traitmatch^2)

true_interactions<-sapply(lambda,function(x){rpois(1,x)})

#convert to matrix
true_interactions<-matrix(nrow=h_species,ncol=plant_species,data=true_interactions)

#combine and melt into a single dataframe
mdat<-dcast(melt(list(y=true_interactions,x=traitmatch)),Var1+Var2~L1)

ggplot(mdat,aes(x=x,y=y,col=Var1)) + geom_point() + geom_smooth(method="glm",family="poisson",formula=y~poly(x,2)) + theme_bw() + labs(x="Bill-Corolla Difference",y="Occurrences","Hummingbird") + ggtitle("Correlation in Simulated Data")

```

### True Interaction Matrix

```{r,fig.width=12}
#Reshape into a nicer format
colnames(mdat)<-c("Hummingbird","Plant","Bill_Diff","True_State")

trueplot<-ggplot(mdat,aes(y=as.factor(Plant),x=as.factor(Hummingbird),fill=True_State)) + geom_tile() + labs(x="Hummingbird",y="Plant",fill="Presence") + ggtitle("True State ") + scale_fill_continuous(low="white",high="red","Occurrences")
```

```{r,fig.width=11,fig.height=4}
##Simulate detection 

#for each species loop through and create a replicate dataframe
obs<-array(dim=c(h_species,plant_species,months))

#Which months are plants in bloom?
#This is the phenology matrix
sampled<-replicate(plant_species,rbinom(months,1,phenology))
sampled[sampled==0]<-NA

for(x in 1:h_species){
  for (y in 1:plant_species){
    
    #True State
    ts<-true_interactions[x,y]
    
    #detections are function of phenology detection probability and occupancy
    det<-rbinom(months,ts,detection[x])
    
    #detections and phenology
    obs[x,y,]<-det *sampled[,y]
    }
  }

#plot observed state
obs.state<-melt(obs)
colnames(obs.state)<-c("Hummingbird","Plant","Month","Detections")

#turn NA's to 0
obs.state$Detections[is.na(obs.state$Detections)]<-0

obs.state$Hummingbird<-as.factor(obs.state$Hummingbird)
obs.state$Plant<-factor(obs.state$Plant,levels=1:plant_species)

ob1<-ggplot(obs.state[obs.state$Month==12,],aes(x=Hummingbird,y=Plant,fill=Detections)) + geom_tile() + scale_fill_continuous(low="white",high="Red",limits=c(0,max(mdat$True_State))) + ylab("Plant") + ggtitle("Example 1") + xlab("Hummingbird")

ob2<-ggplot(obs.state[obs.state$Month==18,],aes(x=Hummingbird,y=Plant,fill=Detections)) + geom_tile() + scale_fill_continuous(low="white",high="Red",limits=c(0,max(mdat$True_State))) + ylab("Plant") + ggtitle("Example 2") + xlab("Hummingbird")

grid.arrange(trueplot,ob1,ob2,nrow=1)
```

The left hand panel is the true state for each hummingbird plant combination. The middle and right hand panel are two realizations that might result from a month of sampling given incomplete detection and phenology.

```{r}
d<-merge(mdat,obs.state)
ggplot(d,aes(x=True_State,y=Detections,col=Month)) + geom_point() + theme_bw() + geom_abline() + coord_equal()
```

#Niave Estimate of Trait-Matching

Fit a model of observations without repect to their hierarcichal structure or with detection bias.

Observations between each bird and flower is modeled as a poisson with a lognormal link. 

$$Y{i,j} \sim Pois(\lambda)$$
$$log(\lambda) = \alpha + \beta * (Bill_i-Corolla_i)$$

```{r}
#Fit model
niave<-glm(data=d,Detections~poly(Bill_Diff,2,raw=T)  ,family=poisson())
pm<-predict(niave,type="response")
niave.pred<-data.frame(x=d$Bill_Diff,y=pm)
true.pred<-data.frame(x=d$Bill_Diff,y=d$True_State)
detect.pred<-data.frame(x=d$Bill_Diff,y=d$Detections)
pred.frame<-melt(list(Niave=niave.pred,Detections=detect.pred),id.var=c("x","y"))
ggplot(pred.frame,aes(x=x,y=y,col=L1)) + geom_point(data=pred.frame[pred.frame$L1=='Detections',],size=2.5) + theme_bw() + geom_line(data=pred.frame[pred.frame$L1=='Niave',]) + labs(col="",x="Bill Length- Corolla Length",y="Interactions") + scale_color_discrete(labels=c("Observations","Poisson GLM"))
```

## Hierarcichal Occupancy Model Formulation

###Observation

The number of observations observed between $hummingbird_i$ and $flower_j$ in $survey_k$ is a binomial trail where the probability of detecting a species is a species specific parameter detect with N trials.

$$ Y_{i,j,k} \sim Binom(N_{i,j},detect_i)$$

###Process

N is the underlying frequency of interactions among each pair of plants and hummingbirds drawn from a poisson with $\lambda_{i,j}$, which is modeled as a lognormal link.

$$N_{i,j} \sim Pois(\lambda_{i,j}) $$
$$log(\lambda_{i,j})<-\alpha_i + \beta_i * (Bill_i - Corolla_i) + \beta_{i2} *(Bill_i - Corolla_i)^2 $$

###Fixed species level priors

$$detect_i \sim U(0,1)$$ 

**Detection is set for each bird species** This could account for differing abundances or foraging intensity.
    
###Hierarchical Priors
  
Species level priors for the strength of trait-matching is drawn from a normal distribution of all hummingirds.

$$\alpha_i \sim N(intercept,\tau_{\alpha})$$

$$\beta_i \sim N(\gamma,\tau_{\beta})$$

$$\beta_{i2} \sim N(\gamma,\tau_{polybeta})$$    
    
**Hyperpriors**

$$gamma \sim N(0.001,0.001)$$
$$polygamma \sim N(0.001,0.001)$$
$$intercept \sim N(0.001,0.001)$$
  
$$\tau_{\alpha} \sim Gamma(0.001,0.001)$$
$$\tau_\beta \sim Gamma(0.001,0.001)$$
$$\tau_{polybeta} \sim Gamma(0.001,0.001)$$

**Derived quantities**

$$\sigma_{int} = \frac{1}{\tau_{\alpha}}^2$$
$$\sigma_{slope} = \frac{1}{\tau_{\beta}}^2$$
$$\sigma_{polyslope} = \frac{1}{\tau_{poly\beta}}^2$$

```{r,eval=T}
setwd("C:/Users/Ben/Documents/Occupy/")
runs<-50000

#Source model
source("Bayesian/NMixture.R")
 
#print model
print.noquote(readLines("Bayesian/NMixture.R"))

#Input Data
Dat <- list(
  Y=obs,
  Birds=dim(obs)[1],
  Plants=dim(obs)[2],
  Months=dim(obs)[3],
  traitmatch=traitmatch)

#A blank Y matrix - all present
initY<-array(dim=c(Dat$Birds,Dat$Plants),data=max(obs,na.rm=T))

#Inits
InitStage <- function() {list(beta=rep(.5,Dat$Birds),alpha=rep(.5,Dat$Birds),detect=rep(.5,Dat$Birds),gamma=0,intercept=0,tau_alpha=0.1,tau_beta=0.1,N=initY)}

#Parameters to track
ParsStage <- c("detect","alpha","beta","intercept","gamma","sigma_int","sigma_slope","N","polybeta","sigma_polyslope","polygamma")

#MCMC options
ni <- runs  # number of draws from the posterior
nt <- runs*.001   #thinning rate
nb <- 0 # number to discard for burn-in
nc <- 2  # number of chains

#Jags

m = jags(inits=InitStage,
         n.chains=nc,
         model.file="Bayesian/NMixture.jags",
         working.directory=getwd(),
         data=Dat,
         parameters.to.save=ParsStage,
         n.thin=nt,
         n.iter=ni,
         n.burnin=nb,
         DIC=T)
```

```{r,echo=FALSE,eval=F}
#Update if needed
recompile(m5)
add<-1000000
m5 <- update(m5,n.iter=add)
```

```{r}
  #extract desired info from the models
  parsO<-melt(m$BUGSoutput$sims.array)
  colnames(parsO)<-c("Draw","Chain","parameter","estimate")
  parsO<-parsO[!parsO$Draw %in% 1:(max(parsO$Draw)-3000/m$BUGSoutput$n.chains),]
  
  #label species and plants
  l<-levels(parsO$parameter)

  #parameters to save
  totrack<-m$parameters.to.save
  
  sp_pl<-data.frame(parameter=l,str_match(l,pattern="(\\d+),(\\d+)")[,-1],par=str_extract(l,paste(totrack,collapse="|")))
  
  colnames(sp_pl)<-c("parameter","species","plant","par")

  sp_pl[is.na(sp_pl$species),c("species")]<-str_extract(sp_pl[is.na(sp_pl$species),"parameter"],"\\d+")

  #merge levels
  pars<-merge(parsO,sp_pl)
  
  #take out deviance
  pars<-pars[!pars$par %in% "deviance",]
  
```

###Assess Convergence

```{r,cache=FALSE,eval=TRUE,fig.width=11,fig.height=5}

###Chains
ggplot(pars[pars$par %in% c("detect","alpha","beta","polybeta"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_grid(par~species,scale="free") + theme_bw() + labs(col="Chain") + ggtitle("Detection Probability")

```

```{r,fig.height=5,fig.width=11,eval=T}
ggplot(pars[pars$par %in% c("gamma","polygamma","sigma_int","sigma_slope","sigma_polyslope"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + theme_bw() + labs(col="Chain") + ggtitle("Trait-matching regression") + facet_wrap(~par,scales="free")
```

###Posteriors

```{r,cache=FALSE,fig.width=7,fig.height=5}
###Posterior Distributions
p<-ggplot(pars[pars$par %in% c("detect","alpha","beta","polybeta"),],aes(x=estimate)) + geom_histogram() + ggtitle("Estimate of parameters") + facet_grid(species~par,scales="free") + theme_bw() + ggtitle("Detection Probability")

#Add true values
tr<-melt(data.frame(species=1:length(detection),detect=detection,alpha=alpha,beta=beta,polybeta=beta2),id.var='species')
colnames(tr)<-c("species","par","value")
p + geom_vline(data=tr,aes(xintercept=value),col='red',linetype='dashed',size=1)
```

```{r,cache=FALSE,eval=TRUE,fig.height=3,fig.width=10}

p<-ggplot(pars[pars$par %in% c("gamma","polygamma","intercept","sigma_int","sigma_slope","sigma_polyslope"),],aes(x=estimate)) + geom_histogram() + ggtitle("Trait matching regression parameters") + facet_grid(~par,scale="free") + theme_bw() 

#Add true values
tr<-melt(list(gamma=gamma,intercept=intercept,sigma_int=sigma_intercept,sigma_slope=sigma_slope,sigma_polyslope=sigma_slope2,polygamma=polygamma))

colnames(tr)<-c("value","par")

p + geom_vline(data=tr,aes(xintercept=value),linetype='dashed',size=1,col="red")
```

**True values are given in the dashed lines.**

###Predicted Relationship 

Does accounting for non-independence and detection change our estimate of trait matching?

```{r,fig.height=4,fig.width=4}
 
castdf<-group_by(pars,Chain) %>% sample_n(2000)%>% select(par,estimate) %>% filter(par %in% c("polygamma","gamma","intercept"))

castdf<-dcast(pars[pars$par %in% c("gamma","intercept","polygamma"),], Chain + Draw~par,value.var="estimate")
castdf<-castdf[sample(1:nrow(castdf),1500),]

trajF<-function(alpha,beta,beta2,x){
  indat<-cbind(alpha,beta,beta2)
  
  #fit regression for each input estimate
  sampletraj<-apply(indat,1,function(s){
    data.frame(x=x,y=exp(s['alpha'] + s['beta'] *x + s['beta2']*x^2))})
  sample_all<-rbind_all(sampletraj)
  
  #Compute CI intervals
  predy<-group_by(sample_all,x) %>% summarise(lower=quantile(y,0.025,na.rm=T),upper=quantile(y,0.975,na.rm=T),mean=mean(y,na.rm=T))
  }

#calculated predicted y
predy<-trajF(alpha=castdf$intercept,beta=castdf$gamma,beta2=castdf$polygamma,x=as.numeric(traitmatch))

orig<-trajF(alpha=rnorm(2000,intercept,sigma_intercept),beta=rnorm(2000,gamma,sigma_slope),beta2=rnorm(2000,polygamma,sigma_slope2),x=as.numeric(traitmatch))

niaveP<-trajF(alpha=rep(niave$coefficients[1],100),beta=rep(niave$coefficients[2],100),beta2=rep(niave$coefficients[3],100),x=as.numeric(traitmatch))

#plot and compare to original data
ggplot(data=predy,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.1)  + geom_line(aes(y=mean),size=1.,col="red") + theme_bw() + ylab("Interactions") + geom_line(data=orig,aes(x=x,y=mean),col='blue',linetype="dashed",size=1) + geom_line(data=niaveP,aes(x=x,y=mean),col="green") + xlab("Difference between Bill and Corolla Length") 
```

Blue line is the true relationship. The red line is the posterior mean with confidible intervals in shaded grey for the proposed bayesian model. The poisson glm that does not account for detectability or non-independence is in green.


**Conclusion:** Accounting for detection and non-independence greatly increases the accuracy of the predicted state. The poisson glm underestimates the strength of trait matching among hummingbirds and their foodplants.

###Predicted Frequency

Validating the model.

```{r,eval=T}

#any given state
predState<-group_by(pars,par) %>% filter(par=="N") %>% group_by(par,species,plant) %>% summarize(State=as.numeric(names(which.max(table(estimate)))))

predState$species<-as.factor(predState$species)
predState$plant<-factor(predState$plant,levels=1:plant_species)

predplot<-ggplot(predState,aes(x=species,y=plant,fill=State)) + geom_tile() + scale_fill_continuous(na.value="white",low="white",high="red",limits=c(0,max(obs.state$Detection))) + labs(x="Hummingbird",y="Plant",fill="Predicted State") + ggtitle("Predicted")

#compare true and pred states
tr<-melt(true_interactions)
colnames(tr)<-c("Hummingbird","Plant","True_State")

mdat<-merge(predState,tr,by.x=c("species","plant"),by.y=c("Hummingbird","Plant"))

ggplot(mdat,aes(y=State,x=True_State)) + geom_point(size=3) + geom_abline(linetype="dashed") + theme_bw() + xlab("True State") + ylab("Predicted State") + coord_equal()
```

***********

#Observed dataset

###Read in data
```{r}
#read in flower morphology data, comes from Nectar.R
droppath<-"C:/Users/Ben/Dropbox/"
fl.morph<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/FlowerMorphology.csv",sep=""))

#First row is empty
fl.morph<-fl.morph[-1,]

#Bring in Hummingbird Morphology Dataset, comes from
hum.morph<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/HummingbirdMorphology.csv",sep=""))

#Bring in Interaction Matrix
int<-read.csv(paste(droppath,"Thesis/Maquipucuna_SantaLucia/Results/Network/HummingbirdInteractions.csv",sep=""),row.names=1)

#int$Month<-cut(int$Month,seq(0,12,2),labels=seq(1,11,2))

#Melt the interaction frame and match it with the traits
m.dat<-int[colnames(int) %in% c("ID","Video","Time","Hummingbird","Sex","TransectID","Transect_R","Iplant_Double","Pierce","DateP","Month","ele")]

m.dat$Year<-years(as.Date(m.dat$DateP))
#Fix spacing to match clades

#Which are matching
levels(m.dat$Hummingbird)[!levels(m.dat$Hummingbird) %in% hum.morph$English]

#This needs to be checked
#print(paste(levels(m.dat$Hummingbird)[!levels(m.dat$Hummingbird) %in% hum.morph$English],"not matched"))

#Number of bird species
h_species<-nlevels(m.dat$Hummingbird)

#Number of plant species
plant_species<-nlevels(m.dat$Iplant_Double)

#levels(m.dat$Hummingbird)[!levels(m.dat$Hummingbird) %in% hum.morph$English]<-c("Green-crowned Woodnymph")
m.datH<-merge(m.dat,hum.morph, by.x="Hummingbird",by.y="English")

#Merge to flowers
int.FLlevels<-levels(factor(m.datH$Iplant_Double))

#Which flowers are we missing info for?
missingTraits<-int.FLlevels[!int.FLlevels %in% fl.morph$X]

#print(paste("Missing Trait Information:",missingTraits))
m.datH<-merge(m.datH,fl.morph, by.x="Iplant_Double",by.y="X")

#Drop piercing events, since they don't represent correlation
m.datH<-m.datH[!m.datH$Pierce %in% c("y","Y"),]

p<-ggplot(m.datH[!is.na(m.datH$Month),],aes(x=factor(Total_Culmen),TotalCorolla,col=Hummingbird)) + geom_point() 
p<-p + geom_smooth(aes(group=1),method="lm") + facet_wrap(~Month) + theme_bw()

p<-ggplot(m.datH[!is.na(m.datH$Month),],aes(x=Total_Culmen,TotalCorolla,col=Month)) + geom_point() 
p<-p + geom_smooth(aes(group=Month),method="lm") + theme_bw() + scale_color_continuous(low="blue",high="red")

#Difference Between Corolla and Bill Length of interactions measured
m.datH$BD<-m.datH$Total_Culmen-m.datH$TotalCorolla
p<-ggplot(m.datH,aes(y=BD,x=Hummingbird)) + geom_boxplot(position="dodge")
p<-p + coord_flip()

```

###Format data
```{r}

#remove species with less than  20 observations
keep<-names(which(table(m.datH$Hummingbird) > 20))

m.datH<-droplevels(m.datH[m.datH$Hummingbird %in% keep,])

#observed traitmatching
traitmatchF<-t(sapply(hum.morph$Bill,function(x){x-fl.morph$TotalCorolla}))

rownames(traitmatchF)<-hum.morph$English
colnames(traitmatchF)<-fl.morph$Group.1
```

```{r}
#make the names
#ROund to 2 decimals
#Convert to cm for winbugs, avoids numerical underflow
traitmatchT<-round(traitmatchF[rownames(traitmatchF) %in% m.datH$Hummingbird,colnames(traitmatchF) %in% m.datH$Iplant_Double],2)/10
```

```{r}
#Formatting indexes
m.datH$Bird<-as.numeric(factor(m.datH$Hummingbird,sort(unique(m.datH$Hummingbird))))
m.datH$Plant<-as.numeric(factor(m.datH$Iplant_Double,sort(unique(m.datH$Iplant_Double))))
m.datH$obs<-1

traitmatchT<-traitmatchT[sort(rownames(traitmatchT)),sort(colnames(traitmatchT))]

indat<-filter(m.datH,!is.na(DateP)) %>% mutate(Time=DateP) %>% group_by(Bird,Plant,Time) %>% summarize(Yobs=sum(obs)) 

indat$Time<-as.numeric(factor(indat$Time))

#add in non-detection 0's
#this involves some ugly data management, where we have to figure out which plants were sampled in which periods, and if it was sampled, the non-detections are 0 if it wasn't the non-detections are NA. then remove all the Na's.

indatlong<-acast(indat,Bird~Plant~Time,value.var="Yobs",fill=0)

#Get rid of plants not surveyed in that time period
for(x in 1:dim(indatlong)[3]){
  a<-indatlong[,,x]
  toNA<-as.numeric(names(which(apply(a,2,sum)==0)))
  indatlong[,toNA,x]<-NA
}

#melt and remove Na's
indat<-melt(indatlong)
indat<-indat[!is.na(indat$value),]

colnames(indat)<-c("Bird","Plant","Time","Yobs")
```

```{r,eval=T}

runs<-2000

#Source model
source("Bayesian/NMixture.R")
 
#print model
print.noquote(readLines("Bayesian/NMixture.R"))


#ragged index data

# #Input Data
# Dat <- list(
#   Y=indat$Yobs,
#   Bird=indat$Bird,
#   Plant=indat$Plant,
#   Birds=length(unique(indat$Bird)),
#   Plants=length(unique(indat$Plant)),
#   Nobs=length(indat$Yobs),
#   traitmatch=traitmatchT
#   )


# #Input Data
 Dat <- list(
   Y=indatlong,
   Birds=dim(indatlong)[1],
   Plants=dim(indatlong)[2],
   Months=dim(indatlong)[3],
   traitmatch=traitmatchT
   )

#A blank Y matrix - all present
initY<-matrix(nrow=Dat$Birds,ncol=Dat$Plants,data=max(Dat$Y,na.rm=T))

#Inits
InitStage <- function() {list(beta=rep(.5,Dat$Birds),alpha=rep(.5,Dat$Birds),detect=rep(.5,Dat$Birds),gamma=0,intercept=0,tau_alpha=0.1,tau_beta=0.1,N=initY)}

#Parameters to track
ParsStage <- c("detect","alpha","beta","intercept","gamma","sigma_int","sigma_slope","N","polybeta","sigma_polyslope","polygamma","fit","fitnew")

#MCMC options
ni <- runs  # number of draws from the posterior
nt <- runs*.001   #thinning rate
nb <- 0 # number to discard for burn-in
nc <- 2  # number of chains

#Jags

m2 = jags(inits=InitStage,
         n.chains=nc,
         model.file="Bayesian/NMixture.jags",
         working.directory=getwd(),
         data=Dat,
         parameters.to.save=ParsStage,
         n.thin=nt,
         n.iter=ni,
         n.burnin=nb,
         DIC=T)
```


```{r}
  #extract desired info from the models
  parsO<-melt(m2$BUGSoutput$sims.array)
  colnames(parsO)<-c("Draw","Chain","parameter","estimate")
  parsO<-parsO[!parsO$Draw %in% 1:(max(parsO$Draw)-3000/m2$BUGSoutput$n.chains),]
  
  #label species and plants
  l<-levels(parsO$parameter)

  #parameters to save
  totrack<-m2$parameters.to.save
  
  sp_pl<-data.frame(parameter=l,str_match(l,pattern="(\\d+),(\\d+)")[,-1],par=str_extract(l,paste(totrack,collapse="|")))
  
  colnames(sp_pl)<-c("parameter","species","plant","par")

  sp_pl[is.na(sp_pl$species),c("species")]<-str_extract(sp_pl[is.na(sp_pl$species),"parameter"],"\\d+")

  #merge levels
  pars<-merge(parsO,sp_pl)
  
  #take out deviance
  pars<-pars[!pars$par %in% "deviance",]
  
```

###Assess Convergence

```{r,cache=FALSE,eval=TRUE,fig.width=13,fig.height=5}

###Chains
ggplot(pars[pars$par %in% c("detect","alpha","beta","polybeta"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_grid(par~species,scale="free") + theme_bw() + labs(col="Chain") + ggtitle("Detection Probability")

```

```{r,fig.height=5,fig.width=11,eval=T}
ggplot(pars[pars$par %in% c("gamma","polygamma","sigma_int","sigma_slope","sigma_polyslope"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + theme_bw() + labs(col="Chain") + ggtitle("Trait-matching regression") + facet_wrap(~par,scales="free")
```

###Posteriors

```{r,cache=FALSE,fig.width=11,fig.height=12}
###Posterior Distributions
ggplot(pars[pars$par %in% c("detect","alpha","beta","polybeta"),],aes(x=estimate)) + geom_histogram() + ggtitle("Estimate of parameters") + facet_grid(species~par,scales="free") + theme_bw() + ggtitle("Detection Probability")

```

```{r,cache=FALSE,eval=TRUE,fig.height=5,fig.width=13}

ggplot(pars[pars$par %in% c("gamma","polygamma","intercept","sigma_int","sigma_slope","sigma_polyslope"),],aes(x=estimate)) + geom_histogram() + ggtitle("Trait matching regression parameters") + facet_wrap(~par,scale="free",nrow=2) + theme_bw() 
```

###Species Predictions

```{r,fig.height=10,fig.width=11}

castdf<-dcast(pars[pars$par %in% c("beta","alpha","polybeta"),], species +Chain + Draw~par,value.var="estimate")

#Turn to 
castdf$species<-factor(castdf$species,levels=1:max(as.numeric(castdf$species)))

species.split<-split(castdf,castdf$species)

species.traj<-list()

trajF<-function(alpha,beta,beta2,x){
  fdat<-data.frame(alpha=alpha,beta=beta,beta2=beta2)
  
  #fit regression for each input estimate
  sampletraj<-list()
  for (s in 1:nrow(fdat)){
    a<-fdat$alpha[s]
    b<-fdat$beta[s]
    b2<-fdat$beta2[s]
    yp=exp(a + (b*x) + (b2*x^2))
    
    #compute pred value
    sampletraj[[s]]<-data.frame(x=x,y=yp)
    }

   sample_all<-rbind_all(sampletraj)
  
  #Compute CI intervals
  predy<-group_by(sample_all,x) %>% summarise(lower=quantile(y,0.025,na.rm=T),upper=quantile(y,0.975,na.rm=T),median=mean(y,na.rm=T))
  return(predy)
  }

for(d in 1:length(species.split)){
  x<-species.split[[d]]
  species.traj[[d]]<-trajF(alpha=x$alpha,beta=x$beta,beta2=x$polybeta,x=as.numeric(traitmatchT))
}

names(species.traj)<-rownames(traitmatchT)

species.traj<-melt(species.traj,id.var=colnames(species.traj[[1]]))

#plot and compare to original data
ggplot(data=species.traj,aes(x=x,fill=L1)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.1)  + geom_line(aes(y=median),size=1.,col="red") + theme_bw() + ylab("Interactions") + xlab("Difference between Bill and Corolla Length") + facet_wrap(~L1,scales="free",ncol=3) + labs(fill="Species")
```

###Overall predicted relationship 

Does accounting for non-independence and detection change our estimate of trait matching?

```{r,fig.height=4,fig.width=4}
 
castdf<-group_by(pars,Chain) %>% sample_n(2000)%>% select(par,estimate) %>% filter(par %in% c("polygamma","gamma","intercept"))

castdf<-dcast(pars[pars$par %in% c("gamma","intercept","polygamma"),], Chain + Draw~par,value.var="estimate")

#calculated predicted y
predy<-trajF(alpha=castdf$intercept,beta=castdf$gamma,beta2=castdf$polygamma,x=round(as.numeric(traitmatchT),2))

#plot and compare to original data
ggplot(data=predy,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.1)  + geom_line(aes(y=median),size=1,col="red") + theme_bw() + ylab("Interactions") + xlab("Difference between Bill and Corolla Length") 
```

The red line is the posterior median with confidible intervals in shaded grey for the proposed bayesian model. The poisson glm that does not account for detectability or non-independence is in green.

**Conclusion:** Accounting for detection and non-independence greatly increases the accuracy of the predicted state. The poisson glm underestimates the strength of trait matching among hummingbirds and their foodplants.

###Poisson regression without detection bias
```{r}

niavedat<-as.data.frame(filter(m.datH,!is.na(Month)) %>% mutate(Time=paste(Month,Year)) %>% group_by(Bird,Plant,Time) %>% summarize(Yobs=sum(obs)))
niavedat$x<-NULL

for (g in 1:nrow(niavedat)){ 
  b<-niavedat[g,"Bird"]
  I<-niavedat[g,"Plant"]
  niavedat[g,"x"]<-traitmatchT[b,I]  
}

niaveobs<-glm(data=niavedat,Yobs~poly(x,2,raw=T),family=poisson())
summary(niaveobs)
niavecoef<-niaveobs$coefficients
predyniave<-trajF(alpha=rep(niavecoef[1],100),beta=rep(niavecoef[2],100),beta2=rep(niavecoef[3],100),x=as.numeric(traitmatchT))

#plot and compare to original data
p<-ggplot(data=predyniave,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.1)  + geom_line(aes(y=median),size=1.,col="blue") + theme_bw() + ylab("Interactions") + xlab("Difference between Bill and Corolla Length") + ggtitle("Without accounting for detection bias")

pboth<-ggplot(data=predyniave,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.1)  + geom_line(aes(y=median),size=1.,col="blue") + theme_bw() + ylab("Interactions") + xlab("Difference between Bill and Corolla Length") + geom_ribbon(data=predy,aes(ymin=lower,ymax=upper),alpha=0.1)  + geom_line(data=predy,aes(y=median),size=1.,col="red") + ggtitle("Accounting for detection bias")
grid.arrange(p,pboth)
```

###Predicted Frequency

```{r,eval=T,fig.height=7,fig.width=12,eval=F}

#any given state
predState<-group_by(pars,par) %>% filter(par=="N") %>% group_by(par,species,plant) %>% summarize(State=as.numeric(names(which.max(table(estimate)))))

#remerge species levels
bindex<-data.frame(Index=1:length(rownames(traitmatchT)),Species=rownames(traitmatchT))

pindex<-data.frame(Index=1:length(colnames(traitmatchT)),Species=colnames(traitmatchT))

predState<-merge(predState,bindex,by.x="species",by.y="Index")

predState<-merge(predState,pindex,by.x="plant",by.y="Index")
colnames(predState)<-c("plant","species","par","State","Bird","Plant")

#order it to show nestedness.
b_ord<-group_by(predState,Bird) %>% summarize(I=sum(State)) %>% arrange(desc(I)) %>% select(Bird)

p_ord<-group_by(predState,Plant) %>% summarize(I=sum(State)) %>% arrange(I) %>% select(Plant)

predState$Bird<-factor(predState$Bird,levels=b_ord$Bird)
predState$Plant<-factor(predState$Plant,levels=p_ord$Plant)

predplot<-ggplot(predState,aes(x=Bird,y=Plant,fill=State)) + geom_tile() + scale_fill_continuous(na.value="white",low="white",high="red",limits=c(0,max(obs.state$Detection))) + labs(x="Hummingbird",y="Plant",fill="Predicted State") + ggtitle("Predicted")

predplot

#discrepancy plot
orig<-group_by(indat,Bird,Plant) %>% summarize(Y=sum(Yobs))

finaldat<-merge(predState,orig,by.x=c("species","plant"),by.y=c("Bird","Plant"))
ggplot(finaldat,aes(x=Y,y=State)) + geom_point() + geom_abline() + coord_equal()
```

```{r}
fitstat<-pars[pars$par %in% c("fit","fitnew"),]
fitstat<-dcast(fitstat,Draw+Chain~par,value.var="estimate")
ggplot(fitstat,aes(x=fit,y=fitnew)) + geom_point() + geom_abline() + coord_equal() + theme_bw()
```

```{r}
save.image("Abundance.Rdata")
```