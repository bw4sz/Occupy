---
title: "Accounting for detection bias increases trait-matching in a tropical plant-hummingbird network"
author: "Ben Weinstein"
date: "Monday, March 16, 2015"
output: html_document
---

```{r,warning=FALSE,message=FALSE,echo=FALSE,cache=FALSE}
library(reshape2)
library(ggplot2)
library(knitr)
library(R2jags)
library(dplyr)
library(stringr)
library(gridExtra)
library(boot)
library(picante)
library(bipartite)

opts_chunk$set(message=FALSE,warning=FALSE,fig.width=5,fig.height=4,echo=FALSE,cache=TRUE,cache.path = 'jp_cache/',fig.align='center',fig.path="figure/")

setwd("C:/Users/Ben/Documents/Occupy/")

set.seed(11)

```

#Aim

Network ecology is a rapidly developing field that uses graph theory to represents interactions among plants and pollinators, hosts and parasites, and herbivores and hosts. One aim of network ecology is to quantify the rate of interaction among partners, their relative specialization, and the robustness of these interactions to perturbation. Considerable work has focused on the effect sampling on network structure and how best to measure network properties (Bluthgen, Bascompte, Jordano). Considerably less work has focused on a more fundamental problem of network ecology: Our ability to detect interactions is imperfect in time and space. This limitation is a fundamental assumption in wildlife ecology, where occupancy models are common(). In occupancy modeling, repeated surveys of the same site are used to estimate the probability of detection given a species probability of occurrence. The probability of occurrence is a latent variable which cannot be directly infered from the data. If we did not see a species at a site, was it absent or undetected? By analogy, if we failed to find a pollinator interacting with a plant, is it due to detection or is it a 'forbidden link' due mismatch in species ecology? The goal of this paper is to use a large dataset on plant-hummingbird interactins from a tropical montane forest to evaluate the effect of imperfect detection on estimating species interactions and network properties. We will then seperate estimate environmental and morphological covariates to both the probability of interaction ($\psi$) as well as the probability of detection (p).

#Background

  Collecting network data is time consuming and few studies have the resources to adopt a repeated measures sampling design. The hummingbird dataset in this paper was collected using time-lapse cameras which turn on at dawn and dusk automatically. In addition, more traditional hummingbird transects were used to survey flower visitation. Combining these sampling types, we have a very large network with over 3,000 interactions (Weinstein XXXX).

#Similiar work

  * http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0069200
  * http://onlinelibrary.wiley.com/doi/10.1111/j.2041-210x.2012.00249.x/abstract

#Approach

Occupancy models are complex and require fiting a number of latent variables. Before I fit models to an observed dataset, it is crucial that I simulate data with known results to show that the models are performing well. The goal is to create datasets that match the size and characteristics of our observed data. I will begin slowly, beginning with constant detection and occupancy. The ultimate goal is a model that can estimate occupancy and detection as a hierarchical distribution with uneven sampling at sites. This model will be used to compare niche overlap as a function of available resources, as well as the importance of trait matching in determing occupancy.

**In this study we want to estimate three quantitites:**

$$\hat{Y}_{i,j} = \text{Frequency of Interactions between Hummingbird_i  at  Flower_j}$$

$$ \psi_{i,j} = \text{The probability a flower is visited by a hummigbird}  $$

$$ p_{i,j} = \text{The probability of detecting a bird-flower interaction given that it occurs} $$


##Simulation

I first create data with constant detection for each hummingbird speices, and the interaction frequency is a function of a species hierarcichal model and corolla similarity. There is uneven sampling among species.

### Parameters

  * 7 hummingbird species
    * Range of hummingbird bill sizes (mm) ~ Pois(10)
  * Ten plants
    * Range of corolla sizes (mm) ~ Pois(20)
  * Mean frequeny ($\lambda$) for each hummingbird is drawn from U(0,10)  
    * For each plant the occupancy is N($\lambda$,0.2) (truncated 0-1) 
    * Trait matching (minimizing Bill-Corolla difference) is drawn from a hierarcichal distribution
    $$logit(true_state)<-\alpha_i + \beta_i *traitmatch + \beta_{2i} * traitmatch^2$$
      $$\alpha=N(3,.01)$$
      $$\beta = N(-.01,.001)$$
      $$\beta_2=N(.-.05,.001)$$
      
  * Imperfect detection 
    * $p_i = U(0,1)$ 
  * 24 month replicates
  * Phenology = .5 (plants are in flower/present .5 of surveys)

************

**View simulated strength and form of trait matching **

```{r,fig.height=5,fig.width=8}
#Number of hummingbird species
h_species=8
plant_species=20
months=24
detection=runif(h_species,0,1)
phenology=.5

#Bill sizes
Bill<-rpois(h_species,10)

#Corolla sizes
Corolla<-rpois(plant_species,15)

#Subtract both
traitmatch<-sapply(Corolla,function(x) x - Bill)

#regression slope
intercept<-3
gamma<- -0.01
polygamma<- -0.05
sigma_slope<- 0.01
sigma_slope2<- 0.01
sigma_intercept<- 0.01

beta<-rnorm(h_species,gamma,sigma_slope)
beta2<-rnorm(h_species,polygamma,sigma_slope2)
alpha<-rnorm(h_species,intercept,sigma_intercept)

#fit regression
lambda<-exp(alpha + beta * traitmatch + beta2*traitmatch^2)

true_interactions<-sapply(lambda,function(x){rpois(1,x)})

#convert to matrix
true_interactions<-matrix(nrow=h_species,ncol=plant_species,data=true_interactions)

#combine and melt into a single dataframe
mdat<-dcast(melt(list(y=true_interactions,x=traitmatch)),Var1+Var2~L1)

ggplot(mdat,aes(x=x,y=y,col=Var1)) + geom_point() + geom_smooth(method="glm",family="poisson",formula=y~poly(x,2)) + theme_bw() + labs(x="Bill-Corolla Difference",y="Occurrences","Hummingbird") + ggtitle("Correlation in Simulated Data")

```

### True Interaction Matrix

```{r,fig.width=12}
#Reshape into a nicer format
colnames(mdat)<-c("Hummingbird","Plant","Bill_Diff","True_State")

trueplot<-ggplot(mdat,aes(y=as.factor(Plant),x=as.factor(Hummingbird),fill=True_State)) + geom_tile() + labs(x="Hummingbird",y="Plant",fill="Presence") + ggtitle("True State ") + scale_fill_continuous(low="white",high="red","Occurrences")
```

```{r,fig.width=11,fig.height=4}
##Simulate detection 

#for each species loop through and create a replicate dataframe
obs<-array(dim=c(h_species,plant_species,months))

#Which months are plants in bloom?
#This is the phenology matrix
sampled<-replicate(plant_species,rbinom(months,1,phenology))
sampled[sampled==0]<-NA

for(x in 1:h_species){
  for (y in 1:plant_species){
    
    #True State
    ts<-true_interactions[x,y]
    
    #detections are function of phenology detection probability and occupancy
    det<-rbinom(months,ts,detection[x])
    
    #detections and phenology
    obs[x,y,]<-det *sampled[,y]
    }
  }

#plot observed state
obs.state<-melt(obs)
colnames(obs.state)<-c("Hummingbird","Plant","Month","Detections")

#turn NA's to 0
obs.state$Detections[is.na(obs.state$Detections)]<-0

obs.state$Hummingbird<-as.factor(obs.state$Hummingbird)
obs.state$Plant<-factor(obs.state$Plant,levels=1:plant_species)

ob1<-ggplot(obs.state[obs.state$Month==12,],aes(x=Hummingbird,y=Plant,fill=Detections)) + geom_tile() + scale_fill_continuous(low="white",high="Red",limits=c(0,max(mdat$True_State))) + ylab("Plant") + ggtitle("Example 1") + xlab("Hummingbird")

ob2<-ggplot(obs.state[obs.state$Month==18,],aes(x=Hummingbird,y=Plant,fill=Detections)) + geom_tile() + scale_fill_continuous(low="white",high="Red",limits=c(0,max(mdat$True_State))) + ylab("Plant") + ggtitle("Example 2") + xlab("Hummingbird")

grid.arrange(trueplot,ob1,ob2,nrow=1)
```

The left hand panel is the true state for each hummingbird plant combination. The middle and right hand panel are two realizations that might result from a month of sampling given incomplete detection and phenology.

```{r}
d<-merge(mdat,obs.state)
ggplot(d,aes(x=True_State,y=Detections,col=Month)) + geom_point() + theme_bw() + geom_abline() + coord_equal()
```

#Niave Estimate of Trait-Matching

Fit a model of observations without repect to their hierarcichal structure or with detection bias.

Observations between each bird and flower is modeled as a poisson with a lognormal link. 

$$Y{i,j} \sim Pois(\lambda)$$
$$log(\lambda) = \alpha + \beta * (Bill_i-Corolla_i)$$

```{r}
niave<-glm(data=d,Detections~poly(Bill_Diff,2,raw=T)  ,family=poisson())
pm<-predict(niave,type="response")
niave.pred<-data.frame(x=d$Bill_Diff,y=pm)
true.pred<-data.frame(x=d$Bill_Diff,y=d$True_State)
detect.pred<-data.frame(x=d$Bill_Diff,y=d$Detections)
pred.frame<-melt(list(Niave=niave.pred,Detections=detect.pred),id.var=c("x","y"))
ggplot(pred.frame,aes(x=x,y=y,col=L1)) + geom_point(data=pred.frame[pred.frame$L1=='Detections',],size=2.5) + theme_bw() + geom_line(data=pred.frame[pred.frame$L1=='Niave',]) + labs(col="",x="Bill Length- Corolla Length",y="Interactions") + scale_color_discrete(labels=c("Observations","Poisson GLM"))
```

## Hierarcichal Occupancy Model Formulation

###Observation

The number of observations observed between $hummingbird_i$ and $flower_j$ in $survey_k$ is a binomial trail where the probability of detecting a species is a species specific parameter detect with N trials.

$$ Y_{i,j,k} \sim Binom(N_{i,j},detect_i)$$

###Process

N is the underlying frequency of interactions among each pair of plants and hummingbirds drawn from a poisson with $\lambda_{i,j}$, which is modeled as lognormal distributions 

$$N_{i,j} \sim Pois(\lambda_{i,j}) $$
$$log(\lambda_{i,j})<-\alpha_i + \beta_i * (Bill_i - Corolla_i) + \beta_{i2} *(Bill_i - Corolla_i)^2 $$

###Fixed species level priors
$$detect_i \sim U(0,1)$$ 
**Detection is set for each bird species** This could account for differing abundances or foraging intensity.
    
###Hierarchical Priors
  
Species level priors for the strength of trait-matching is drawn from a normal distribution of for all hummingirds.

$$\alpha_i \sim N(intercept,\tau_{\alpha})$$

$$\beta_i \sim N(\gamma,\tau_{\beta})$$

$$\beta_{i2} \sim N(\gamma,\tau_{polybeta})$$    
    
**Hyperpriors**

$$gamma \sim N(0.001,0.001)$$
$$polygamma \sim N(0.001,0.001)$$
$$intercept \sim N(0.001,0.001)$$
  
$$\tau_{\alpha} \sim Gamma(0.001,0.001)$$
$$\tau_\beta \sim Gamma(0.001,0.001)$$
$$\tau_{polybeta} \sim Gamma(0.001,0.001)$$

**Derived quantities**

$$\sigma_{int} = \frac{1}{\tau_{\alpha}}^2$$
$$\sigma_{slope} = \frac{1}{\tau_{\beta}}^2$$
$$\sigma_{polyslope} = \frac{1}{\tau_{poly\beta}}^2$$

```{r,eval=T}
 setwd("C:/Users/Ben/Documents/Occupy/Bayesian")

runs<-10000

#Source model
source("NMixture.R")
 
#print model
print.noquote(readLines("NMixture.R"))

#Input Data
Dat <- list(
  Y=obs,
  Plants=plant_species,
  Birds=h_species,
  Months=months,
  traitmatch=traitmatch
  )

#A blank Y matrix - all present
initY<-true_interactions+1

#Inits
InitStage <- function() {list(beta=rep(.5,h_species),alpha=rep(.5,h_species),detect=rep(.5,h_species),gamma=0,intercept=0,tau_alpha=0.1,tau_beta=0.1,N=initY)}

#Parameters to track
ParsStage <- c("detect","alpha","beta","intercept","gamma","sigma_int","sigma_slope","N","polybeta","sigma_polyslope","polygamma")

#MCMC options
ni <- runs  # number of draws from the posterior
nt <- runs*.001   #thinning rate
nb <- 0 # number to discard for burn-in
nc <- 2  # number of chains

#Jags

m = jags(inits=InitStage,
         n.chains=nc,
         model.file="NMixture.jags",
         working.directory=getwd(),
         data=Dat,
         parameters.to.save=ParsStage,
         n.thin=nt,
         n.iter=ni,
         n.burnin=nb,
         DIC=T)
```

```{r,echo=FALSE,eval=F}
#Update if needed
recompile(m5)
add<-1000000
m5 <- update(m5,n.iter=add)
```

```{r}
  #extract desired info from the models
  parsO<-melt(m$BUGSoutput$sims.array)
  colnames(parsO)<-c("Draw","Chain","parameter","estimate")
  parsO<-parsO[!parsO$Draw %in% 1:(max(parsO$Draw)-3000/m$BUGSoutput$n.chains),]
  
  #label species and plants
  l<-levels(parsO$parameter)

  #parameters to save
  totrack<-m$parameters.to.save
  
  sp_pl<-data.frame(parameter=l,str_match(l,pattern="(\\d+),(\\d+)")[,-1],par=str_extract(l,paste(totrack,collapse="|")))
  
  colnames(sp_pl)<-c("parameter","species","plant","par")

  sp_pl[is.na(sp_pl$species),c("species")]<-str_extract(sp_pl[is.na(sp_pl$species),"parameter"],"\\d+")

  #merge levels
  pars<-merge(parsO,sp_pl)
  
  #take out deviance
  pars<-pars[!pars$par %in% "deviance",]
  
```

###Assess Convergence

```{r,cache=FALSE,eval=TRUE,fig.width=11,fig.height=5}

###Chains
ggplot(pars[pars$par %in% c("detect","alpha","beta","polybeta"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_grid(par~species,scale="free") + theme_bw() + labs(col="Chain") + ggtitle("Detection Probability")

```

```{r,fig.height=5,fig.width=11,eval=T}
ggplot(pars[pars$par %in% c("gamma","polygamma","sigma_int","sigma_slope","sigma_polyslope"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + theme_bw() + labs(col="Chain") + ggtitle("Trait-matching regression") + facet_wrap(~par,scales="free")
```

###Posteriors

```{r,cache=FALSE,fig.width=7,fig.height=5}
###Posterior Distributions
p<-ggplot(pars[pars$par %in% c("detect","alpha","beta","polybeta"),],aes(x=estimate)) + geom_histogram() + ggtitle("Estimate of parameters") + facet_grid(species~par,scales="free") + theme_bw() + ggtitle("Detection Probability")

#Add true values
tr<-melt(data.frame(species=1:length(detection),detect=detection,alpha=alpha,beta=beta,polybeta=beta2),id.var='species')
colnames(tr)<-c("species","par","value")
p + geom_vline(data=tr,aes(xintercept=value),col='red',linetype='dashed',size=1)
```

```{r,cache=FALSE,eval=TRUE,fig.height=3,fig.width=10}

p<-ggplot(pars[pars$par %in% c("gamma","polygamma","intercept","sigma_int","sigma_slope","sigma_polyslope"),],aes(x=estimate)) + geom_histogram() + ggtitle("Trait matching regression parameters") + facet_grid(~par,scale="free") + theme_bw() 

#Add true values
tr<-melt(list(gamma=gamma,intercept=intercept,sigma_int=sigma_intercept,sigma_slope=sigma_slope,sigma_polyslope=sigma_slope2,polygamma=polygamma))

colnames(tr)<-c("value","par")

p + geom_vline(data=tr,aes(xintercept=value),linetype='dashed',size=1,col="red")
```

**True values are given in the dashed lines.**

###Predicted Relationship 

Does accounting for non-independence and detection change our estimate of trait matching?

```{r,fig.height=4,fig.width=4}
 
castdf<-group_by(pars,Chain) %>% sample_n(2000)%>% select(par,estimate) %>% filter(par %in% c("polygamma","gamma","intercept"))

castdf<-dcast(pars[pars$par %in% c("gamma","intercept","polygamma"),], Chain + Draw~par,value.var="estimate")
castdf<-castdf[sample(1:nrow(castdf),1500),]

trajF<-function(alpha,beta,beta2,x){
  indat<-cbind(alpha,beta,beta2)
  
  #fit regression for each input estimate
  sampletraj<-apply(indat,1,function(s){
    data.frame(x=x,y=exp(s['alpha'] + s['beta'] *x + s['beta2']*x^2))})
  sample_all<-rbind_all(sampletraj)
  
  #Compute CI intervals
  predy<-group_by(sample_all,x) %>% summarise(lower=quantile(y,0.025,na.rm=T),upper=quantile(y,0.975,na.rm=T),mean=mean(y,na.rm=T))
  }

#calculated predicted y
predy<-trajF(alpha=castdf$intercept,beta=castdf$gamma,beta2=castdf$polygamma,x=as.numeric(traitmatch))

orig<-trajF(alpha=rnorm(2000,intercept,sigma_intercept),beta=rnorm(2000,gamma,sigma_slope),beta2=rnorm(2000,polygamma,sigma_slope2),x=as.numeric(traitmatch))

niaveP<-trajF(alpha=rep(niave$coefficients[1],100),beta=rep(niave$coefficients[2],100),beta2=rep(niave$coefficients[3],100),x=as.numeric(traitmatch))

#plot and compare to original data
ggplot(data=predy,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.1)  + geom_line(aes(y=mean),size=1.,col="red") + theme_bw() + ylab("Interactions") + geom_line(data=orig,aes(x=x,y=mean),col='blue',linetype="dashed",size=1) + geom_line(data=niaveP,aes(x=x,y=mean),col="green") + xlab("Difference between Bill and Corolla Length") 
```

Blue line is the true relationship. The red line is the posterior mean with confidible intervals in shaded grey for the proposed bayesian model. The poisson glm that does not account for detectability or non-independence is in green.


**Conclusion:** Accounting for detection and non-independence greatly increases the accuracy of the predicted state. The poisson glm underestimates the strength of trait matching among hummingbirds and their foodplants.

###Predicted Frequency

Validating the model.

```{r,eval=T}

#any given state
predState<-group_by(pars,par) %>% filter(par=="N") %>% group_by(par,species,plant) %>% summarize(State=as.numeric(names(which.max(table(estimate)))))

predState$species<-as.factor(predState$species)
predState$plant<-factor(predState$plant,levels=1:plant_species)

predplot<-ggplot(predState,aes(x=species,y=plant,fill=State)) + geom_tile() + scale_fill_continuous(na.value="white",low="white",high="red",limits=c(0,max(obs.state$Detection))) + labs(x="Hummingbird",y="Plant",fill="Predicted State") + ggtitle("Predicted")

#compare true and pred states
tr<-melt(true_interactions)
colnames(tr)<-c("Hummingbird","Plant","True_State")

mdat<-merge(predState,tr,by.x=c("species","plant"),by.y=c("Hummingbird","Plant"))

ggplot(mdat,aes(y=State,x=True_State)) + geom_point(size=3) + geom_abline(linetype="dashed") + theme_bw() + xlab("True State") + ylab("Predicted State") + coord_equal()
```

***********

#Observed dataset
