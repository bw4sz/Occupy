---
title: "Combining automated monitering and bayesian occupancy models for detecting rare plant-animal interactions"
author: "Ben Weinstein"
date: "Tuesday, February months, 2015"
output: html_document
---

```{r,warning=FALSE,message=FALSE,echo=FALSE,cache=FALSE}
library(reshape2)
library(ggplot2)
library(knitr)
library(R2jags)
library(dplyr)
library(stringr)
library(gridExtra)
library(boot)
opts_chunk$set(message=FALSE,warning=FALSE,fig.width=4,fig.height=3,echo=FALSE,cache=TRUE,cache.path = 'jp_cache/',fig.align='center',fig.path="figure/")

setwd("C:/Users/Ben/Documents/Occupy/")

set.seed(3)
#If updating the model, just reload
load("C:/Users/Ben/Dropbox/Thesis/Occupancy/Simulation.Rdata")
```

#Aim

Network ecology is a rapidly developing field that uses graph theory to represents interactions among plants and pollinators, hosts and parasites, and herbivores and hosts. One aim of network ecology is to quantify the rate of interaction among partners, their relative specialization, and the robustness of these interactions to perturbation. Considerable work has focused on the effect sampling on network structure and how best to measure network properties (Bluthgen, Bascompte, Jordano). Considerably less work has focused on a more fundamental problem of network ecology: Our ability to detect interactions is imperfect in time and space. This limitation is a fundamental assumption in wildlife ecology, where occupancy models are common(). In occupancy modeling, repeated surveys of the same site are used to estimate the probability of detection given a species probability of occurrence. The probability of occurrence is a latent variable which cannot be directly infered from the data. If we did not see a species at a site, was it absent or undetected? By analogy, if we failed to find a pollinator interacting with a plant, is it due to detection or is it a 'forbidden link' due mismatch in species ecology? The goal of this paper is to use a large dataset on plant-hummingbird interactins from a tropical montane forest to evaluate the effect of imperfect detection on estimating species interactions and network properties. We will then seperate estimate environmental and morphological covariates to both the probability of interaction ($\psi$) as well as the probability of detection (p).

#Background

  Collecting network data is time consuming and few studies have the resources to adopt a repeated measures sampling design. The hummingbird dataset in this paper was collected using time-lapse cameras which turn on at dawn and dusk automatically. In addition, more traditional hummingbird transects were used to survey flower visitation. Combining these sampling types, we have a very large network with over 3,000 interactions (Weinstein XXXX).

#Similiar work

  * http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0069200
  * http://onlinelibrary.wiley.com/doi/10.1111/j.2041-210x.2012.00249.x/abstract


#Approach

Occupancy models are complex and require fiting a number of latent variables. Before I fit models to an observed dataset, it is crucial that I simulate data with known results to show that the models are performing well. The goal is to create datasets that match the size and characteristics of our observed data. I will begin slowly, beginning with constant detection and occupancy. The ultimate goal is a model that can estimate occupancy and detection as a hierarchical distribution with uneven sampling at sites. This model will be used to compare niche overlap as a function of available resources, as well as the importance of trait matching in determing occupancy.

**Simulation 0: Constant occupancy and detection for all species**

**Simulation 1: Constant occupancy and detection within each hummingbird species.**

**Simulation 2: Constant detection but variable occupancy for each hummingbird species for each plant**

**Simulation 3: Constant detection but variable occupancy for each hummingbird species. The occupancy of each plant-bird combination is drawn from a hierarchical distribution for each hummingbird species.**

**Simulation 4: Constant detection, and hierarchical occupancy with uneven sampling among plants.**

**Simulation 5: Constant detection for each hummingbird speices, occupancy is function of species hierarcichal model and corolla similarity.**

````

**In this study we want to estimate three quantitites:**

$$\hat{Y}_{i,j} = \text{Detection  of  Hummingbird i  at  Flower j}$$

$$ \psi_{i,j} = \text{the probability a flower is visited by a hummigbird}  $$

$$ p_{i,j} = \text{the probability of detecting a bird-flower interaction given that it occurs} $$

##Simulation 0: Constant occupancy and detection
Consider a matrix of interactions, where we assume interactions among plants and hummingbirds are independent.

### Parameters

  * 2 hummingbirds
  * 10 plants
  * Known occupancy $\psi = .8$
  * Imperfect detection $p = .7$ 
  * 24 Months replicates

Each species gets their own occupancy and imperfect detection which is drawn from uniform distribution. The goal is **recover these parameters**.

```{r}
#Number of hummingbird species
h_species=7
plant_species=10
months=24
detection=rep(0.7,h_species)
occupancy=rep(0.8,h_species)
dat<-t(sapply(occupancy,function(x){rbinom(plant_species,1,x)}))
```

### True Interaction Matrix

```{r}
#Reshape into a nicer format
mdat<-melt(dat)
colnames(mdat)<-c("Plant","Hummingbird","True_State")
trueplot<-ggplot(mdat,aes(x=as.factor(Plant),y=as.factor(Hummingbird),fill=as.factor(True_State))) + geom_tile() + scale_fill_manual(labels=c(0,1),values=c("White","Black")) + labs(x="Hummingbird",y="Plant",fill="Presence") + ggtitle("True State")
```


```{r,fig.width=11,fig.height=3}
##Simulate detection 

#for each species loop through and create a replicate dataframe
obs<-array(dim=c(h_species,plant_species,months))

for(x in 1:h_species){
  for (y in 1:plant_species){
    ts<-dat[x,y]
    obs[x,y,]<-rbinom(months,1,detection[x]) * ts
    }
  }

#plot observed state
obs.state<-melt(obs)
colnames(obs.state)<-c("Hummingbird","Plant","Month","Presence")
obs.state<-group_by(obs.state,Hummingbird,Plant) %>% summarize(Detections=sum(Presence))
obplot<-ggplot(obs.state,aes(x=Hummingbird,y=as.factor(Plant),fill=Detections)) + geom_tile() + scale_fill_continuous(low="white",high="Red") + ylab("Plant") + ggtitle("Observed")
grid.arrange(trueplot,obplot,nrow=1)
```

##Occupancy model formulation
For each hummingbird (i), plant (j) and month (k):

$$ Y_{i,j,k} \sim Bern(sightp_{i,j,k})$$
$$sightp_{i,j,k} = present_{i,j} * detect$$
$$present_{i,j} \sim Bern(occ) $$

```{r,eval=T}
setwd("C:/Users/Ben/Documents/Occupy/Bayesian")

runs<-40000

#Source model
source("Simulation.R")
 
#print model
print.noquote(readLines("Simulation.R"))

#Input Data
Dat <- list(
  Y=obs,
  Plants=plant_species,
  Birds=h_species,
  Months=months
  )

#A blank Y matrix - all present
initY<-matrix(nrow=h_species,ncol=plant_species,data=1)


#Inits
InitStage <- function() {list(occ=.5,detect=.5,present=initY)}

#Parameters to track
ParsStage <- c("occ","detect")

#MCMC options
ni <- runs  # number of draws from the posterior
nt <- runs*.0001   #thinning rate
nb <- 0 # number to discard for burn-in
nc <- 2  # number of chains

#Jags

m0 = jags(inits=InitStage,
         n.chains=nc,
         model.file="Simulation.jags",
         working.directory=getwd(),
         data=Dat,
         parameters.to.save=ParsStage,
         n.thin=nt,
         n.iter=ni,
         n.burnin=nb,
         DIC=T)
```

```{r,cache=FALSE}

#Trim chains from model m2 to 2000 posterior draws and return parameters detect and occ
  parsO<-melt(m0$BUGSoutput$sims.array)
  colnames(parsO)<-c("Draw","Chain","parameter","estimate")
  parsO<-parsO[!parsO$Draw %in% 1:(max(parsO$Draw)-2000/m0$BUGSoutput$n.chains),]
  
  #take out deviance
  #label parameter
  pars<-parsO[parsO$parameter %in% c("detect","occ"),]
```

###Assess Convergence
```{r,cache=FALSE,eval=TRUE,fig.width=8,fig.height=2}
###Chains
ggplot(pars,aes(x=Draw,col=as.factor(Chain),y=estimate)) + geom_line() + facet_grid(~parameter,scale="free") + theme_bw() + labs(col="Chain") 
```

###Posteriors
```{r,cache=FALSE,eval=TRUE,fig.height=3,fig.width=10}
###Posterior Distributions
p<-ggplot(pars,aes(x=estimate)) + geom_histogram() + ggtitle("Estimate of parameters") + facet_grid(~parameter,scale="free") + theme_bw() 

#Add true values
tr<-melt(data.frame(species=1:length(detection),detect=detection,occ=occupancy),id.var='species')

colnames(tr)<-c("species","parameter","value")

p + geom_vline(data=tr,aes(xintercept=value),col='red',linetype='dashed',size=1) + xlim(0,1)
```

**True values are given in the red dashed lines.**
Species are the rows.

```{r}
###Parameter estimates

parG<-group_by(pars,parameter)
m0<-summarise(parG,mean=mean(estimate),lower=quantile(estimate,0.025),upper=quantile(estimate,0.975),sd=sd(estimate))
```

## Simulation 1: Constant occupancy and detection for each hummingbird species

Consider a matrix of interactions, where we assume interactions among plants and hummingbirds are independent.

### Parameters

  * 7 hummingbirds
  * 10 plants
  * Known occupancy $\psi = U(.5,1)$
    * At very low occupancies, the interaction is too rare to estimate.
  * Imperfect detection $p = U(0,1)$ 
  * 24 Months replicates

Each species gets their own occupancy and imperfect detection which is drawn from uniform distribution. The goal is **recover these parameters**.

```{r}
#Number of hummingbird species
h_species=7
plant_species=10
months=24
detection=runif(h_species,0,1)
occupancy=runif(h_species,.5,1)
dat<-t(sapply(occupancy,function(x){rbinom(plant_species,1,x)}))
```

### True Interaction Matrix

```{r}
#Reshape into a nicer format
mdat<-melt(dat)
colnames(mdat)<-c("Plant","Hummingbird","True_State")
trueplot<-ggplot(mdat,aes(x=as.factor(Plant),y=as.factor(Hummingbird),fill=as.factor(True_State))) + geom_tile() + scale_fill_manual(labels=c(0,1),values=c("White","Black")) + labs(x="Hummingbird",y="Plant",fill="Presence") + ggtitle("True State")
```


```{r,fig.width=7,fig.height=3}

##Simulate detection 
#for each species loop through and create a replicate dataframe
obs<-array(dim=c(h_species,plant_species,months))

for(x in 1:h_species){
  for (y in 1:plant_species){
    ts<-dat[x,y]
    obs[x,y,]<-rbinom(months,1,detection[x]) * ts
    }
  }
#plot observed state
obs.state<-melt(obs)
colnames(obs.state)<-c("Hummingbird","Plant","Month","Presence")
obs.state<-group_by(obs.state,Hummingbird,Plant) %>% summarize(Detections=sum(Presence))
obplot<-ggplot(obs.state,aes(x=Hummingbird,y=as.factor(Plant),fill=Detections)) + geom_tile() + scale_fill_continuous(low="white",high="Red") + ylab("Plant") + ggtitle("Observed")
grid.arrange(trueplot,obplot,nrow=1)
```

Data is stored in a multidimensional array
Hummingbird 1 on Plant 1 - True State is Present

```{r}
dat[1,1]
```

Observed state from the simulated transect data

**Format is [Hummingbird,Plants,Month]**

```{r}
obs[1,1,]
```

##Occupancy model formulation
For each hummingbird (i), plant (j) and month (k):

$$ Y_{i,j,k} \sim Bern(sightp_{i,j,k})$$
$$sightp_{i,j,k} = present_{i,j} * detect_i$$
$$present_{i,j} \sim Bern(occ_i) $$

```{r,eval=T}
setwd("C:/Users/Ben/Documents/Occupy/Bayesian")

runs<-40000

#Source model
source("Simulation1.R")
 
#print model
print.noquote(readLines("Simulation1.R"))

#Input Data
Dat <- list(
  Y=obs,
  Plants=plant_species,
  Birds=h_species,
  Months=months
  )

#A blank Y matrix - all present
initY<-matrix(nrow=h_species,ncol=plant_species,data=1)


#Inits
InitStage <- function() {list(occ=rep(.5,h_species),detect=rep(.5,h_species),present=initY)}

#Parameters to track
ParsStage <- c("occ","detect")

#MCMC options
ni <- runs  # number of draws from the posterior
nt <- runs*.0001   #thinning rate
nb <- 0 # number to discard for burn-in
nc <- 2  # number of chains

#Jags

m = jags(inits=InitStage,
         n.chains=nc,
         model.file="Simulation1.jags",
         working.directory=getwd(),
         data=Dat,
         parameters.to.save=ParsStage,
         n.thin=nt,
         n.iter=ni,
         n.burnin=nb,
         DIC=T)
```

```{r update,echo=FALSE,eval=F}
#Update if needed
recompile(m)
add<-1000000
m2 <- update(m,n.iter=add)
```

```{r,cache=FALSE}

#Trim chains from model m2 to 2000 posterior draws and return parameters detect and occ
  parsO<-melt(m$BUGSoutput$sims.array)
  colnames(parsO)<-c("Draw","Chain","parameter","estimate")
  parsO<-parsO[!parsO$Draw %in% 1:(max(parsO$Draw)-2000/m$BUGSoutput$n.chains),]
  
  #take out deviance
  #label parameter
  totrack<-paste(c("detect","occ"),collapse="|")
  parsO$par<-str_extract(parsO$parameter,totrack)
  
  #label species
  parsO$species<-str_extract(parsO$parameter,"\\d+")
  pars<-parsO[parsO$par %in% c("detect","occ"),]
```

###Assess Convergence
```{r,cache=FALSE,eval=TRUE,fig.width=10,fig.height=3}
###Chains
ggplot(pars,aes(x=Draw,col=as.factor(Chain),y=estimate)) + geom_line() + facet_grid(species~par,scale="free") + theme_bw() + labs(col="Chain") 
```

###Posteriors
```{r,cache=FALSE,eval=TRUE}
###Posterior Distributions
p<-ggplot(pars,aes(x=estimate)) + geom_histogram() + ggtitle("Estimate of parameters") + facet_grid(species~par,scale="free") + theme_bw() 

#Add true values
tr<-melt(data.frame(species=1:length(detection),detect=detection,occ=occupancy),id.var='species')

colnames(tr)<-c("species","par","value")

p + geom_vline(data=tr,aes(xintercept=value),col='red',linetype='dashed',size=1)
```

**True values are given in the red dashed lines.**
Species are the rows.

```{r}
###Parameter estimates

parG<-group_by(pars,parameter)
out_m2<-summarise(parG,mean=mean(estimate),lower=quantile(estimate,0.025),upper=quantile(estimate,0.975),sd=sd(estimate))
```

##Conclusion

We were able to recover the true data for detection, but less accurate for occupancy (the right hand column).

**Question 1: Why is occupancy harder to predict? Do we need more data? The chains look pretty converged. There are two types of additional data, more sites (flowers) and more visits (replicates), which type of data will help us estimate more accurately?**

## Simulation 2: Constant detection but variable occupancy for each hummingbird species for each plant

Here we assume that the probability of detection is related to abundance and the abundance of species is constant within the sampling window. Therefore each hummingbird species gets a detection probability, but each plant-hummingbird gets a occupancy. 

### Parameters

  * 7 hummingbird species
  * 5 plants
  * Variable occupancy for each plant $\psi_{i,j} = U(0,1)$
  * Imperfect detection $p = U(0,1)$ for each hummingbird species
  * 24 Months replicates

```{r}
#Number of hummingbird species
h_species=7
plant_species=5
months=24
detection=runif(h_species,0,1)
occupancy=replicate(plant_species,runif(h_species,.5,1))
dat<-matrix(nrow=h_species,ncol=plant_species,data=rbinom(occupancy,1,occupancy))
```

### True Interaction Matrix

```{r}
#Reshape into a nicer format
mdat<-melt(dat)
colnames(mdat)<-c("Plant","Hummingbird","True_State")
trueplot<-ggplot(mdat,aes(x=as.factor(Plant),y=as.factor(Hummingbird),fill=as.factor(True_State))) + geom_tile() + scale_fill_manual(labels=c(0,1),values=c("White","Black")) + labs(x="Hummingbird",y="Plant",fill="Presence") + ggtitle("True State ")
```

```{r,fig.width=7,fig.height=3}
##Simulate detection 

#for each species loop through and create a replicate dataframe
obs<-array(dim=c(h_species,plant_species,months))

for(x in 1:h_species){
  for (y in 1:plant_species){
    ts<-dat[x,y]
    obs[x,y,]<-rbinom(months,1,detection[x]) * ts
    }
  }

#plot observed state
obs.state<-melt(obs)
colnames(obs.state)<-c("Hummingbird","Plant","Month","Presence")
obs.state<-group_by(obs.state,Hummingbird,Plant) %>% summarize(Detections=sum(Presence))
obplot<-ggplot(obs.state,aes(x=Hummingbird,y=as.factor(Plant),fill=Detections)) + geom_tile() + scale_fill_continuous(low="white",high="Red") + ylab("Plant") + ggtitle("Observed")
grid.arrange(trueplot,obplot,nrow=1)
```

## Occupancy Model Formulation

$$ Y_{i,j,k} \sim Bern(sightp_{i,j,k})$$
$$sightp_{i,j,k} = present_{i,j} * detect_i$$
$$present_{i,j} \sim Bern(occ_{i,j}) $$

```{r,eval=T}
setwd("C:/Users/Ben/Documents/Occupy/Bayesian")

runs<-40000

#Source model
source("Simulation2.R")
 
#print model
print.noquote(readLines("Simulation2.R"))

#Input Data
Dat <- list(
  Y=obs,
  Plants=plant_species,
  Birds=h_species,
  Months=months
  )

#A blank Y matrix - all present
initY<-matrix(nrow=h_species,ncol=plant_species,data=1)

#Initial occupancy matrix
initOcc<-matrix(h_species,plant_species,data=1)

#Inits
InitStage <- function() {list(occ=initOcc,detect=rep(.5,h_species),present=initY)}

#Parameters to track
ParsStage <- c("occ","detect")

#MCMC options
ni <- runs  # number of draws from the posterior
nt <- runs*0.0001   #thinning rate
nb <- 0 # number to discard for burn-in
nc <- 2  # number of chains

#Jags

m2 = jags(inits=InitStage,
         n.chains=nc,
         model.file="Simulation2.jags",
         working.directory=getwd(),
         data=Dat,
         parameters.to.save=ParsStage,
         n.thin=nt,
         n.iter=ni,
         n.burnin=nb,
         DIC=T)
```

```{r update2,echo=FALSE,eval=F}
#Update if needed
recompile(m2)
add<-1000000
m <- update(m2,n.iter=add)
```

```{r}
  parsO<-melt(m2$BUGSoutput$sims.array)
  colnames(parsO)<-c("Draw","Chain","parameter","estimate")
  parsO<-parsO[!parsO$Draw %in% 1:(max(parsO$Draw)-2000/m2$BUGSoutput$n.chains),]
  
  
  #label species and plants
  l<-levels(parsO$parameter)
  sp_pl<-data.frame(parameter=l,str_match(l,pattern="(\\d+),(\\d+)")[,-1],par=str_extract(l,c("detect|occ")))
  colnames(sp_pl)<-c("parameter","species","plant","par")

  sp_pl[is.na(sp_pl$species),c("species")]<-str_extract(sp_pl[is.na(sp_pl$species),"parameter"],"\\d+")
  pars<-merge(parsO,sp_pl)
  
  #take out deviance
  pars<-pars[pars$par %in% c("detect","occ"),]
  
```

###Assess Convergence

```{r,cache=FALSE,eval=TRUE,fig.width=10,fig.height=4}

###Chains
ggplot(pars[pars$par %in% "detect",],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_grid(~species,scale="free") + theme_bw() + labs(col="Chain") + ggtitle("Detection Probability")

```

```{r,fig.height=5,fig.width=12}
ggplot(pars[pars$par %in% "occ",],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_grid(plant~species,scale="free") + theme_bw() + labs(col="Chain") + ggtitle("Occupancy Probability")

```

###Posteriors

```{r,cache=FALSE,fig.width=11}
###Posterior Distributions
p<-ggplot(pars[pars$par %in% "detect",],aes(x=estimate)) + geom_histogram() + ggtitle("Estimate of parameters") + facet_grid(species~par,scale="free") + theme_bw() + ggtitle("Detection probability")
#Add true values
tr<-melt(data.frame(species=1:length(detection),detect=detection),id.var='species')
colnames(tr)<-c("species","par","value")
p + geom_vline(data=tr,aes(xintercept=value),col='red',linetype='dashed',size=1)
```

```{r,cache=FALSE,eval=TRUE,fig.height=5,fig.width=11}

p<-ggplot(pars[pars$par %in% "occ",],aes(x=estimate,fill=as.factor(plant))) + geom_histogram() + ggtitle("Estimate of parameters") + facet_grid(plant~species,scale="free") + theme_bw() + ggtitle("Occupancy probability") + labs(fill="Plant Species")

#Add true values
tr<-melt(occupancy)

colnames(tr)<-c("species","plant","value")

p + geom_vline(data=tr,aes(xintercept=value),linetype='dashed',size=1)
```

**True values are given in the dashed lines.**

```{r,eval=TRUE}
###Parameter estimates

parG<-group_by(pars,parameter)
out_m2<-summarise(parG,mean=mean(estimate),lower=quantile(estimate,0.025),upper=quantile(estimate,0.975),sd=sd(estimate))
```

## Simulation 3: Constant detection and varying occupancy drawn from a hierarcichal distribution.

Here we assume that the probability of detection is related to abundance and the abundance of species is constant within the sampling window. Therefore each hummingbird species gets a detection probability, but each plant-hummingbird gets a occupancy. 

### Parameters

  * 7 hummingbird species
  * Ten plants
  * Mean occupancy ($\gamma$) for each hummingbird is drawn from U(0.5,1)  
    * For each plant the occupancy is N($\gamma$,0.1) 
  * Imperfect detection $p = U(0,1)$ for each hummingbird species
  * 24 months replicates

```{r}
#Number of hummingbird species
h_species=7
plant_species=10
months=24
detection=runif(h_species,0,1)

#normally distributed centered on for each hummingbird species
gamma=runif(h_species,0.5,1)
sigma=runif(h_species,0.1,0.5)

#draw occupancy values for each plant
occupancy<-mapply(function(x,y){rnorm(plant_species,x,0.1)},gamma,sigma)

#truncate normal
occupancy[occupancy>1]<-1
occupancy[occupancy<0]<-0

#create data matrix
dat<-matrix(nrow=h_species,ncol=plant_species,data=rbinom(occupancy,1,occupancy))
```

### True Interaction Matrix

```{r}
#Reshape into a nicer format
mdat<-melt(dat)
colnames(mdat)<-c("Plant","Hummingbird","True_State")
trueplot<-ggplot(mdat,aes(x=as.factor(Plant),y=as.factor(Hummingbird),fill=as.factor(True_State))) + geom_tile() + scale_fill_manual(labels=c(0,1),values=c("White","Black")) + labs(x="Hummingbird",y="Plant",fill="Presence") + ggtitle("True State ")
```

```{r, fig.width=8,fig.height=3}
##Simulate detection 

#for each species loop through and create a replicate dataframe
obs<-array(dim=c(h_species,plant_species,months))

for(x in 1:h_species){
  for (y in 1:plant_species){
    ts<-dat[x,y]
    obs[x,y,]<-rbinom(months,1,detection[x]) * ts
    }
  }

#plot observed state
obs.state<-melt(obs)
colnames(obs.state)<-c("Hummingbird","Plant","Month","Presence")
obs.state<-group_by(obs.state,Hummingbird,Plant) %>% summarize(Detections=sum(Presence))
obplot<-ggplot(obs.state,aes(x=Hummingbird,y=as.factor(Plant),fill=Detections)) + geom_tile() + scale_fill_continuous(low="white",high="Red") + ylab("Plant")
grid.arrange(trueplot,obplot,nrow=1)
```

## Occupancy Model Formulation

$$ Y_{i,j,k} \sim Bern(sightp_{i,j,k})$$
$$sightp_{i,j,k} = present_{i,j} * detect_i$$
$$present_{i,j} \sim Bern(occ_{i,j}) $$

Where
$$ occ_{i,j} ~ N(\gamma,\sigma)$$

```{r,eval=T}
setwd("C:/Users/Ben/Documents/Occupy/Bayesian")

runs<-40000

#Source model
source("Simulation3.R")
 
#print model
print.noquote(readLines("Simulation3.R"))

#Input Data
Dat <- list(
  Y=obs,
  Plants=plant_species,
  Birds=h_species,
  Months=months
  )

#A blank Y matrix - all present
initY<-matrix(nrow=h_species,ncol=plant_species,data=1)

#Inits
InitStage <- function() {list(tau=rep(.5,h_species),gamma=rep(.5,h_species),detect=rep(.5,h_species),present=initY)}

#Parameters to track
ParsStage <- c("occ","detect","gamma","sigma")

#MCMC options
ni <- runs  # number of draws from the posterior
nt <- runs*.001   #thinning rate
nb <- 0 # number to discard for burn-in
nc <- 2  # number of chains

#Jags

m3 = jags(inits=InitStage,
         n.chains=nc,
         model.file="Simulation3.jags",
         working.directory=getwd(),
         data=Dat,
         parameters.to.save=ParsStage,
         n.thin=nt,
         n.iter=ni,
         n.burnin=nb,
         DIC=T)
```

```{r,echo=FALSE,eval=F}
#Update if needed
recompile(m3)
add<-1000000
m3 <- update(m3,n.iter=add)
```

```{r}
  #extract desired info from the models
  parsO<-melt(m3$BUGSoutput$sims.array)
  colnames(parsO)<-c("Draw","Chain","parameter","estimate")
  parsO<-parsO[!parsO$Draw %in% 1:(max(parsO$Draw)-2000/m3$BUGSoutput$n.chains),]
  
  
  #label species and plants
  l<-levels(parsO$parameter)
  sp_pl<-data.frame(parameter=l,str_match(l,pattern="(\\d+),(\\d+)")[,-1],par=str_extract(l,c("detect|occ|gamma|sigma")))
  colnames(sp_pl)<-c("parameter","species","plant","par")

  sp_pl[is.na(sp_pl$species),c("species")]<-str_extract(sp_pl[is.na(sp_pl$species),"parameter"],"\\d+")
  pars<-merge(parsO,sp_pl)
  
  #take out deviance
  pars<-pars[pars$par %in% c("detect","occ","gamma","sigma"),]
  
```

###Assess Convergence

```{r,cache=FALSE,eval=TRUE,fig.width=10,fig.height=4}

###Chains
ggplot(pars[pars$par %in% c("detect","gamma","sigma"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_grid(par~species,scale="free") + theme_bw() + labs(col="Chain") + ggtitle("Detection Probability")

```

```{r,fig.height=5,fig.width=12}
ggplot(pars[pars$par %in% "occ",],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_grid(plant~species,scale="free") + theme_bw() + labs(col="Chain") + ggtitle("Occupancy Probability")

```

###Posteriors

```{r,cache=FALSE,fig.width=8,fig.height=4}
###Posterior Distributions
p<-ggplot(pars[pars$par %in% c("detect","gamma","sigma"),],aes(x=estimate)) + geom_histogram() + ggtitle("Estimate of parameters") + facet_grid(species~par,scale="free") + theme_bw() + ggtitle("Detection probability")
#Add true values
tr<-melt(data.frame(species=1:length(detection),detect=detection,gamma=gamma,sigma=sigma),id.var='species')
colnames(tr)<-c("species","par","value")
p + geom_vline(data=tr,aes(xintercept=value),col='red',linetype='dashed',size=1)
```

```{r,cache=FALSE,eval=TRUE,fig.height=6,fig.width=9}

p<-ggplot(pars[pars$par %in% "occ",],aes(x=estimate,fill=as.factor(plant))) + geom_histogram() + ggtitle("Estimate of parameters") + facet_grid(plant~species,scale="free") + theme_bw() + ggtitle("Occupancy probability") + labs(fill="Plant Species")

#Add true values
tr<-melt(occupancy)

colnames(tr)<-c("plant","species","value")

p + geom_vline(data=tr,aes(xintercept=value),linetype='dashed',size=1)
```

**True values are given in the dashed lines.**

```{r,eval=TRUE}
###Parameter estimates

parG<-group_by(pars,parameter)
out_m3<-summarise(parG,mean=mean(estimate),lower=quantile(estimate,0.025),upper=quantile(estimate,0.975),sd=sd(estimate))
```

#Simulation 4: Hierarchical occupancy with uneven sampling.

Here we assume that the probability of detection is related to abundance and the abundance of species is constant within the sampling window. Therefore each hummingbird species gets a detection probability, but each plant-hummingbird gets a occupancy. However, each plant is only in flower during a certain number of transects. Add a phenology parameter, expressed as a proportion of surveys where the plant is available.

### Parameters

  * 7 hummingbird species
  * Ten plants
  * Mean occupancy ($\gamma$) for each hummingbird is drawn from U(0.5,1)  
    * For each plant the occupancy is N($\gamma$,0.2) 
  * Imperfect detection $p = U(0,1)$ for each hummingbird species
  * 24 months replicates
  * Phenology = .75 (plants are in flower 3/4 of surveys)

```{r}
#Number of hummingbird species
h_species=7
plant_species=10
months=24
detection=runif(h_species,0,1)
phenology=0.75
#normally distributed centered on for each hummingbird species
gamma=runif(h_species,0.5,1)
sigma=runif(h_species,0.1,0.5)

#draw occupancy values for each plant
occupancy<-mapply(function(x,y){rnorm(plant_species,x,0.2)},gamma,sigma)

#truncate normal
occupancy[occupancy>1]<-1
occupancy[occupancy<0]<-0

#create data matrix
dat<-matrix(nrow=h_species,ncol=plant_species,data=rbinom(occupancy,1,occupancy))
```

### True Interaction Matrix

```{r}
#Reshape into a nicer format
mdat<-melt(dat)
colnames(mdat)<-c("Plant","Hummingbird","True_State")
trueplot<-ggplot(mdat,aes(x=as.factor(Plant),y=as.factor(Hummingbird),fill=as.factor(True_State))) + geom_tile() + scale_fill_manual(labels=c(0,1),values=c("White","Black")) + labs(x="Hummingbird",y="Plant",fill="Presence") + ggtitle("True State ")
```

```{r, fig.width=7,fig.height=4}
##Simulate detection 

#for each species loop through and create a replicate dataframe
obs<-array(dim=c(h_species,plant_species,months))

#Which months are plants in bloom?
#This is the phenology matrix
sampled<-replicate(plant_species,rbinom(months,1,phenology))
sampled[sampled==0]<-NA

for(x in 1:h_species){
  for (y in 1:plant_species){
    ts<-dat[x,y]
    
    #Detections
    d<-rbinom(months,1,detection[x])
    
    #detections are function of phenology detection probability and occupancy
    obs[x,y,]<-d *sampled[,y] * ts
    }
  }

#plot observed state
obs.state<-melt(obs)
colnames(obs.state)<-c("Hummingbird","Plant","Month","Presence")
obs.state<-group_by(obs.state,Hummingbird,Plant) %>% summarize(Detections=sum(Presence,na.rm=T))
obplot<-ggplot(obs.state,aes(x=Hummingbird,y=as.factor(Plant),fill=Detections)) + geom_tile() + scale_fill_continuous(low="white",high="Red") + ylab("Plant") + ggtitle("Observed")
grid.arrange(trueplot,obplot,nrow=1)
```

## Occupancy Model Formulation

$$ Y_{i,j,k} \sim Bern(sightp_{i,j,k})$$
$$sightp_{i,j,k} = present_{i,j} * detect_i$$
$$present_{i,j} \sim Bern(occ_{i,j}) $$

Where:

$$ occ_{i,j} ~ N(\gamma,\sigma)$$

```{r}
#for each hummingbird plant combination, we need a string of numbers for which months have plant presence.
#index of ragged array with Na's removed?
obsr<-melt(obs)
colnames(obsr)<-c("Hummingbird","Plant","Month","Presence")

obs_sample<-obsr[!is.na(obsr$Presence),]
```


```{r,eval=T}
setwd("C:/Users/Ben/Documents/Occupy/Bayesian")

runs<-40000

#Source model
source("Simulation4.R")
 
#print model
print.noquote(readLines("Simulation4.R"))

#Input Data
Dat <- list(
  Y=obs,
  Plants=plant_species,
  Birds=h_species,
  Months=months
  )

#A blank Y matrix - all present
initY<-matrix(nrow=h_species,ncol=plant_species,data=1)

#Inits
InitStage <- function() {list(tau=rep(.5,h_species),gamma=rep(.5,h_species),detect=rep(.5,h_species),present=initY)}

#Parameters to track
ParsStage <- c("occ","detect","gamma","sigma")

#MCMC options
ni <- runs  # number of draws from the posterior
nt <- runs*.001   #thinning rate
nb <- 0 # number to discard for burn-in
nc <- 2  # number of chains

#Jags

m4 = jags(inits=InitStage,
         n.chains=nc,
         model.file="Simulation4.jags",
         working.directory=getwd(),
         data=Dat,
         parameters.to.save=ParsStage,
         n.thin=nt,
         n.iter=ni,
         n.burnin=nb,
         DIC=T)
```

```{r,echo=FALSE,eval=F}
#Update if needed
recompile(m4)
add<-1000000
m4 <- update(m4,n.iter=add)
```

```{r}
  #extract desired info from the models
  parsO<-melt(m4$BUGSoutput$sims.array)
  colnames(parsO)<-c("Draw","Chain","parameter","estimate")
  parsO<-parsO[!parsO$Draw %in% 1:(max(parsO$Draw)-2000/m4$BUGSoutput$n.chains),]
  
  
  #label species and plants
  l<-levels(parsO$parameter)
  sp_pl<-data.frame(parameter=l,str_match(l,pattern="(\\d+),(\\d+)")[,-1],par=str_extract(l,c("detect|occ|gamma|sigma")))
  colnames(sp_pl)<-c("parameter","species","plant","par")

  sp_pl[is.na(sp_pl$species),c("species")]<-str_extract(sp_pl[is.na(sp_pl$species),"parameter"],"\\d+")
  pars<-merge(parsO,sp_pl)
  
  #take out deviance
  pars<-pars[pars$par %in% c("detect","occ","gamma","sigma"),]
  
```

###Assess Convergence

```{r,cache=FALSE,eval=TRUE,fig.width=9,fig.height=4}

###Chains
ggplot(pars[pars$par %in% c("detect","gamma","sigma"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_grid(par~species,scale="free") + theme_bw() + labs(col="Chain") + ggtitle("Detection Probability")

```

```{r,fig.height=5,fig.width=9}
ggplot(pars[pars$par %in% "occ",],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_grid(plant~species,scale="free") + theme_bw() + labs(col="Chain") + ggtitle("Occupancy Probability")
```

###Posteriors

```{r,cache=FALSE,fig.width=8,fig.height=5}
###Posterior Distributions
p<-ggplot(pars[pars$par %in% c("detect","gamma","sigma"),],aes(x=estimate)) + geom_histogram() + ggtitle("Estimate of parameters") + facet_grid(species~par,scale="free") + theme_bw() + ggtitle("Detection probability")

#Add true values
tr<-melt(data.frame(species=1:length(detection),detect=detection,gamma=gamma,sigma=sigma),id.var='species')
colnames(tr)<-c("species","par","value")
p + geom_vline(data=tr,aes(xintercept=value),col='red',linetype='dashed',size=1)
```

```{r,cache=FALSE,eval=TRUE,fig.height=6,fig.width=9}

p<-ggplot(pars[pars$par %in% "occ",],aes(x=estimate,fill=as.factor(plant))) + geom_histogram() + ggtitle("Estimate of parameters") + facet_grid(plant~species,scale="free") + theme_bw() + ggtitle("Occupancy probability") + labs(fill="Plant Species")

#Add true values
tr<-melt(occupancy)

colnames(tr)<-c("plant","species","value")

p + geom_vline(data=tr,aes(xintercept=value),linetype='dashed',size=1)
```

**True values are given in the dashed lines.**

```{r,eval=TRUE}
###Parameter estimates

parG<-group_by(pars,parameter)
out_m4<-summarise(parG,mean=mean(estimate),lower=quantile(estimate,0.025),upper=quantile(estimate,0.975),sd=sd(estimate))
```

# What have we learned so far?
  * Detection is easy to estimate.
  * Occupancy is harder to estimate
  * Adding a hierarchical term yields much better estimates of known values of occupancy
  * Given data sizes we are likely to see in the field, it is not possible to model every interaction seperately and get believable estimates.
  * Its unclear whether the lack of solid estimates in Simulation 2 especially is due to lack of convergence, or just not enough data.
  * I'm concerned about how high occupancy needs to be to estimatable.

#Simulation 5: Constant detection for each hummingbird speices, occupancy is function of species hierarcichal model and corolla similarity. Uneven sampling among species.

### Parameters

  * 7 hummingbird species
    * Range of bill sizes (mm) Pois(10)
  * Ten plants
    * Range of corolla sizes (mm) Pois(10)
  * Mean occupancy ($\gamma$) for each hummingbird is drawn from U(0.5,1)  
    * For each plant the occupancy is N($\gamma$,0.2) (truncated,0-1) 
    * Strong trait matching (minimizing Bill-Corolla difference)
      $logit(true_state)<-\alpha + \beta *traitmatch$
      where $\alpha=0, \beta = 1$
      
      * Keep it linear for now (only penalty for having increasingly smaller bill) 
  * Imperfect detection $p = U(0,1)$ for each hummingbird species
  * 24 month replicates
  * Phenology = .75 (plants are in flower 3/4 of surveys)

```{r,fig.height=5,fig.width=8}
#Number of hummingbird species
h_species=7
plant_species=20
months=24
detection=runif(h_species,0,1)
phenology=0.75

#Bill sizes
Bill<-rpois(h_species,10)

#Corolla sizes
Corolla<-rpois(plant_species,20)

#Subtract both
traitmatch<-sapply(Corolla,function(x) x - Bill)

#regression slope
intercept=0.5
gamma=-0.2
sigma_slope=0.01
sigma_intercept=0.01

beta<-rnorm(h_species,gamma,sigma_slope)
alpha<-rnorm(h_species,intercept,sigma_intercept)

#fit regression
occupancy<-inv.logit(alpha + beta * traitmatch)

df<-dcast(melt(list(occ=occupancy,traitmatch=traitmatch)),Var1+Var2~L1)
ggplot(df,aes(x=traitmatch,y=occ,shape=as.factor(Var1))) + geom_point(size=6) + geom_smooth(method="lm",aes(group=Var1)) + theme_bw() + labs(x="Bill-Corolla Difference",y="Occurrence Probability",shape="Hummingbird",col="Plant") + ggtitle("Correlation in Simulated Data")

#create data matrix
dat<-matrix(nrow=h_species,ncol=plant_species,data=rbinom(occupancy,1,occupancy))

```

### True Interaction Matrix

```{r}
#Reshape into a nicer format
mdat<-melt(dat)
colnames(mdat)<-c("Plant","Hummingbird","True_State")
trueplot<-ggplot(mdat,aes(x=as.factor(Plant),y=as.factor(Hummingbird),fill=as.factor(True_State))) + geom_tile() + scale_fill_manual(labels=c(0,1),values=c("White","Black")) + labs(x="Hummingbird",y="Plant",fill="Presence") + ggtitle("True State ")
```

```{r,fig.width=7,fig.height=3}
##Simulate detection 

#for each species loop through and create a replicate dataframe
obs<-array(dim=c(h_species,plant_species,months))

#Which months are plants in bloom?
#This is the phenology matrix
sampled<-replicate(plant_species,rbinom(months,1,phenology))
sampled[sampled==0]<-NA

for(x in 1:h_species){
  for (y in 1:plant_species){
    ts<-dat[x,y]
    
    #Detections
    d<-rbinom(months,1,detection[x])
    
    #detections are function of phenology detection probability and occupancy
    obs[x,y,]<-d *sampled[,y] * ts
    }
  }

#plot observed state
obs.state<-melt(obs)
colnames(obs.state)<-c("Hummingbird","Plant","Month","Presence")
obs.state<-group_by(obs.state,Hummingbird,Plant) %>% summarize(Detections=sum(Presence,na.rm=T))

obplot<-ggplot(obs.state,aes(x=Hummingbird,y=as.factor(Plant),fill=Detections)) + geom_tile() + scale_fill_continuous(low="white",high="Red") + ylab("Plant") + ggtitle("Observed")
grid.arrange(trueplot,obplot,nrow=1)
```

## Occupancy Model Formulation

$$ Y_{i,j,k} \sim Bern(sightp_{i,j,k})$$
$$sightp_{i,j,k} = present_{i,j} * detect_i$$
$$present_{i,j} \sim Bern(occ_{i,j}) $$
$$occ_{i,j}<-\alpha + \beta * (Bill_i - Corolla_i) $$

```{r,eval=T}
setwd("C:/Users/Ben/Documents/Occupy/Bayesian")

runs<-30000

#Source model
source("Simulation5.R")
 
#print model
print.noquote(readLines("Simulation5.R"))

#Input Data
Dat <- list(
  Y=obs,
  Plants=plant_species,
  Birds=h_species,
  Months=months,
  traitmatch=traitmatch
  )

#A blank Y matrix - all present
initY<-matrix(nrow=h_species,ncol=plant_species,data=1)

#Inits
InitStage <- function() {list(beta=rep(.5,h_species),alpha=rep(.5,h_species),detect=rep(.5,h_species),gamma=0,intercept=0,tau_alpha=0.1,tau_beta=0.1,present=initY)}

#Parameters to track
ParsStage <- c("occ","detect","alpha","beta","intercept","gamma","sigma_int","sigma_slope")

#MCMC options
ni <- runs  # number of draws from the posterior
nt <- runs*.001   #thinning rate
nb <- 0 # number to discard for burn-in
nc <- 2  # number of chains

#Jags

m5 = jags(inits=InitStage,
         n.chains=nc,
         model.file="Simulation5.jags",
         working.directory=getwd(),
         data=Dat,
         parameters.to.save=ParsStage,
         n.thin=nt,
         n.iter=ni,
         n.burnin=nb,
         DIC=T)
```

```{r,echo=FALSE,eval=F}
#Update if needed
recompile(m5)
add<-1000000
m5 <- update(m5,n.iter=add)
```

```{r}
  #extract desired info from the models
  parsO<-melt(m5$BUGSoutput$sims.array)
  colnames(parsO)<-c("Draw","Chain","parameter","estimate")
  parsO<-parsO[!parsO$Draw %in% 1:(max(parsO$Draw)-4000/m5$BUGSoutput$n.chains),]
  
  
  #label species and plants
  l<-levels(parsO$parameter)
  sp_pl<-data.frame(parameter=l,str_match(l,pattern="(\\d+),(\\d+)")[,-1],par=str_extract(l,c("detect|alpha|beta|sigma_int|sigma_slope|gamma|intercept")))
  colnames(sp_pl)<-c("parameter","species","plant","par")

  sp_pl[is.na(sp_pl$species),c("species")]<-str_extract(sp_pl[is.na(sp_pl$species),"parameter"],"\\d+")
  pars<-merge(parsO,sp_pl)
  
  #take out deviance
  pars<-pars[pars$par %in% c("detect","alpha","beta","gamma","intercept","sigma_int","sigma_slope"),]
  
```

###Assess Convergence

```{r,cache=FALSE,eval=TRUE,fig.width=8,fig.height=4}

###Chains
ggplot(pars[pars$par %in% c("detect","alpha","beta"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_grid(par~species,scale="free") + theme_bw() + labs(col="Chain") + ggtitle("Detection Probability")

```

```{r,fig.height=2,fig.width=12,eval=F}
ggplot(pars[pars$par %in% c("alpha","beta","sigma_int","sigma_slope"),],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + theme_bw() + labs(col="Chain") + ggtitle("Occupancy Probability") + facet_wrap(~par,scales="free")
```

###Posteriors

```{r,cache=FALSE,fig.width=9,fig.height=3}
###Posterior Distributions
p<-ggplot(pars[pars$par %in% c("detect"),],aes(x=estimate)) + geom_histogram() + ggtitle("Estimate of parameters") + facet_wrap(~species) + theme_bw() + ggtitle("Detection Probability")

#Add true values
tr<-melt(data.frame(species=1:length(detection),detect=detection),id.var='species')
colnames(tr)<-c("species","par","value")
p + geom_vline(data=tr,aes(xintercept=value),col='red',linetype='dashed',size=1)
```

```{r,cache=FALSE,eval=TRUE,fig.height=3,fig.width=10}

p<-ggplot(pars[pars$par %in% c("gamma","intercept","sigma_int","sigma_slope"),],aes(x=estimate)) + geom_histogram() + ggtitle("Trait matching regression parameters") + facet_grid(~par,scale="free") + theme_bw() 

#Add true values
tr<-melt(list(gamma=gamma,intercept=intercept,sigma_int=sigma_intercept,sigma_slope=sigma_slope))

colnames(tr)<-c("value","par")

p + geom_vline(data=tr,aes(xintercept=value),linetype='dashed',size=1,col="red")
```

**True values are given in the dashed lines.**

###Predicted Relationship
```{r,fig.height=4,fig.width=4}
 
castdf<-group_by(pars,Chain) %>% sample_n(1000)%>% select(par,estimate) %>% filter(par %in% c("gamma","intercept"))

castdf<-dcast(pars[pars$par %in% c("gamma","intercept"),], Chain + Draw~par,value.var="estimate")
castdf<-castdf[sample(1:nrow(castdf),1000),]

trajF<-function(alpha,beta,x){
  indat<-cbind(alpha,beta)
  
  #fit regression for each input estimate
  sampletraj<-apply(indat,1,function(s){
    data.frame(x=x,y=inv.logit(s['alpha'] + s['beta'] *x))})
  sample_all<-rbind_all(sampletraj)
  
  #Compute CI intervals
  predy<-group_by(sample_all,x) %>% summarise(lower=quantile(y,0.025),upper=quantile(y,0.975),mean=mean(y))
  }

#calculated predicted y
predy<-trajF(alpha=castdf$intercept,beta=castdf$gamma,x=as.numeric(traitmatch))

orig<-trajF(alpha=rnorm(2000,intercept,sigma_intercept),beta=rnorm(2000,gamma,sigma_slope),x=as.numeric(traitmatch))

#plot and compare to original data
ggplot(data=predy,aes(x=x)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.2)  + geom_line(aes(y=mean),size=1.1,col="red") + theme_bw() + ylab("Probability of Occurrence") + geom_ribbon(data=orig,aes(x=x,ymin=lower,ymax=upper),fill='blue',alpha=.5) + xlab("Difference between Bill and Corolla Length")
```

Black line is the true relationship - red line is the estimated relationship with confidence intervals in shaded grey. 

# Simulations to do
  * Hierarchical model where species-plant level covariates are estimated as a function of the species distrubtion * additional predictors such as traits and abundance of plants
  * Varying time models?
  * Get predicted networks based on output of models, need to build a function. Compare predicted and observed.

# Next steps

  *
  * Define closed population period
  * Create model comparison for env correlates
    * Elevation
    * Time
    * Behavioral Strategy (as defined by morphology or field observations)
  * Create predictions of interactions
  * Compare corrected and uncorrected interaction networks, models, and inferences.
  
```{r,echo=FALSE}
#save.image("C:/Users/Ben/Thesis/Occupancy/Simulation.RData")
```

