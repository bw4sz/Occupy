---
title: "Combining automated monitering and bayesian occupancy models for detecting rare plant-animal interactions"
author: "Ben Weinstein"
date: "Tuesday, February months, 2015"
output: html_document
---

```{r,warning=FALSE,message=FALSE,echo=FALSE}
library(reshape2)
library(ggplot2)
library(knitr)
library(R2jags)
library(dplyr)
opts_chunk$set(message=FALSE,warning=FALSE,fig.width=7,fig.height=4,echo=TRUE,cache=TRUE,cache.path = 'jp_cache/', fig.path='figure/',fig.align='center')

setwd("C:/Users/Ben/Documents/Occupy/")

set.seed(4)
```

#Aim

Network ecology is a rapidly developing field that uses graph theory to represents interactions among plants and pollinators, hosts and parasites, and herbivores and hosts. One aim of network ecology is to quantify the rate of interaction among partners, their relative specialization, and the robustness of these interactions to perturbation. Considerable work has focused on the effect sampling on network structure and how best to measure network properties (Bluthgen, Bascompte, Jordano). Considerably less work has focused on a more fundamental problem of network ecology: Our ability to detect interactions is imperfect in time and space. This limitation is a fundamental assumption in wildlife ecology, where occupancy models are common(). In occupancy modeling, repeated surveys of the same site are used to estimate the probability of detection given a species probability of occurrence. The probability of occurrence is a latent variable which cannot be directly infered from the data. If we did not see a species at a site, was it absent or undetected? By analogy, if we failed to find a pollinator interacting with a plant, is it due to detection or is it a 'forbidden link' due mismatch in species ecology? The goal of this paper is to use a large dataset on plant-hummingbird interactins from a tropical montane forest to evaluate the effect of imperfect detection on estimating species interactions and network properties. We will then seperate estimate environmental and morphological covariates to both the probability of interaction ($\psi$) as well as the probability of detection (p).

#Background

  Collecting network data is time consuming and few studies have the resources to adopt a repeated measures sampling design. The hummingbird dataset in this paper was collected using time-lapse cameras which turn on at dawn and dusk automatically. In addition, more traditional hummingbird transects were used to survey flower visitation. Combining these sampling types, we have a very large network with over 3,000 interactions (Weinstein XXXX).

#Similiar work

Unfortunately someone already did this:
http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0069200

How can i take it a step further to actually make ecological inference?

#Approach

Potential comparisons

* Transects versus cameras
* Corrected versus uncorrected network statistics
* Simulations - networks with imperfect detection - what are the biases?


**In this study we want to estimate three quantitites:**

$$\hat{Y}_{i,j} = \text{Detection  of  Hummingbird i  at  Flower j}$$

$$ \psi_{i,j} = \text{the probability a flower is visited by a hummigbird}  $$

$$ p = \text{the probability of detecting a species as present} $$

#Simulations

Consider a matrix of interactions, where we assume interactions among plants and hummingbirds are independent.

Simulation parameters

  * 1 hummingbird
  * Ten plants
  * Known occupancy $\psi = .6$ for all species
  * Imperfect detection $p = .4$ for all species
  * 24 Months replicates

** Can we recover these parameters? **

```{r}
#Number of hummingbird species
h_species=1
plant_species=10
months=24
detection=.4
occupancy=.6
dat<-replicate(h_species,rbinom(plant_species,1,occupancy))
```

True Interaction Matrix

* Rows are plants
* Columns are hummingbirds

```{r}
print(dat)
```

```{r,fig.height=2,fig.width=8,fig.align='center'}
#Reshape into a nicer format
mdat<-melt(dat)
colnames(mdat)<-c("Plant","Hummingbird","True_State")
ggplot(mdat,aes(x=as.factor(Plant),y=as.factor(Hummingbird),fill=as.factor(True_State))) + geom_tile() + scale_fill_manual(labels=c(0,1),values=c("White","Black")) + labs(x="Plant",y="Hummingbird",fill="Presence") + ggtitle("True State")
```

##Simulate detection 

```{r}

#for each species loop through and create a replicate dataframe
obs<-list()

for (x in 1:h_species){
  #How many detections?
  size<-nrow(mdat[mdat$True_State==1,])
  
  #Simualte detections for species with presences
  pres<-replicate(months,rbinom(size,1,detection))
  #fill in 0's for species with absences
  ab<-replicate(months,rep(0,plant_species-size))
  obs[[x]]<-rbind(pres,ab)
}

mobs<-melt(obs)
colnames(mobs)<-c("Plants","Month","Detection","Hummingbird")

mobs<-dcast(mobs,Plants~Month,value.var="Detection")
```

So let's look at example. 

Hummingbird 1 on Plant 1 - True State is Present
```{r}
dat[1,1]
```

Observed state from transect data
```{r}
obs[[1]][1,]
```

##Hierarchical model for the interaction of each hummingbird on each plant species

$$ Y_{i,j} \sim Bern(sightp_{i,j})$$
$$sightp_{i,j} = present_i * detect$$
$$present_i \sim Bern(presentp) $$
$$presentp_{i,j}<-occ $$

```{r,echo=FALSE,eval=TRUE}
setwd("C:/Users/Ben/Documents/Occupy/Bayesian")

#Source model
source("Simulation.R")
 
#print model
print.noquote(readLines("Simulation.R"))

#Input Data
Dat <- list(
  Y=obs[[1]],
  Plants=plant_species,
  Months=months
  )

#A blank Y matrix - all present
initY<-as.numeric(matrix(nrow=plant_species,ncol=1,data=1))

#Inits
InitStage <- function() {list(occ=.5,detect=.5,present=initY)}

#Parameters to track
ParsStage <- c("occ","detect")

#MCMC options
ni <- 200000  # number of draws from the posterior
nt <- 2    #thinning rate
nb <- 0  # number to discard for burn-in
nc <- 2  # number of chains

#Jags

m = jags(inits=InitStage,
         n.chains=nc,
         model.file="Simulation.jags",
         working.directory=getwd(),
         data=Dat,
         parameters.to.save=ParsStage,
         n.thin=nt,
         n.iter=ni,
         n.burnin=nb,
         DIC=T)
```


```{r,cache=FALSE}
DIC_BRUTE<-m$BUGSoutput$DIC

#Remove Burnin
parsO<-melt(m$BUGSoutput$sims.array)
colnames(parsO)<-c("Draw","Chain","parameter","estimate")
parsO<-parsO[!parsO$Draw %in% 1:20000,]
#take out deviance
pars<-parsO[parsO$parameter %in% c("detect","occ"),]
```


###Assess Convergence
```{r,cache=FALSE,eval=TRUE}
###Chains
ggplot(pars,aes(x=Draw,col=as.factor(Chain),y=estimate)) + geom_line() + facet_wrap(~parameter,scale="free") + theme_bw() + labs(col="Chain") 


```

###Posteriors
```{r,cache=FALSE,eval=TRUE}
###Posterior Distributions
p<-ggplot(pars,aes(x=estimate)) + geom_histogram() + ggtitle("Estimate of parameters") + facet_wrap(~parameter,scale="free") + theme_bw() 

#Add true values
tr<-data.frame(parameter=c('detect','occ'),value=c(detection,occupancy))
p + geom_vline(data=tr,aes(xintercept=value),col='red',linetype='dashed')
```

**True values are given in the red dashed lines.**

```{r}
parG<-group_by(pars,parameter)
out_brute<-summarise(parG,mean=mean(estimate),lower=quantile(estimate,0.025),upper=quantile(estimate,0.975),sd=sd(estimate))
out_brute
```

##Conclusion

We were able to recover the true data, suggesting this modeling approach has real applications to these kinds of datasets.

